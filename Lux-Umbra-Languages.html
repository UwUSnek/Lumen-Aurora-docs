<!DOCTYPE html>


<html>
<head>
    <title>Umbra | Lux</title>
    <meta charset="UTF-8">
    <meta name="author" content="Snek" />
    <meta name="description" content="Umbra and Lux languages specification"/>
    <link rel="icon" href="Logos/Lux.png" type="image/png">
    <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, width=device-width, user-scalable=no"/>
    <link rel="stylesheet" type="text/css" href="Styles/main.css" media="screen">
</head>
















<body onresize="ui_slider._onresize()">
    <div id="main-mask" class="main-mask"></div>
    <input type="range" min="0" max="99999999" value="0" step="0.00001" class="slider" id="main-slider">
    <left- class="hide-scrollbar" id="main-left">
<index- class="hide-scrollbar"><indexh-></indexh->
    <index-><indexh->overview</indexh->
        <indexd->typographical-conventions</indexd->
    </index->



    <index-separator-></index-separator->



    <index-><indexh->preprocessor</indexh->
        <indexd->comments</indexd->
        <indexd->include-statement</indexd->
        <indexd->macros</indexd->
        <indexd->conditionals</indexd->
        <indexd->line-continuation-token</indexd->
    </index->



    <index-separator-></index-separator->



    <index-><indexh->language-|-summary</indexh->
        <index-><indexh->language-structure</indexh->
            <indexd->character-set</indexd->
            <index-><indexh->syntactic-elements</indexh->
                <indexd->keywords</indexd->
                <indexd->meta-keywords</indexd->
                <indexd->literal-tokens</indexd->
                <indexd->identifiers</indexd->
            </index->
            <index-><indexh->semantic-elements</indexh->
                <indexd->language-structure.directives</indexd->
                <indexd->language-structure.declarations</indexd->
                <indexd->language-structure.statements</indexd->
                <indexd->language-structure.expressions</indexd->
                <indexd->language-structure.paths</indexd->
            </index->
        </index->
        <index-><indexh->concepts</indexh->
            <index-><indexh->scopes</indexh->
                <indexd->name-resolution</indexd->
                <indexd->name-shadowing</indexd->
                <indexd->multiple-declarations</indexd->
            </index->
            <indexd->left-and-right-values</indexd->
            <indexd->undefined-values</indexd->
            <indexd->undefined-behaviour</indexd->
            <indexd->compile-time-expressions</indexd->
        </index->
    </index->



    <index-separator-></index-separator->



    <index-><indexh->language-|-details</indexh->
        <index-><indexh->directives</indexh->
            <indexd->import-directive</indexd->
            <indexd->export-directive</indexd->
            <indexd->construct-directive</indexd->
        </index->
        <index-><indexh->types</indexh->
            <index-><indexh->primitive-types</indexh->
                <indexd->integral-types</indexd->
                <indexd->floating-point-types</indexd->
                <indexd->boolean-type</indexd->
            </index->
            <index-><indexh->enums</indexh->
                <indexd->struct-enums</indexd->
                <indexd->automatic-enum-scoping</indexd->
            </index->
            <index-><indexh->structs</indexh->
                <indexd->struct-methods</indexd->
                <indexd->constructor-function</indexd->
                <indexd->destructor-function</indexd->
                <indexd->struct-specialization</indexd->
            </index->
            <index-><indexh->special-types</indexh->
                <indexd->void-type</indexd->
                <indexd->pointer-types</indexd->
                <indexd->function-types</indexd->
            </index->
            <indexd->const-qualifier</indexd->
            <indexd->auto-specifier</indexd->
            <indexd->typeof-specifier</indexd->
            <index-><indexh->implicit-conversions</indexh->
                <indexd->implicit-conversions.primitive-types</indexd->
                <indexd->implicit-conversions.enums</indexd->
                <indexd->implicit-conversions.pointer-types</indexd->
                <indexd->implicit-conversions.constness-conversions</indexd->
            </index->
        </index->
        <index-><indexh->expressions</indexh->
            <index-><indexh->inline-values</indexh->
                <indexd->literals</indexd->
                <indexd->function-calls</indexd->
                <indexd->operator-calls</indexd->
                <indexd->try-expression</indexd->
            </index->
            <index-><indexh->stored-values</indexh->
                <indexd->variables</indexd->
                <indexd->temporary-variables</indexd->
                <indexd->exp.routine-parameters</indexd->
            </index->
        </index->
        <index-><indexh->routines</indexh->
            <indexd->routine-parameters</indexd->
            <index-><indexh->functions</indexh->
                <indexd->function-declarations</indexd->
                <indexd->the-main-function</indexd->
                <indexd->default-values</indexd->
                <indexd->parameter-packs</indexd->
            </index->
            <index-><indexh->operators</indexh->
                <indexd->operator-declarations</indexd->
                <indexd->operator-precedence</indexd->
                <indexd->reference-parameters</indexd->
            </index->
            <indexd->routine-specialization</indexd->
        </index->
        <index-><indexh->templates</indexh->
            <indexd->template-declarations</indexd->
            <indexd->template-parameters</indexd->
            <indexd->template-parameter-packs</indexd->
            <indexd->abbreviated-template-syntax</indexd->
            <indexd->multi-argument-type-deduction</indexd->
        </index->
        <index-><indexh->statements</indexh->
            <index-><indexh->selection</indexh->
                    <indexd->if-statement</indexd->
                    <indexd->match-statement</indexd->
            </index->
            <index-><indexh->iteration</indexh->
                <indexd->for-loops</indexd->
                <indexd->while-loops</indexd->
                <indexd->continue-and-break-statements</indexd->
                <indexd->once-statement</indexd->
                <indexd->then-statement</indexd->
            </index->
            <index-><indexh->non-local-flow-control</indexh->
                <indexd->return-statement</indexd->
                <indexd->defer-statement</indexd->
            </index->
            <index-><indexh->statements.misc</indexh->
                <indexd->else-statement</indexd->
                <indexd->expression-statement</indexd->
                <indexd->empty-statement</indexd->
                <indexd->unnamed-scope</indexd->
            </index->
        </index->
        <index-><indexh->misc</indexh->
            <indexd->declarations.namespaces</indexd->
            <indexd->symbol-aliases</indexd->
            <indexd->inline-declarations</indexd->
            <indexd->inline-glsl</indexd->
        </index->
        <index-><indexh->reflection</indexh->
        </index->
        <index-><indexh->syntactic-sugar</indexh->
        </index->
    </index->



    <index-separator-></index-separator->



    <index-><indexh->compilation</indexh->
        <indexd->modules</indexd->
        <indexd->compilation-phases-and-error-types</indexd->
        <indexd->global-initialization-order</indexd->
        <index-><indexh->runtime-performance</indexh->
            <indexd->value-precomputation</indexd->
            <indexd->branching-performance</indexd->
        </index->
    </index->



    <index-separator-></index-separator->



    <index-><indexh->core-module</indexh->
        <index-><indexh->core.operators</indexh->
            <indexd->common-operators</indexd->
            <indexd->arithmetic-operators</indexd-> 
            <indexd->logical-operators</indexd-> 
            <indexd->bitwise-operators</indexd-> 
            <indexd->relational-operators</indexd-> 

            <indexd->assignment-operators</indexd->
            <indexd->special-operators</indexd->
            <indexd->arithmetic-exceptions</indexd->
            <indexd->array-operations</indexd->
        </index->
        <index-><indexh->core.data-types</indexh->
            <indexd->core.arrays</indexd->
            <indexd->core.tuples</indexd->
        </index->
    </index->



    <index-separator-></index-separator->



    <index-><indexh->standard-modules</indexh->
        <indexd->limits-module</indexd->
        <indexd->math-module</indexd->
        <indexd->bits-module</indexd->
        <indexd->types-module</indexd->
        <indexd->memory-module</indexd->
    </index->



    <index-separator-></index-separator->



    <index-><indexh->quick-reference-tabs</indexh->
        <index-><indexh->syntaxes</indexh->
            <indexd->preprocessor-syntaxes</indexd->
            <indexd->misc-syntaxes</indexd->
            <indexd->symbol-declarations</indexd->
            <indexd->statement-syntaxes</indexd->
            <indexd->expression-syntaxes</indexd->
        </index->
        <index-><indexh->undefined-behaviours</indexh->
            <indexd->conversions</indexd->
            <indexd->core-module-operators</indexd->
            <indexd->math-module-functions</indexd->
        </index->
    </index->

    <index-separator-></index-separator->

    <indexd->omitted-features</indexd->
    <indexh-></indexh->
</index->
    </left->

    <right- id="main-right">
        <div id="main-right-tab-container">
            <div id="main-right-doc" class="hide-scrollbar">
                <logo-top-></logo-top->
                <logo- style="background-image: url('Logos/Photon.png');"></logo->

                <main-right-doc-scroll->


<div style="margin-top: var(--main-padding-r);"></div>
<h1 id="overview"></h1>
<p>
    Umbra and Lux are <b>high level procedural compiled languages</b> with the aim of abstracting GPU rendering while preserving the runtime performance of low level languages.
    This is achieved through a built-in rendering support and a powerful optimizer.<br>
</p>
<p>
    The languages are organized in modules and share the same compiler.<br>
    A static type system is used to improve readability and minimize runtime errors.<br>
    A reference counter manages the lifespan of variables and memory blocks.
</p>
<p>
    <div style="display: inline-block; min-width: 10ch"><umbra-logo-></umbra-logo-> Umbra</div>- Programming language.<br>
    <div style="display: inline-block; min-width: 10ch"><lux-logo-></lux-logo-> Lux</div>- Shading language. Subset of Umbra.
</p>
<p>
    Umbra and Lux are part of the <b>Photon SDK</b>.<br>
    Details on the internal structure of the compiler are available <a href="./Internal.html">Here</a>.
</p>
<p><a href="#quick-reference-tabs">Quick reference tabs</a></p>


<logo- style="background-image: url('Logos/Lux.png');"></logo->
<logo- style="background-image: url('Logos/Umbra.png');"></logo->


<h1 id="typographical-conventions"></h1>
<p>
    //TODO move the "alphanumeric or symbolic" stuff here
</p>
<p>
    <s-vbtm- class="syntax-glossary">x             </s-vbtm-> The literal character "x"<br>
    <s-any-  class="syntax-glossary">x             </s-any->  x is an user-defined sequence of characters<br>
    <s-sub-  class="syntax-glossary">x             </s-sub->  x is a semantic sub-element<br>
    <s-decl- class="syntax-glossary">x             </s-decl-> x is a declaration<br>
    <s-expr- class="syntax-glossary"><t->[t]</t-> x</s-expr-> x is an expression of type t<br>
    <s-path- class="syntax-glossary">x             </s-path-> x is a symbol path<br>
    <s-sgr-  class="syntax-glossary">x             </s-sgr->  x is syntactic sugar
</p>


<h1 id="preprocessor"></h1>
<p>
    The <b>preprocessing</b> phase <b>precedes</b> the code <b>compilation</b>.<br> //TODO
    It removes <a href="#comments">comments</a> and evaluates preprocessor directives and <a href="#line-continuation-token">line continuation tokens</a>.
</p>
<p>
    <b>Preprocessor directives</b> are special instructions that allow the <b>code</b> to be <b>programmatically modified</b>.<br>
    All the preprocessor directives are identified by the <code>#</code> character followed by their name and definition.<br>
    Each directive spans over a single line of code.<br>
    Preprocessor directives are always case sensitive.
</p>


<h1 id="comments"></h1>
<p>
    <b>Comments</b> are <b>portions of code</b> that are <b>intentionally ignored</b>.<br>
    They can be used to provide informations or temporarily exclude lines of code.<br>
    Comments are allowed to contain any sequence of unicode characters of any length.<br>
</p>
<p>
    Single line comments start with <code>//</code> and end at the next newline character (\n).<br>
    Multiline comments start with <code>/*</code> and end with <code>*/</code>.<br>
</p>
<p>
    Comments cannot be nested.
    Not closing a comment is allowed.
</p>

<syntax->
    <label- id="copy.syntax--preprocessor-comment">Syntax</label->
</syntax->
<example- class="full-example">
    <label->Example 1</label->
    <div>
        <c->// Single line comment</c->

        <c->/* Multi</c->
        <c->line</c->
        <c->comment */</c->

        <c->/* Another multiline comment</c->
    </div>
    <label->Example 2</label->
    <div>
        <c->/* Multi line /* Another comment */ comment */</c->
                                         <ce->// ^ Error, unexpected token "comment"</ce->
    </div>
</example->



<h1 id="include-statement"></h1>
<p>
    The <b>include statement</b> is used to <b>paste code</b> from other files.<br>
    Any existent file can be included, regardless of its content or extension.<br>
    The path of the included file must be enclosed in <code>"</code> <code>"</code> characters.<br>
    <a href="#standard-modules">Standard modules</a> are included using the <code>&lt;</code> <code>&gt;</code> characters.<br>
    The <a href="#core-module">core module</a> cannot be included.
</p>
<p>
    Absolute and relative paths are both supported.<br>
    Relative paths are relative to the file the include statement is used in and any specified include path.<br>
    <code>~</code> is not recognized as the home directory but as the literal character <code>~</code>.<br>
    <code>/</code> identifies the root directory.<br>
    <code>.</code> identifies the current directory, while <code>..</code> identifies the parent directory.
</p>
<p>
    The preprocessor supports the <code>**</code> (any sequence of characters including <code>/</code>), </code><code>*</code> (any sequence of characters but <code>/</code>) and <code>?</code> (any character) wildcards of Glob patterns.<br>
    Glob patterns that don't match any file are allowed and have no effect.
</p>
<p>
    Files cannot be named <code>.</code> or <code>..</code> and their name cannot contain the <code>/</code> character.<br>
    Any other character is allowed, including <code>*</code>, <code>?</code>, <code>"</code>, <code>&lt;</code> <code>&gt;</code> and <code>&bsol;</code>.<br>
    These characters can be escaped by preceding them with a single <code>&bsol;</code> character.<br>
    Unknown escape sequences generate a preprocessing error. //TODO LINK
</p>
<syntax->
    <label- id="copy.syntax--preprocessor-include">Syntax</label->
</syntax->
<example- class="full-example">
    <label->Example</label->
    <div>
        <k->#include</k-> <s->"/home/Photon/Lux/file.lux"</s->      <c->// Ok, absolute path</c->
        <k->#include</k-> <s->"./file.lux"</s->                     <c->// Ok, relative path</c->
        <k->#include</k-> <s->":</s-><sr->&bsol;</sr-><s->&bsol; why is this a file name</s-><sr->&bsol;</sr-><s->?"</s->  <c->// Ok, relative path</c->
        <k->#include</k-> <s->"*.lux"</s->                          <c->// Ok, includes any file with lux extension in any include path</c->
        <k->#include</k-> <s->"**/*.lux"</s->                       <c->// Ok, includes any file with lux extension in any include path, recursively</c->
        <k->#include</k-> <s->&lt;math&gt;</s->                           <c->// Ok, includes the standard module "math"</c->

        <c->//#include ./file.ilsh</c->                    <ce->// Error, "" or &lt;&gt; are required</ce->
        <c->//#include "./non_existent_file"</c->          <ce->// Error, non-glob patterns must correspond to an existing file</ce->
        <c->//#include ""</c->                             <ce->// Error, file name not specified</ce->
    </div>
</example->



<h1 id="macros"></h1>
//TODO



<h1 id="conditionals"></h1>
//TODO



<h1 id="line-continuation-token"></h1>
<p>
    The <b>line continuation token</b> can be used to <b>merge multiple lines</b> and allow single line <a href="#comments">comments</a>, preprocessor directives and multi character <a href="#syntactic-elements">tokens</a> to be written across multiple lines.<br>
    It consists of a <code>&bsol;</code> immediatly followed by a newline character.
</p>
<p>
    Line continuation tokens can be used inside <a href="#comments">comments</a> or preprocessor directives but cannot be nested.<br>
    Using a line continuation token as the last character of a file is allowed and has no effect.
</p>

<syntax->
    <label- id="copy.syntax--preprocessor-line-continuation-token">Syntax</label->
</syntax->

<example- class="full-example">
    <label->Example 1</label->
    <div>
        <c->// single line comment</c-><sg->&bsol;</sg->
        <c->on two lines</c->

        <c->// #include &lt;math&gt;</c->
        <k->#include</k-> <s->&lt;ma</s-><sg->&bsol;</sg->
        <s->th</s-><sg->&bsol;</sg->
        <s->&gt;</s->

        <c->// void function() {</c->
        <c->//   uint var = 0, b = 0;</c->
        <c->//   var += b;</c->
        <c->// }</c->
        <t->vo</t-><sg->&bsol;</sg->
        <t->id</t-> <f->fun</f-><sg->&bsol;</sg->
        <f->ction</f->() {
        <t->uint</t-> va<sg->&bsol;</sg->
        r = <k->0</k->, b = <k->0</k->;
        v<sg->&bsol;</sg->
        ar +<sg->&bsol;</sg->
        <sg->&bsol;</sg->
        = <k->b</k->;
        }
    </div>
    <label->Example 2</label->
    <div>
        <ce->// Error, unexpected token "\"</ce->
        <t->void</t-> ma&bsol;<sg->&bsol;</sg->

        in(){}
        <ce->// Error,  unexpected token "in"</ce->
    </div>
</example->



<h1 id="language-|-summary"></h1>


<h1 id="language-structure"></h1>
<p>
    //TODO this works as a summary for the elements of the language
</p>


<h1 id="character-set"></h1>
<p>
    After the <a href="#preprocessor">preprocessing phase</a>, only a <b>small number</b> of <b>characters</b> are left.<br>
    These characters <b>compose the <a href="#syntactic-elements">syntactic elements</a></b> that are used in the compilation phase.<br>
    Any unknown character generates a syntactic error. //TODO LINK
</p>
<p>
    The allowed characters are:
</p>
<p>
    <code>a</code> <code>b</code> <code>c</code> <code>d</code> <code>e</code> <code>f</code> <code>g</code> <code>h</code> <code>i</code> <code>j</code> <code>k</code> <code>l</code> <code>m</code>
    <code>n</code> <code>o</code> <code>p</code> <code>q</code> <code>r</code> <code>s</code> <code>t</code> <code>u</code> <code>v</code> <code>w</code> <code>x</code> <code>y</code> <code>z</code><br>
    <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> <code>K</code> <code>L</code> <code>M</code>
    <code>N</code> <code>O</code> <code>P</code> <code>Q</code> <code>R</code> <code>S</code> <code>T</code> <code>U</code> <code>V</code> <code>W</code> <code>X</code> <code>Y</code> <code>Z</code><br>
    <code>0</code> <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>8</code> <code>9</code> <code>_</code><br>
    <code>!</code> <code>$</code> <code>%</code> <code>&</code> <code>(</code> <code>)</code> <code>*</code> <code>+</code> <code>-</code> <code>/</code> <code>:</code> <code>&lt;</code> <code>=</code>
    <code>&gt;</code> <code>?</code> <code>@</code> <code>^</code> <code>`</code> <code>|</code> <code>~</code> <code>;</code> <code>{</code> <code>}</code> <code>[</code> <code>]</code> <code>.</code><br>
    <code><space-></space-></code> <code><tab-></tab-></code> <code><nl-></nl-></code>
</p>
<p>
    String <a href="#literals">literals</a> can contain any unicode character. They are converted to allowed characters during the compilation phase.//TODO<br>
    Carriage return characters (\r) are ignored.
</p>


<h1 id="syntactic-elements"></h1>
<p>
    <b>Syntactic elements</b>, or Tokens, are the fundamental elements of the source code of any program.<br>
    They are <b>sequences</b> of one or more <a href="#character-set">allowed <b>characters</b></a> that follow specific patterns.<br>
    One or more syntactic elements create a <a href="#semantic-elements">semantic element</a>.
</p>
<p>
    A syntactic element ends when a character that isn't allowed in its pattern is encountered. //TODO   ".:"    "(?"    and similar cases
    Syntactic elements can also be separated by any number of <code><tab-></tab-></code>, <code><space-></space-></code> and <code><nl-></nl-></code> characters or <a href="#comments">comments</a>.<br>
    Sequences of characters that don't follow any of the recognizes patterns generate a syntactic error. //TODO LINK
</p>
<p>
    Syntactic elements are case sensitive, with the only exception of hexadecimal <a href="#literals">literals</a>.<br>
    <code><tab-></tab-></code>, <code><space-></space-></code> and <code><nl-></nl-></code> characters are not syntactic elements.
</p>
<p>
    Syntactic elements are divided in 4 categories:
</p>

<div class="table-container"><table>
    <thead>
        <tr>
            <th>Category</th>
            <th style="text-align: center;" colspan="4">Pattern</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th class="nowrap medium"><a href="#keywords">Keyword</a></th>
            <td><div class="split-td-outer">
                <div class="split-td">
                    <a href="#namespaces">                   <code><w->namespace</w-></code></a>
                    <a href="#enums">                        <code><w->enum</w-></code></a>
                    <a href="#structs">                      <code><w->struct</w-></code></a>
                    <a href="#const-qualifier">              <code><t->const</t-></code></a>
                    <a href="#auto-specifier">               <code><t->auto</t-></code></a>
                    <a href="#typeof-specifier">             <code><t->typeof</t-></code></a>
                    <a href="#symbol-aliases">               <code><w->alias</w-></code></a>
                    <a href="#import-directive">             <code><w->from</w-></code></a>
                    <a href="#import-directive">             <code><w->import</w-></code></a>
                    <a href="#import-directive">             <code><w->include</w-></code></a>
                    <a href="#export-directive">             <code><w->export</w-></code></a>
                    <a href="#boolean-type">                 <code><k->true</k-></code></a>
                    <a href="#boolean-type">                 <code><k->false</k-></code></a>
                    <a href="#pointer-types">                <code>@</code></a>
                    <a href="#pointer-types">                <code>$</code></a>
                </div>
                <div class="split-td">
                    <a href="#if-statement">                 <code><w->if</w-></code></a>
                    <a href="#match-statement">              <code><w->match</w-></code></a>
                    <a href="#for-loops">                    <code><w->for</w-></code></a>
                    <a href="#while-loops">                  <code><w->while</w-></code></a>
                    <a href="#while-loops">                  <code><w->do</w-></code></a>
                    <a href="#continue-and-break-statements"><code><w->continue</w-></code></a>
                    <a href="#continue-and-break-statements"><code><w->break</w-></code></a>
                    <a href="#once-statement">               <code><w->once</w-></code></a>
                    <a href="#then-statement">               <code><w->then</w-></code></a>
                    <a href="#else-statement">               <code><w->else</w-></code></a>
                    <a href="#return-statement">             <code><w->return</w-></code></a>
                    <a href="#defer-statement">              <code><w->defer</w-></code></a>
                </div>
                <div class="split-td">
                    <elm->                                   <code>(</code><code>)</code></elm->
                    <a href="#scopes-and-symbols">           <elm-><code>{</code><code>}</code></elm-></a>
                    <a href="#string-literals">              <elm-><code>"</code><code>"</code></elm->
                    <a href="#statements">                   <code>,</code></a>
                    <a href="#statements">                   <code> ;</code></a>
                    <a href="#scopes-and-symbols">           <code>.</code></a>
                    <a href="#reflection">                   <code>::</code></a>
                </div>
            </div></td>
        </tr>
        <tr>
            <th class="nowrap medium"><a href="#meta-keywords">Meta keyword</a></th>
            <td><div class="split-td-outer">
                <div class="split-td">
                    <a href="#templates">                       <code><w->template</w-></code></a>
                    <a href="#templates">                       <elm-><code>&lt;</code><code>&gt;</code></elm->
                    <a href="#template-parameters">             <code><w->type</w-></code></a>
                    <a href="#template-parameters">             <code>!</code></a>
                    <a href="#abbreviated-template-syntax">     <code>?</code></a>
                </div>
                <div class="split-td">
                    <a href="#specialization-constraint">       <code><w->when</w-></code></a>
                    <a href="#declarations.operator-precedence"><code><w->priority</w-></code></a>
                    <code><w->as</w-></code>
                    <code><w->to</w-></code>
                    <code>=</code>
                    <a href="enums"><code>:</code></a>
                    <code>...</code>
                    <a href="#reference-parameters"><code>&</code></a>
                </div>
            </div></td>
        </tr>
        <tr>
            <th class="nowrap medium"><a href="#literals">Literal</a></th>
            <td><div class="split-td-outer">
                <div clas="split-td">
                    Any sequence of characters with pattern
                    <code><sg->[</sg-><s->0</s-><sr->-</sr-><s->9</s-><sg->][</sg-><s->a</s-><sr->-</sr-><s->zA</s-><sr->-</sr-><s->Z</s-><s->_</s-><sg->]</sg-><sr->*</sr-><sg->(</sg-><sr->\</sr-><s->.</s-><sg->[</sg-><s->a</s-><sr->-</sr-><s->zA</s-><sr->-</sr-><s->Z</s-><s->_</s-><sg->]</sg-><sr->*</sr-><sg->)</sg-><sr->?</sr-></code>
                </div>
            </div></td>
        </tr>
        <tr>
            <th class="nowrap medium"><a href="#identifiers">Identifier</a></th>
            <td><div class="split-td-outer">
                <div clas="split-td">
                    Any sequence of characters with pattern
                    <code><sg->[</sg-><s->a</s-><sr->-</sr-><s->zA</s-><sr->-</sr-><s->Z_</s-><sg->][</sg-><s->a</s-><sr->-</sr-><s->zA</s-><sr->-</sr-><s->Z_0</s-><sr->-</sr-><s->9</s-><sg->]</sg-><sr->*</sr-></code>
                    or
                    <code><sg->[</sg-><s->!$%&*+</s-><sr->\</sr-><s->-/:&lt;=&gt;?@^`|~;</s-><sr->\</sr-><s->[</s-><sr->\</sr-><s->]</s-><sr->\</sr-><s->.</s-><sg->]</sg-><sr->+</sr-></code>
                    that isn't a <a href="#keywords">keyword</a>
                </div>
            </div></td>
        </tr>
    </tbody>
</table></div>


<h1 id="keywords"></h1>
<p>
    <b>Keywords</b> are <b>built-in <a href="#syntactic-elements">syntactic elements</a></b> that perform hard coded actions or have <b>special meaning</b>.<br>
    The language defines a total of 28 alphanumeric keywords and 6 symbolic keywords.<br>
    Their usage is detailedly explained in their respective sections.
</p>
<ul>
    <li>Semantic keywords</li>
    <ul class="summary-list">
        <li>
            <span><a href="#namespaces"><code><w->namespace</w-></code></a></span>
            <span>Used to declare a <a href="#namespaces">namespace</a>.</span>
        </li>
        <li>
            <span><a href="#enums"><code><w->enum</w-></code></a></span>
            <span>Used to declare an <a href="#enums">enum</a>.</span>
        </li>
        <li>
            <span><a href="#structs"><code><w->struct</w-></code></a></span>
            <span>Used to declare a <a href="#structs">struct</a>.</span>
        </li>
        <li>
            <span><a href="#const-qualifier"><code><t->const</t-></code></a></span>
            <span>Specifies that a pointer type is const. Also used to declare const variables and routine parameters.</span>
        </li>
        <li>
            <span><a href="#auto-specifier"><code><t->auto</t-></code></a></span>
            <span>Can be used in place of the <a href="#types">type</a> in the declaration of a <a href="#variables">variable</a>, a <a href="#routine-parameters">routine parameter</a> or a <a href="#routines">routine</a> to automatically use the best type based on its initializer <a href="#values">value</a> or return value.</span>
        </li>
        <li>
            <span><a href="#typeof-specifier"><code><t->typeof</t-></code></a></span>
            <span>Retrieves the <a href="#types">type</a> of an <a href="#expressions">expression</a>.</span>
        </li>
        <li>
            <span><a href="#symbol-aliases"><code><w->alias</w-></code></a></span>
            <span>Creates an alternative <a href="#name-resolution">path</a> for a <a href="#semantic-elements">symbol</a>.</span>
        </li>
        <li>
            <span><a href="#import-directive"><code><w->from</w-></code></a></span>
            <span>Introduces an <a href="#import-directive">import directive</a>.</span>
        </li>
        <li>
            <span><a href="#import-directive"><code><w->import</w-></code></a></span>
            <span>Imports symbols from a <a href="#modules">module</a> while preserving the container <a href="#namespaces">namespace</a>.</span>
        </li>
        <li>
            <span><a href="#import-directive"><code><w->include</w-></code></a></span>
            <span>Imports symbols from a <a href="#modules">module</a> without preserving the container <a href="#namespaces">namespace</a>.</span>
        </li>
        <li>
            <span><a href="#export-directive"><code><w->export</w-></code></a></span>
            <span>Defines which symbols can be exported from the current <a href="#modules">module</a>.</span>
        </li>
        <li>
            <span><a href="#boolean-type"><code><k->true</k-></code></a></span>
            <span>Identifies the <a href="boolean-type">boolean</a> value true.</span>
        </li>
        <li>
            <span><a href="#boolean-type"><code><k->false</k-></code></a></span>
            <span>Identifies the <a href="boolean-type">boolean</a> value false.</span>
        </li>
        <li>
            <span><a href="#pointer-types"><code>@</code></a></span>
            <span>Identifies the <a href="pointer-types">pointer version</a> of a type. Also used to dereference <a href="#pointer-types">pointer</a> values.</span>
        </li>
        <li>
            <span><a href="#pointer-types"><code>$</code></a></span>
            <span>Retrieves the address of an <a href="#left-and-right-values">l-value</a> as a <a href="#pointer-types">pointer</a> <a href="#left-and-right-values">r-value</a>. Also used to access <a href="#temporary-variables">temporary variables</a>.</span>
        </li>
    </ul><br>
    <li>Flow control keywords</li>
    <ul class="summary-list">
        <li>
            <span><a href="#if-statement"><code><w->if</w-></code></a></span>
            <span>Used in the if selection statement.</span>
        </li>
        <li>
            <span><a href="#match-statement"><code><w->match</w-></code></a></span>
            <span>Used in the match selection statement.</span>
        </li>
        <li>
            <span><a href="#for-loops"><code><w->for</w-></code></a></span>
            <span>Used in the for loops.</span>
        </li>
        <li>
            <span><a href="#while-loops"><code><w->while</w-></code></a></span>
            <span>Used in the while loops.</span>
        </li>
        <li>
            <span><a href="#while-loops"><code><w->do</w-></code></a></span>
            <span>Used with <a href="#while-loops"><code><w->while</w-></code></a> to check the <a href="#bool-type">condition</a> after having executed the <a href="#statements">statement</a> instead of the other way around.</span>
        </li>
        <li>
            <span><a href="#continue-and-break-statements"><code><w->continue</w-></code></a></span>
            <span>Used to skip iterations.</span>
        </li>
        <li>
            <span><a href="#continue-and-break-statements"><code><w->break</w-></code></a></span>
            <span>Used to skip all the remaining iteration of one or more loops.</span>
        </li>
        <li>
            <span><a href="#once-statement"><code><w->once</w-></code></a></span>
            <span>Used to execute a statement during the first iteration.</span>
        </li>
        <li>
            <span><a href="#then-statement"><code><w->then</w-></code></a></span>
            <span>Used to execute a statement based on the outcome of the preceding loop or if.</span>
        </li>
        <li>
            <span><a href="#else-statement"><code><w->else</w-></code></a></span>
            <span>Used to execute a statement based on the outcome of the preceding loop or if.</span>
        </li>
        <li>
            <span><a href="#return-statement"><code><w->return</w-></code></a></span>
            <span>Returns the execution to the <a href="#function-calls">caller function</a>.</span>
        </li>
        <li>
            <span><a href="#defer-statement"><code><w->defer</w-></code></a></span>
            <span>Delays a <a href="#routine-calls">routine call</a> until the first <a href="#return-statement"><code><w->return</w-></code></a> statement is encountered.</span>
        </li>
    </ul><br>
    <li>Containers</li>
    <ul class="summary-list">
        <li>
            <span><elm-><code>(</code><code>)</code></elm-></span>
            <span>Groups an <a href="#expressions">expression</a>, or encloses a list of <a href="#routine-parameters">routine parameters</a>. Also used for <a href="#declarations.operator-precedence">operator precedence</a> and <a href="#specialization-constraints">specialization constraints.</a></span>
        </li>
        <li>
            <span><a href="#scopes"><elm-><code>{</code><code>}</code></elm-></a></span>
            <span>Declares a new <a href="#scopes">scope</a>. Used to declare most <a href="#semantic-elements">semantic elements</a>.</span>
        </li>
        <li>
            <span><elm-><code>"</code><code>"</code></elm-></span>
            <span>Delimits a <a href="#literals">string literal</a>. Also used in <a href="#import-directive">import directives</a>.</span>
        </li>
    </ul><br>
    <li>Separators</li>
    <ul class="summary-list">
        <li>
            <span><a href="#statements"><code>,</code></a></span>
            <span>Separates 2 or more <a href="#expressions">expressions</a> or <a href="#match-statement">match cases</a>.</span>
        </li>
        <li>
            <span><a href="#statements"><code>;</code></a></span>
            <span>Defines the end of <a href="#expression-statements">expression statements</a> or certain declarations and directives.</span>
        </li>
        <li>
            <span><a href="#name-resolution"><code>.</code></a></span>
            <span>Concatenates 2 or more symbol names to form a <a href="#language-structure.paths">symbol path</a>.
        </li>
        <li>
            <span><a href="#reflection"><code>::</code></a></span>
            <span>Concatenates 2 or more symbol names to form a <a href="#reflection">Reflection path</a>.</span>
        </li>
    </ul>
</ul>
<p>
    <a href="#keywords">Keywords</a> cannot be <a href="#name-shadowing">shadowed</a> like <a href="#identifiers">identifiers</a>.<br>
    Attempting to do so generates a semantic error. //TODO LINK
</p>


<h1 id="meta-keywords"></h1>
<p>
    <b>Meta keywords</b> are <a href="#syntactic-elements">syntactic elements</a> that only have meaning when <b>combined</b> with other <a href="#keywords"><b>keywords</b></a> or <a href="#semantic-elements">semantic elements</a>.<br>
    When active, they always take precedence over <a href="#identifiers">identifiers</a>.
</p>
<ul>
    <li><a href="#templates">Templates</a></li>
    <ul class="summary-list">
        <li>
            <span><a href="#templates"><code><w->template</w-></code></a></span>
            <span>
                Used to declare a <a href="#templates">template</a><br>
                <span class="meta-keyword-constraint">[When used before the <a href="#templates"><elm-><code>&lt;</code><code>&gt;</code></elm-></a> meta keyword]</span>.
            </span>
        </li>
        <li>
            <span><elm-><code>&lt;</code><code>&gt;</code></elm-></span>
            <span>
                Part of the <a href="#templates">template</a> declaration, or part of the the <a href="#local-names">local name</a> of <a href="#templates">template</a> <a href="#symbols">symbols</a>. Also used in <a href="#import-directive">import directives</a><br>
                <span class="meta-keyword-constraint">[When used after the <a href="#templates"><code><w->template</w-></code></a> meta keyword, after the <a href="#name-resolution">path</a> to a <a href="#templates">template</a> <a href="#symbols">symbol</a> or around the module name in an <a href="#import-directive">import directive</a>]</span>.
            </span>
        </li>
        <li>
            <span><a href="#template-parameters"><code><w->type</w-></code></a></span>
            <span>
                Used to declare type <a href="#template-parameters">template parameters</a> or type <a href="#template-parameter-packs">template parameter packs</a><br>
                <span class="meta-keyword-constraint">[When used as type in the declaration of a <a href="#template-parameters">template parameter</a> or <a href="#template-parameter-packs">template parameter pack</a>]</span>.
            </span>
        </li>
        <li>
            <span><a href="#abbreviated-template-syntax"><code>!</code></a></span>
            <span>
                Identifies the parameters whose arguments are used to deduce a type template parameter or type template parameter pack<br>
                <span class="meta-keyword-constraint">[When used between the type and the identifier in the declaration of a routine parameter or function parameter pack]</span>.
            </span>
        </li>
        <li>
            <span><a href="#abbreviated-template-syntax"><code>?</code></a></span>
            <span>
                <a href="#abbreviated-template-syntax">Abbreviated template syntax</a><br>
                <span class="meta-keyword-constraint">[When used between the type and the identifier of a <a href="#symbols">symbol</a> declaration inside a struct or routine declaration]</span>.
            </span>
        </li>
    </ul><br>
    <li>Misc</li>
    <ul class="summary-list">
        <li>
            <span><a href="#templates"><code><w->when</w-></code></a></span>
            <span>
                Specifies a <a href="#specialization-constraints">specialization constraint</a><br>
                <span class="meta-keyword-constraint">[When used before the body of a routine or struct declaration</span>.
            </span>
        </li>
        <li>
            <span><a href="#declarations.operator-precedence"><code><w->priority</w-></code></a></span>
            <span>
                Defines the <a href="#declarations.operator-precedence">priority</a> of an <a href="#operators">operator</a><br>
                <span class="meta-keyword-constraint">[When used at the end of the signature of an <a href="#operators">operator</a> or <a href="#templates">operator template</a> declaration]</span>.
            </span>
        </li>
        <li>
            <span><code><w->as</w-></code></span>
            <span>
                Defines the name of the counter <a href="#variables">variable</a> of a <a href="#for-loops">for loop</a>, a new name for an <a href="#export-directive">exported</a> or <a href="#import-directive">imported</a> <a href="#symbols"> symbol</a>, or the new identifier used for a <a href="#symbol-aliases">symbol alias</a><br>
                <span class="meta-keyword-constraint">[When used in the signature of a <a href="#for-loops">for-each</a>, <a href="#for-loops">for-n</a> or <a href="#for-loops">for-range</a> loop, after the name of a <a href="#symbols">symbol</a> in an <a href="#import-directive">import</a> or <a href="#export-directive">export</a> directive or in a <a href="#symbol-aliases">symbol alias</a> declaration]</span>.
            </span>
        </li>
        <li>
            <span><code><w->to</w-></code></span>
            <span>
                Defines the end of a numerical range<br>
                <span class="meta-keyword-constraint">[When used in the value of a <a href="#for-loops">for-range</a> loop or a <a href="#match-statement">match case</a>]</span>.
            </span>
        </li>
        <li>
            <span><code>=</code></span>
            <span>
                Used to assign initializer values to <a href="#variables">variables</a> and default values to <a href="#routine-parameter">routine parameters</a><br> //TODO templates can prob have def values<br>
                <span class="meta-keyword-constraint">[When used after the name of a <a href="#variables">variable</a> or <a href="#routine-parameters">routine parameter</a> declaration]</span>.
            </span>
        </li>
        <li>
            <span><code>:</code></span>
            <span>
                Specifies the base type of an enum<br>
                <span class="meta-keyword-constraint">[When used after the identifier of an enum declaration]</span>.
            </span>
        </li>
        <li>
            <span><code>...</code></span>
            <span>
                Used to declare <a href="#template-parameter-packs">template parameter packs</a> and <a href="function parameter packs">function parameter packs</a><br>
                <span class="meta-keyword-constraint">[When used after the identifier in the declaration of a template parameter pack or function parameter pack, or, if inside a struct or routine declaration, between the type and the identifier in the declaration of a routine parameter or function parameter pack]</span>.
            </span>
        </li>
        <li>
            <span><code>&</code></span>
            <span>
                Used todeclare a reference parameter<br>
                <span class="meta-keyword-constraint">[When used between the type and the identifier of a reference parameter]</span>.
            </span>
        </li>
    </ul>
</ul>


<h1 id="literal-tokens"></h1>
<p>
    <b>Literals</b> are a <b>special type</b> of <a href="#syntactic-elements"><b>syntactic element</b></a>, as they can contain both alphanumeric characters and <code>.</code>.<br>
    Their usage and syntax are explained in <a href="#literals">Literals</a>.
</p>


<h1 id="identifiers"></h1>
<p>
    <b>Identifiers</b> are used to <b>name and reference <a href="#semantic-elements">symbols</a></b>.<br>
    An identifier can be
    alphanumeric (<code><sg->[</sg-><s->a</s-><sr->-</sr-><s->zA</s-><sr->-</sr-><s->Z_</s-><sg->][</sg-><s->a</s-><sr->-</sr-><s->zA</s-><sr->-</sr-><s->Z_0</s-><sr->-</sr-><s->9</s-><sg->]</sg-><sr->*</sr-></code>)
    or symbolic (<code><sg->[</sg-><s->!$%&*+</s-><sr->\</sr-><s->-/:&lt;=&gt;?@^`|~;</s-><sr->\</sr-><s->[</s-><sr->\</sr-><s->]</s-><sr->\</sr-><s->.</s-><sg->]</sg-><sr->+</sr-></code>).
</p>
<p>
    Identifiers can be shadowed. This is explained in <a href="#name-shadowing">Name shadowing</a>.
</p>


<h1 id="semantic-elements"></h1>
<p>
    <b>Semantic elements</b> are <b>sequences</b> of one or more <a href="#syntactic-elements"><b>syntactic elements</b></a> or other semantic elements that follow specific patterns.<br>
    They define the contents and interface of the <a href="#modules">module</a>.
</p>
<p>
    Semantic elements are divided in 6 categories:
</p>


<div class="table-container"><table>
    <tr>
        <th>Category</th>
        <th>Semantic element</th>
    </tr>
    <tr>
        <th class="nowrap medium"><a href="#language-structure.directives">Directive</a></th>
        <td><div class="split-td-outer">
            <div class="split-td">
                <even-elm-><a href="#import-directive">Import </a> directive</even-elm->
                <even-elm-><a href="#export-directive"><code><w->export</w-></code></a> directive</even-elm->
                <even-elm-><a href="#construct-directive"><code><w->construct</w-></code></a> directive</even-elm->
            </div>
        </div></td>
    </tr>
    <tr>
        <th class="nowrap medium"><a href="#language-structure.declarations">Declaration</a></th>
        <td><div class="split-td-outer">
            <div class="split-td">
                <even-elm-><a href="#enums"><code><w->enum</w-></code></a> declaration</even-elm->
                <even-elm-><a href="#enums"><code><w->enum</w-></code></a> element declaration</even-elm->
                <even-elm-><a href="#structs"><code><w->struct</w-></code></a> declaration</even-elm->
                <even-elm-><a href="#structs"><code><w->struct</w-></code></a> member declaration</even-elm->
            </div>
            <div class="split-td">
                <even-elm-><a href="#functions">Function</a> declaration</even-elm->
                <even-elm-><a href="#operators">Operator</a> declaration</even-elm->
                <even-elm-><a href="#routine-parameters">Routine parameter</a></even-elm->
            </div>
            <div class="split-td">
                <even-elm-><a href="#namespaces"><code><w->namespace</w-></code></a> declaration</even-elm->
                <even-elm-><a href="#templates"><code><w->template</w-></code></a> declaration</even-elm->
                <even-elm-><a href="#symbol-aliases"><code><w->alias</w-></code></a> declaration</even-elm->
                <even-elm-><a href="#variables">Variable</a> declaration</even-elm->
            </div>
        </div></td>
    </tr>
    <tr>
        <th class="nowrap medium"><a href="#language-structure.statements">Statement</a></th>
        <td><div class="split-td-outer">
            <div class="split-td">
                <even-elm-><a href="#if-statement"><code><w->if</w-></code></a> statement</even-elm->
                <even-elm-><a href="#match-statement"><code><w->match</w-></code></a> statement</even-elm->
            </div>
            <div class="split-td">
                <even-elm-><a href="#while-loops"><code><w->while</w-></code></a> loop</even-elm->
                <even-elm-><a href="#for-loops"><code><w->for</w-></code></a> loop</even-elm->
                <even-elm-><a href="#once-statement"><code><w->once</w-></code></a> statement</even-elm->
                <even-elm-><a href="#then-statement"><code><w->then</w-></code></a> statement</even-elm->
                <even-elm-><a href="#break-statement"><code><w->break</w-></code></a> statement</even-elm->
                <even-elm-><a href="#continue-statement"><code><w->continue</w-></code></a> statement</even-elm->
            </div>
            <div class="split-td">
                <even-elm-><a href="#return-statement"><code><w->return</w-></code></a> statement</even-elm->
                <even-elm-><a href="#defer-statement"><code><w->defer</w-></code></a> statement</even-elm->
            </div>
            <div class="split-td">
                <even-elm-><a href="#else-statement"><code><w->else</w-></code></a> statement</even-elm->
                <even-elm-><a href="#expressions">Expression statement</a></even-elm->
                <even-elm-><a href="#unnamed-scopes">Unnamed scope</a></even-elm->
                <even-elm-><a href="#empty-statement">Empty statement</a></even-elm->
                <even-elm-><a href="#inline-glsl">Inline GLSL</a></even-elm->
                <even-elm-><a href="#inline-cpp">Inline C++</a></even-elm->
            </div>
        </div></td>
    </tr>
    <tr>
        <th class="nowrap medium"><a href="#language-structure.expressions">Expression</a></th>
        <td><div class="split-td-outer">
            <div class="split-td">
                <even-elm-><a href="#literals">Literal</a></even-elm->
                <even-elm-><a href="#try-expression"><code><w->try</w-></code> expression</a></even-elm->
            </div>
            <div class="split-td">
                <even-elm-><a href="#variables">Variable</a></even-elm->
                <even-elm-><a href="#temporary-variables">Temporary variable</a></even-elm->
                <even-elm-><a href="#routine-parameters">Routine parameter</a></even-elm->
            </div>
            <div class="split-td">
                <even-elm-><a href="#function-calls">Function call</a></even-elm->
                <even-elm-><a href="#operator-calls">Operator call</a></even-elm->
            </div>
        </div></td>
    </tr>
    <tr>
        <th class="nowrap medium"><a href="#language-structure.paths">Paths</a></th>
        <td><div class="split-td-outer">
            <div>
                <even-elm-><a href="#symbol-paths">Symbol path</a></even-elm->
                <even-elm-><a href="#symbol-reflection-paths">Symbol reflection path</a></even-elm->
            </div>
        </div></td>
    </tr>
</table></div>



<p>
    <a href="#structs">structs</a>, <a href="#routines">routines</a>, <a href="#templates">templates</a> and the <a href="#while-loops"><code><w->while</w-></code> loop</a>
    are divided in sub-elements in order to provide a clear and concise syntax.<br>
</p>
<ul>
    <li>Declaration sub-elements</li>
    <ul class="summary-list">
        <li>
            <span><a href="#structs">Struct</a> signature</span>
            <span>Defines the name of a <a href="#structs">struct</a>.</span>
        </li>
        <li>
            <span><a href="#structs">Struct</a> body</span>
            <span>Contains the <a href="#structs">struct</a> members and other allowed declarations.</span>
        </li>
        <li>
            <span><a href="#functions">Function</a> signature</span>
            <span>Defines the name, <a href="#return-statement">return type</a> and <a href="#routine-parameters">parameters</a> of a <a href="#functions">function</a></span>
        </li>
        <li>
            <span><a href="#operators">Operator</a> signature</span>
            <span>Defines the names, <a href="#return-statement">return type</a>, <a href="#routine-parameters">parameters</a>, <a href="#declarations.operator-precedence">priority</a> and <a href="#declarations.operator-precedence">associativity</a> of an <a href="#operators">operator</a></span>
        </li>
        <li>
            <span><a href="#routines">Routine</a> body</span>
            <span>Contains the <a href="#statements">statements</a> and other allowed declarations of a <a href="#routines">routine</a></span>
        </li>
        <li>
            <span><a href="#templates">Template</a> signature</span>
            <span>Defines the name and parameters of a <a href="#templates">template</a></span>
        </li>
        <li>
            <span><a href="#specialization-constraints">Specialization constraint</a></span>
            <span>Defines the <a href="#specialization-constraints">constraint</a> that determines when the subsequent element body is suitable for specialization</span>
        </li>
    </ul><br>
    <li>Other sub-elements</li>
    <ul class="summary-list">
        <li>
            <span><a href="#while-loops">While</a> signature</span>
            <span>Defines the <a href="boolean-type">condition</a> of a <a href="while-loops">while loop</a></span>
        </li>
        <li>
            <span>Specialization constraint</span>
            <span>Specifies a constraint whose result determines when a struct or routine declaration can be used.</span>
        </li>
    </ul>
</ul>


<h1 id="language-structure.directives"></h1>
<p>
    <b>Directives</b> are instructions that <b>modify</b> the <a href="#modules">module</a> on a <b>semantic</b> level.<br>
    They are used to define which <a href="#name-resolution">symbols</a> are <a href="#import-directive">imported</a> and/or <a href="#export-directive">exported</a> and to programmatically generate code.
</p>
<ul>
    <li>Module interface</li>
    <ul class="summary-list">
        <li>
            <span><elm-><a href="#import-directive">Improt</a> directive</elm-></span>
            <span><a href="#import-directive">Imports</a> <a href="#symbols">symbols</a> from a <a href="#modules">module</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#export-directive"><code><w->export</w-></code></a> directive</elm-></span>
            <span>Defines the <a href="#symbols">symbols</a> the <a href="#modules">module</a> provides when <a href="#import-directive">imported</a>.</span>
        </li>
    </ul>
    <li>Code generation</li>
    <ul class="summary-list">
        <li>
            <span><elm-><a href="#construct-directive"><code><w->construct</w-></code></a> directive</elm-></span>
            <span>Generates code in the corresponding language by compiling and running Umbra code before the compilation phase. //TODO other languages</span>
        </li>
    </ul>
</ul>


<h1 id="language-structure.declarations"></h1>
<p>
    <b>Declarations</b> define user-defined elements, such as <a href="#structs">structs</a>, <a href="#enums">enums</a>, <a href="#routines">routines</a>, <a href="#namespaces">namespaces</a>, <a href="#templates">templates</a>, <a href="#symbol-aliases">symbol aliases and <a href="#variables">variables</a>.</a><br>
    Anything defined through a declaration is called a <b>Symbol</b>. Symbols can be referenced through their <a href="#name-resolution">path</a>. This is explained in <a href="#name-resolution">Name resolution</a>.<br>
    There are a total of 11 user-defined elements. They are available in both languages.
</p>
<ul>
    <li>Types</li>
    <ul class="summary-list">
        <li>
            <span><elm-><a href="#enums"><code><w->enum</w-></code></a> declaration</elm-></span>
            <span>Declares an <a href="#enums">enum</a>, a type used to group <a href="#compile-time-expressions">compile time expressions</a> of the same <a href="#types">type</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#enums"><code><w->enum</w-></code></a> element declaration</elm-></span>
            <span>Defines one or more <a href="#enums">enum</a> elements and their values.</span>
        </li>
        <li>
            <span><elm-><a href="#structs"><code><w->struct</w-></code></a> declaration</elm-></span>
            <span>Declares a <a href="#structs">struct</a>, a type used to group <a href="#variables">variables</a> of different <a href="#types">types</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#structs"><code><w->struct</w-></code></a> member declaration</elm-></span>
            <span>Defines one ore more <a href="#structs">struct</a> members.</span>
        </li>
    </ul><br>
    <li>Routines</li>
    <ul class="summary-list">
        <li>
            <span><elm-><a href="#functions">Function</a> declaration</elm-></span>
            <span>Declares a <a href="#functions">function</a>, a prefix <a href="#routines">routine</a> that requires parentheses to be <a href="#function-calls">called</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#operators">Operator</a> declaration</elm-></span>
            <span>Declares an <a href="#operators">operator</a>, a <a href="#routines">routine</a> that doesn't require parentheses to be <a href="#operator-calls">called</a> and can use multiple symbolic or alphanumeric <a href="#identifiers">identifiers</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#routine-parameters">Routine parameter</a></elm-></span>
            <span>Defines an input values for a <a href="routines">routine</a>.</span>
        </li>
    </ul><br>
    <li>Misc</li>
    <ul class="summary-list">
        <li>
            <span><elm-><a href="#namespaces"><code><w->namespace</w-></code></a> declaration</elm-></span>
            <span>Declares a named <a href="#scopes">scope</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#templates"><code><w->template</w-></code></a> declaration</elm-></span>
            <span>Generates <a href="#structs">struct</a>, <a href="#functions">function</a> or <a href="#operators">operator</a> declarations based on the explicit <a href="#templates">template</a> arguments or the <a href="#types">types</a> used in the <a href="#routine-calls">routine calls</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#symbol-aliases"><code><w->alias</w-></code></a> declaration</elm-></span>
            <span>Declares an alternative <a href="#symbol-paths">path</a> for a <a href="#symbols">symbol</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#variables">Variable</a> declaration</elm-></span>
            <span>Declares one or more named memory locations that can store <a href="#values">values</a>.</span>
        </li>
    </ul>
</ul>


<h1 id="language-structure.statements"></h1>
<p>
    <b>Statements</b> perform actions during runtime. They define the behaviour of each <a href="#routines">routine</a>, their return value and runtime performance.<br>
    Statements are hard coded into the languages and cannot be modified. There are a total of 16 statements, 2 of which can only be used in their respective language.
</p>
<ul>
    <li>Selection</li>
    <ul class="summary-list">
        <li>
            <span><elm-><a href="#if-statement"><code><w->if</w-></code></a> statement</elm-></span>
            <span>Executes a <a href="#statements">statement</a> if its condition evaluates to <a href="#boolean-type"><code><k->true</k-></code></a>.</span>
        </li>
        <li>
            <span><elm-><a href="#match-statement"><code><w->match</w-></code></a> statement</elm-></span>
            <span>Executes <a href="#statements">statements</a> based on the value of an <a href="#expressions">expression</a>.</span>
        </li>
    </ul><br>
    <li>Iteration</li>
    <ul class="summary-list">
        <li>
            <span><elm-><a href="#for-loops"><code><w->for</w-></code></a> loop</elm-></span>
            <span>Executes a <a href="#statements">statement</a> a fixed amount of times.</span>
        </li>
        <li>
            <span><elm-><a href="#while-loops"><code><w->while</w-></code></a> loop</elm-></span>
            <span>Executes a <a href="#statements">statement</a> until its condition evaluates to <a href="#boolean-type"><code><k->false</k-></code></a>.</span>
        </li>
        <li>
            <span><elm-><a href="#continue-statement"><code><w->continue</w-></code></a> statement</elm-></span>
            <span>Skips an arbitrary number of iterations of the innermost enclosing <a href="#iteration">loop</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#break-statement"><code><w->break</w-></code></a> statement</elm-></span>
            <span>Skips all the remaining iterations of an arbitrary number of enclosing <a href="#iteration">loops</a>, starting from the innermost.</span>
        </li>
        <li>
            <span><elm-><a href="#once-statement"><code><w->once</w-></code></a> statement</elm-></span>
            <span>Executes a <a href="#statements">statement</a> during the first iteration of the innermost enclosing <a href="#iteration">loop</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#then-statement"><code><w->then</w-></code></a> statement</elm-></span>
            <span>Executes a <a href="#statements">statement</a> if the immediatly preceding <a href="#iteration">loop</a> didn't stop through a <a href="#break-statement"><code><w->break</w-></code> statement</a> and completed at least one iteration.</span>
        </li>
    </ul><br>
    <li>Non-local</li>
    <ul class="summary-list">
        <li>
            <span><elm-><a href="#return-statement"><code><w->return</w-></code></a> statement</elm-></span>
            <span>Returns the flow control to the caller <a href="#routines">routine</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#defer-statement"><code><w->defer</w-></code></a> statement</elm-></span>
            <span>Evaluates all the <a href="#routine-calls">arguments</a> of a <a href="#routine-calls">routine call</a> but delays its execution until the first <a href="#return-statement"><code><w->return</w-></code> statement</a> is encountered and all the <a href="#routine-calls">routine calls</a> of subsequent <a href="defer-statement"><code><w->defer</w-></code> statements</a> are executed.</span>
        </li>
    </ul><br>
    <li>Misc</li>
    <ul class="summary-list">
        <li>
            <span><elm-><a href="#else-statement"><code><w->else</w-></code></a> statement</elm-></span>
            <span>Executes a <a href="#statements">statement</a> if the <a href="#bool-type">condition</a> of the immediatly preceding <a href="#iteration">loop</a> or <a href="#if-statement"><code><w->if</w-></code> statement</a> evaluated to <code><t->false</t-></code> before the first iteration.</span>
        </li>
        <li>
            <span><elm-><a href="#expressions">Expression statement</a></elm-></span>
            <span>Evaluates an <a href="#expresisons">expression</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#unnamed-scopes">Unnamed scope</a></elm-></span>
            <span>Groups multiple <a href="#statements">statements</a> in one.</span>
        </li>
        <li>
            <span><elm-><a href="#empty-statement">Empty statement</a></elm-></span>
            <span>Does nothing.</span>
        </li>
        <li>
            <span><elm-><a href="#inline-glsl">Inline GLSL</a></elm-></span>
            <span><lux-logo-></lux-logo-> Allows GLSL 4.60 code to be used from within Lux.</span>
        </li>
        <li>
            <span><elm-><a href="#inline-cpp">Inline C++</a></elm-></span>
            <span><umbra-logo-></umbra-logo-> Allows C++20 code to be used from within Umbra.</span>
        </li>
    </ul>
</ul>


<h1 id="language-structure.expressions"></h1>
<p>
    <b>Expressions</b> generate values. They are mostly used to declare <a href="#name-resolution">symbols</a> and call <a href="#routines">routines</a>.
</p>
<ul>
    <li>Inline values</li>
    <ul class="summary-list">
        <li>
            <span><elm-><a href="#literals">Literal</a></elm-></span>
            <span>Generates a value of a <a href="#primitive-types">primitive type</a> by interpreting the token in the specified numerical base.</span>
        </li>
        <li>
            <span><elm-><a href="#try-expression"><code><w->try</w-></code> expression</a></elm-></span>
            <span>Compiles a portion of code. Evaluates to <a href="#boolean-type"><code><k->true</k-></code></a> if the code doesn't generate <a href="#compilation">syntactic</a> or <a href="#compilation">semantic errors</a>.</span>
        </li>
    </ul><br>
    <li>Stored values</li>
    <ul class="summary-list">
        <li>
            <span><elm-><a href="#variables">Variable</a></elm-></span>
            <span>Accesses the value stored in a previously declared <a href="#variables">variable</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#temporary-variables">Temporary variable</a></elm-></span>
            <span>Accesses the value stored in a <a href="#temporary-variables">temporary variable</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#routine-parameters">Routine parameter</a></elm-></span>
            <span>Accesses the value that was passed to a <a href="#variables">routine parameter</a>.</span>
        </li>
    </ul><br>
    <li>Routine calls</li>
    <ul class="summary-list">
        <li>
            <span><elm-><a href="#function-calls">Function call</a></elm-></span>
            <span>Generates a value by calling a <a href="#functions">function</a> or <a href="#templates">function template</a>.</span>
        </li>
        <li>
            <span><elm-><a href="#operator-calls">Operator call</a></elm-></span>
            <span>Generates a value by calling an <a href="#operators">operator</a> or <a href="#templates">operator template</a>.</span>
        </li>
    </ul>
</ul>



<h1 id="language-structure.paths"></h1>
<p>
    Paths are used to reference things declared in in the code, either explicitly or implicitly, in order to retrieve or pass informations about them.<br>
    Any accessible module, namespace, symbol alias, primitive type, enum, struct, special type, routine, variable and temporary variable is considered a symbol.<br>
    Paths are a foundamental part of most <a href="#semantic-elements">semantic elements</a>.
</p>
<p>
    Type paths are a subset of Symbol paths that point to symbols suitable to be used as types, such as primitive types, enums, structs and special types.
</p>
<p>
    Reflection paths are a subset of Symbol paths that can access compile time informations about the referenced symbol. These are detailedly explained in <a href="#reflection">Reflection</a>.
</p>
<syntax->
    <label- id="copy.syntax--path-standard">Standard path</label->
    <label- id="copy.syntax--path-type">Type path</label->
    <label- id="copy.syntax--path-reflection">Reflection path</label->
    <label- id="copy.syntax--path-name">Symbol name</label->
</syntax->


<h1 id="concepts"></h1>


<h1 id="scopes"></h1>
<p>
    <b>Scopes</b> define the <a href="#name-resolution"><b>path</b></a> to the <b>symbols</b> declared within them.<br>
    Any portion of code enclosed in <elm-><code>{</code><code>}</code></elm-> tokens defines a new scope.
    The only exception is the module scope, which contains anything declared in the module.
</p>
<p>
    Each scope can only contain certain types of <a href="#semantic-elements">symbols</a>:
</p>

<div class="scope-table-container">
    <div class="table-container scope-table-left-container"><table class="scope-table-left">
        <tr><th class="medium"><div><span>Scope / Can contain</span></div></th></tr>
        <tr><th class="medium"><div><a href="#modules">       Module                                     </a></div></th></tr>
        <tr><th class="medium"><div><a href="#namespaces">    Namespace                                  </a></div></th></tr>
        <tr><th class="medium"><div><a href="#enums">         Enum<span class="hidden">&nbsp;*</span>    </a></div></th></tr>
        <tr><th class="medium"><div><a href="#structs">       Struct<span class="hidden">&nbsp;*</span>  </a></div></th></tr>
        <tr><th class="medium"><div><a href="#functions">     Function<span class="hidden">&nbsp;*</span></a></div></th></tr>
        <tr><th class="medium"><div><a href="#opertors">      Operator<span class="hidden">&nbsp;*</span></a></div></th></tr>
        <tr><th class="medium"><div><a href="#unnamed-scopes">Unnamed<br>scope    </a></div></th></tr>
    </table></div>
    <div class="table-container scope-table-right-container"><table class="scope-table-right">
        <tr>
            <th><div><a class="medium" href="#namespaces">    Namespace                                  </a></div></th>
            <th><div><a class="medium" href="#enums">         Enum<span class="hidden">&nbsp;*</span>    </a></div></th>
            <th><div><a class="medium" href="#structs">       Struct<span class="hidden">&nbsp;*</span>  </a></div></th>
            <th><div><a class="medium" href="#functions">     Function<span class="hidden">&nbsp;*</span></a></div></th>
            <th><div><a class="medium" href="#operators">     Operator<span class="hidden">&nbsp;*</span></a></div></th>
            <th><div><a class="medium" href="#variables">     Variable                                   </a></div></th>
            <th><div><a class="medium" href="#symbol-aliases">Symbol<br>alias                            </a></div></th>
            <th><div><a class="medium" href="#enums">         Enum<br>member                             </a></div></th>
            <th><div><a class="medium" href="#structs">       Struct<br>member                           </a></div></th>
            <th><div><a class="medium" href="#routines">      Routine<br>parameter                       </a></div></th>
        </tr>
        <tr>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
        </tr>
        <tr>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div class="nobefore"><span>Inherited</span></div></td>
            <td class="scope-table-y"><div class="nobefore"><span>Inherited</span></div></td>
            <td class="scope-table-y"><div class="nobefore"><span>Inherited</span></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
        </tr>
        <tr>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
        </tr>
        <tr>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
        </tr>
        <tr>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-y"><div class="nobefore noafter"><div>Yes<span class="hidden" style="min-width: fit-content; max-width: fit-content;">&nbsp;**</span></div></div></td>
        </tr>
        <tr>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-y"><div class="nobefore noafter"><div>Yes<span class="hidden" style="min-width: fit-content; max-width: fit-content;">&nbsp;**</span></div></div></td>
        </tr>
        <tr>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-y"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
            <td class="scope-table-n"><div></div></td>
        </tr>
    </table></div>
</div>
<div>
    <syntax-note->
        * Also applies to the respective <a href="templates">template</a>.<br>
        ** Declared in the routine signature, but part of the routine scope.
    </syntax-note->
</div>


<h1 id="name-resolution"></h1>
<p>
    <b><a href="#semantic-elements.declarations">User defined elements</a></b>, or <a href="#declarations">Symbols</a>, can be referenced to use them as <a href="#types">types</a>, access their value or perform <a href="#routine-calls">routine calls</a>.
    This is done through their <b>name</b> or <b>path</b>.
</p>
<p>
    The name is the <a href="#identifiers">identifier</a> that was used to declare the <a href="#declarations">symbol</a>, optionally followed, if the symbol is a <a href="#templates">template</a>,
    by <elm-><code>&lt;</code><code>&gt;</code></elm-> tokens containing the <a href="#types">types</a> that identify the generated <a href="#declarations">symbol</a>.<br>
    Names are used to reference <a href="#declarations">symbols</a> that are declared in the current <a href="#scopes">scope</a> or in one of the enclosing ones.
</p>
<p>
    Paths, instead, are used to reference <a href="#declarations">symbols</a> declared in <a href="#scopes">scopes</a> that are not parents of the current <a href="#scopes">scope</a>.<br>
    They consist of the names of the enclosing <a href="#scopes">scopes</a> of the <a href="#declarations">symbol</a> and the name of the <a href="#declarations">symbol</a> itself separated by <code>.</code> tokens, starting from the outermost.<br>
    The <code>.</code> token is used to access the children <a href="#declarations">symbols</a> of the <a href="#scopes">scope</a>.<br>
    Paths work in the same way as file paths, with <a href="#scopes">scopes</a> acting like directories.
</p>
<p>
    The path of a symbol can start from any of its enclosing <a href="#scopes">scopes</a>.<br>
    <a href="#declarations">Symbols</a> declared within unnamed <a href="#scopes">scopes</a> cannot be referenced from the outside.<br>
    The <code>module</code> identifier is used to reference the <a href="#scopes">scope</a> of the current <a href="#modules">module</a>.<br>
    A path that starts from the module <a href="#scopes">scope</a> of the current <a href="#modules">module</a> or any of the <a href="#import-directive">imported</a> ones is called an absolute path.
</p>
<example- class="full-example">
    <label->Example</label->
    <div>
        <c->// Absolute path: module</c->


        <c->// Absolute path: module.s</c->
        <w->namespace</w-> s {
            <c->// Absolute path: module.s.fun</c->
            <t->void</t-> <f->fun</f->(<t->uint</t-> <p->n</p->) {
                <c->//        ^</c->
                <c->// Absolute path: module.s.fun.n</c->
            }
        }

        <w->namespace</w-> {
            <c->// No absolute path, cannot be referenced from outside</c->
            <t->uint</t-> n;
        }
    </div>
</example->
<example- class="full-example">
    <label->Example</label->
    <div>
        <c->// Absolute path: module</c->


        <c->// Absolute path: module.s</c->
        <w->namespace</w-> s {
            <c->// Absolute path: module.s.fun</c->
            <t->void</t-> <f->fun</f->(<t->uint</t-> <p->n</p->) {
                <c->//        ^</c->
                <c->// Absolute path: module.s.fun.n</c->
            }
        }

        <w->namespace</w-> {
            <c->// No absolute path, cannot be referenced from outside</c->
            <t->uint</t-> n;
        }
    </div>
</example->


<h1 id="name-shadowing"></h1>
<p>
    <a href="#declarations"><b>Symbols</b></a> in <b>different <a href="#scopes">scopes</a></b> can be declared using the <b>same <a href="#identifiers">identifier</a></b>. This is known as <b>name shadowing</b>.<br>
</p>
<p>
    When the <a href="#identifiers">identifier</a> is used, the <a href="#declarations">symbol</a> declared in the innermost <a href="#scopes">scope</a>, relatively to where the <a href="#identifiers">identifier</a> is used, always takes precedence.
    This can be avoided by starting the <a href="#name-resolution">path</a> from a parent <a href="#scopes">scope</a> so that the <a href="#identifiers">identifier</a> is not ambiguous.<br>
    Any <a href="#identifiers">identifier</a> can be shadowed, including <a href="#primitive-types">primitive types</a>, the <a href="#name-resolution"><code>module</code></a> <a href="#identifiers">identifier</a> and <a href="#declarations">symbols</a> from the <a href="#core-module">core module</a>.
</p>
<example- class="full-example">
    <label->Example</label->
    <div>
        <w->namespace</w-> s {
            <w->namespace</w-> {
                <t->float</t-> n;
                <c->// n references module.s.*unnamed*.n</c->
            }

            <t->void</t-> <f->n</f->(<t->uint</t-> <p->n</p->) {
                <c->// n references module.s.n.n</c->
            }

            <c->// n references module.s.n</c->
        }
    </div>
</example->

<p>
    The first declaration in a scope is the only one that actually shadows eventual identifiers in parent scopes. Subsequent declarations that use the same identifier will refer to the symbol declared in the same scope.<br>
</p>
<example- class="full-example">
    <label->Example</label->
    <div>
        <c->// Ok, declares a struct with name "t"</c->
        <w->strct</w-> t {
            <t->int</t-> n;
        }

        <t->void</t-> <f->main</f->(){
            <t->t</t-> t;            <c->// Ok, declares a variable with name "t" and type "module.t"</c->
            <c->//t a;</c->          <ce->// Error, "t" is a variable and not a type</ce->
            <c->//module.t t;</c->   <ce->// Error, redeclaration of "module.main.t"</ce->
            module.<t->t</t-> a;     <c->// Ok, declares a variable with name "a" and type "module.t"</c->
        }

    </div>
</example->


<h1 id="multiple-declarations"></h1>
<p> //TODO linkkk
    Some types of symbol can be declared multiple times in the same scope.<br>
</p>
<p>
    <code><w->namespace</w-></code>.<br>
    All the declared namespaces with the same absolute path merge their contents.<br>
    <br>
    Routines.<br>
    Functions and routines declared in the same scope using the same identifier create a specialized routine.<br>
    This is explained in <a href="#routine-specialization">Routine specialization</a>.<br>
    The <code><f->main</f-></code> function cannot be specialized.<br>
    Structs.<br>
    Structs declared in the same scope using the same identifier create a specialized struct.<br>
    This is explained in <a href="#struct-specialization">Struct specialization</a>.<br>
    <br>
    Other symbols.<br>
    Multiple declarations of other symbols generate a semantic error. //TODO LINK
</p>
<example- class="full-example">
    <label->Example</label->
    <div>
        <w->namespace</w-> a {     <c->// Ok, merges with the second declaration</c->
            <t->int</t-> n;        <c->// Ok</c->
            <t->int</t-> a;        <c->// Ok, shadows "module.a"</c->
        }
        <w->namespace</w-> a {     <c->// Ok, merges with the first declaration</c->
            <c->//int n;</c->      <ce->// Error, redeclaration of "module.a.n"</ce->
            <t->int</t-> b;        <c->// Ok</c->
        }
        <t->void</t-> <f->main</f->(){
            a.b <f->=</f-> <k->5</k->;      <c->// Ok</c->
        }

        <t->void</t-> <f->f</f->(<t->int</t-> <p->n</p->) { } <c->// Ok</c->
        <t->void</t-> <f->f</f->() { }      <c->// Ok, specialization of "module.f"</c->
    </div>
</example->


<h1 id="left-and-right-values"></h1>
<p>
    Values can be left values or right values.<br>
    <b>Memory locations</b> which allow <b>changes</b> to their contents after being declared are considered <b>left values</b>.<br>
    Any other value is a <b>right value</b>.
</p>
<div class="table-container"><table>
    <tr>
        <th>Left values</th>
        <th>Right values</th>
    </tr>
    <tr>
        <td>Non-const <a href="#functions">parameters</a></td>
        <td><a href="#const-qualifier">Const</a> parameters</td>
    </tr>
    <tr>
        <td>Result of <a href="#element-indexing">element indexing operations</a> (<code>[</code><code>]</code> and <code>.</code>)</td>
        <td>Result of <a href="#function-calls">function calls</a> and <a href="#operator-calls">operator calls</a></td>
    </tr>
    <tr>
        <td>Non-const <a href="#variables">varibales</a></td>
        <td><a href="#const-qualifier">Const</a> variables</td>
    </tr>
    <tr>
        <td><a href="#temporary-variables">Temporary variables</a></td>
        <td><a href="#enums">Enum</a> elements</td>
    </tr>
    <tr>
        <td></td>
        <td><a href="#literals">Literals</a></td>
    </tr>
</table></div>
<p>
    Left values can be used anywhere right values can.<br>
    Left and right values are also called l-values and r-values.
</p>


<h1 id="undefined-values"></h1>
<p>
    <b>Any unknown value</b> of any <a href="#types">type</a> is an <b>undefined value</b>.<br>
    The language can generate undefined values for a variety of reasons.<br>
    Such values are usually the result of errors that occurred during the execution of a <a href="#functions">function</a> and don't contain any useful information.<br>
    Uninitialized <a href="#variables">variables</a> also have undefined value.
</p>
<p>
    Generating undefined values during runtime doesn't stop the execution and is not signaled in any way, nor is it detectable.<br>
    The <a href="#modules">module</a> is responsible for preventing, discarding or documenting undefined values.
</p>


<h1 id="undefined-behaviour"></h1>
<p>
    Certain actions cause undefined behaviour.<br>
    <b>Undefined behaviour</b> means that the <b>code <a href="#compilation">compiles</a> with no errors</b>, but the <b>runtime behaviour is unknown</b> and anything could happen.<br>
    The software could break, have bugs or work just fine. One cannot know.
</p>
<p>
    As with <a href="#undefined-values">undefined values</a>, the <a href="#modules">module</a> is responsible for preventing or documenting undefined behaviours.
</p>


<h1 id="compile-time-expressions"></h1>
<p>
    <b>Compile time expressions</b> are <a href="#expressions">expressions</a> that can be <b>calculated during</b> the <a href="#compilation"><b>compilation</b></a> phase.<br>
    These <a href="#expressions">expressions</a> are required in certain syntaxes, such as <a href="#operators">operator</a> declarations, <a href="#enums">enum</a> elements, <a href="#template">template</a> <a href="#name-resolution">paths</a> and <a href="#specialization-constraints">specialization constraints</a>.<br>
</p>
<ul>
    <li>Whether an <a href="#expressions">expression</a> can be compile time or not is determined in the following way:</li>
    <ul>
        <li>
            A <a href="#routine">routine</a> is suitable for compile time <a href="#routine-calls">calls</a> if it is not declared with the <a href="#runtime-qualifier"><code><w->runtime</w-></code> qualifier</a>,
            it doesn't contain <a href="#inline-cpp">inline C++</a> or <a href="#inline-glsl">inline GLSL</a> statements and
            every <a href="#routine-calls">routine call</a> within its body, including constructors and destructor called implicitly or not, are compile time.
        </li>
        <li>
            A <a href="#routine-calls">routine call</a> is compile time if the <a href="#routines">routine</a> is suitable for compile time <a href="#routine-calls">calls</a> and
            all of its <a href="#routine-parameters">arguments</a> are compile time expressions.
        </li>
        <li>
            A <a href="#variables">variable</a> or <a href="#temporary-variables">temporary variable</a> is compile time if its initializer expression is compile time,
            all the <a href="#routine-calls">routine calls</a> in which it is used as <a href="#routine-calls">argument</a> to a <a href="#references">reference</a> <a href="#routine-parameters">parameter</a> refer to routines that are suitable for compile time calls and
            all the additional <a href="#routine-parameters">arguments</a> of such <a href="#routine-calls">calls</a> are compile time expressions.
        </li>
        <li>
            <a href="#literals">Literals</a>, <a href="#enums">enum</a> elements, <a href="#templates">template</a> parameters and <a href="#try-expression"><code><w->try</w-></code> expressions</a> are always compile time.
        </li>
    </ul>
</ul>
<p>
    For consistency reasons, cases in which a <a href="#routine">routine</a> is runtime but it doesn't actually need to run during runtime,
    either by containing empty <a href="#inline-cpp">inline C++</a> or <a href="#inline-glsl">inline GLSL</a> statements or
    by containing runtime <a href="#routine-calls">routine calls</a> that are empty or have the aforementioned properties,
    are not considered suitable for compile time <a href="#routine-calls">calls</a>, even though it would be possible to determine their <a href="#return-statement">return value</a> and operations on reference <a href="#routine-parameters">parameters</a> during the <a href="#compilation">compilation</a> process.
</p>
<example- class="full-example">
    <label->Example</label->
    <div>
        <w->from</w-> <s->&lt;random&gt;</s-> <w->include</w-> rand;

        <w->enum</w-> q : <t->bool</t-> {
            to_be     = <k->0</k->,
            not_to_be = <k->1</k->
        }

        <c->// Suitable for compile time calls</c->
        <t->bool</t-> <f->add_1</f->(<t->ulong</t-> <p->n</p->) {
            <w->return</w-> n <f->+</f-> <k->1</k->;
        }


        <t->bool</t-> <f->f</f->(<t->ulong</t-> <p->n</p->) {
            <t->ulong</t-> a = <k->True</k->;

            <c->// return q::elms[n];</c->          <ce->// Error, "n" is not a compile time expression</ce->
            <c->// return q[add_1(n)];</c->   <ce->// Error, the routine call is not compile time</ce->
            <c->// return q[rand(2)];</c->    <ce->// Error, the routine "random.rand" is not suitable for compile time calls</ce->
            <w->return</w-> q<f->[</f->n<f->]</f->;             <c->// Ok</c->
        }
    </div>
</example->
<p>
    Notice that compile time expressions are not required to run during compile time, and they don't affect <a href="#value-precomputation">optimizations</a> in any way.<br>
    Compile time expressions are exclusively used to determine which <a href="#expressions">expressions</a> can be used in contexts where a compile time value is required.
</p>
<p>
    Any routine declared in <a href="#standard-modules">standard modules</a> that could change the observable behaviour of the program if executed during compile time is properly marked as <a href="#runtime-qualifier"><code><w->runtime</w-></code></a>,
    therefore is not possible to accidentally modify the program behaviour by inadvertently executing <a href="#routines">routines</a> that are not supposed to be executed during the <a href="#compilation">compilation</a> process.
</p>
<p>
    //TODO template<t = ulong> t random(t from, t to)
    //TODO template<t = ulong> t random(t to) //from 0
</p>















<h1 id="language-|-details"></h1>


<h1 id="directives"></h1>


<h1 id="import-directive"></h1>
<p>
    The <b>Import directive</b> allows the <a href="#modules">module</a> to <b>access</b> and <b>rename <a href="#name-resolution">symbols</a></b> declared in <b>other modules</b>.<br>
    Only <a href="#name-resolution">symbols</a> exported using the <a href="#export-directive">Export directive</a> and their children can be imported.<br>
    The <code>*</code> character can be used to import all the <a href="#name-resolution">symbols</a> inside the <a href="#modules">module</a>. <code>*</code> doesn't allow renaming.<br>
</p>
<p>
    When an Import directive is used, it creates a new namespace inside the <a href="#root-scope">root scope</a> (.) containing the imported <a href="#name-resolution">symbols</a>, renamed as specified in the directive.<br>
    Anything these <a href="#name-resolution">symbols</a> depend on is automatically imported but not accessible unless intentionally stated.<br>
</p>
<syntax->
    <label- id="copy.syntax--misc-import-directive">Import syntax</label->
</syntax->
<p>
    When the <code><w->import</w-></code> <a href="#keywords">keyword</a> is used, the container <a href="#namespaces">namespace</a> is preserved.<br>
    The new <a href="#namespaces">namespace</a> is created using the export <a href="#identifiers">identifier</a> of the <a href="#modules">module</a> you are importing from, or, if not specified, the name of the file without its extensions.<br>
    The container <a href="#namespaces">namespace</a> can also be renamed.<br>
    <a href="#namespaces">Namespaces</a> created through the <code><w->import</w-></code> <a href="#keywords">keyword</a> always generate a <a href="#symbol-aliases">Symbol alias</a> for consistency reasons.<br>
    Using <a href="#symbol-aliases">Symbol aliases</a> allows import directives to follow the same <a href="#name-shadowing">Name shadowing</a> rules that apply to <a href="#declarations">Symbol declarations</a>.
</p>
<p>
    When the <code><w->include</w-></code> <a href="#keywords">keyword</a> is used, the container <a href="#namespaces">namespace</a> is not preserved and the <a href="#name-resolution">symbols</a> are placed directly inside the <a href="#modules">module</a> <a href="#namespaces">namespace</a>.<br>
    The <code><w->include</w-></code> <a href="#keywords">keyword</a> doesn't generate any <a href="#symbol-aliases">Symbol alias</a>.
</p>

<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example</label->
            <div>
                <c->// [module "main.ubr"]</c->

                <t->int</t-> io;
                <w->from</w-> <s->&lt;math&gt;</s-> <w->include</w-> <f->sum</f->;
                <w->from </w-><s->&lt;io&gt;</s-> <w->import</w-> <f->print</f-> <w->as</w-> <f->write</f->;

                <t->void</t-> <f->main</f->(){
                    io.<f->write</f->(<f->sum</f->((<k->8</k->, <k->9</k->, <k->10</k->)));
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Equivalent code</label->
            <div>
                <c->// From the root scope's perspective,</c->
                <c->// this is what the program looks like</c->

                <w->namespace</w-> root {
                    <w->namespace</w-> module { <c->// Merges with the current module</c->
                        <c->// sum function...</c->
                    }

                    <w->namespace</w-> io {
                        <c->// write function (print) ...</c->
                    }

                    <w->namespace</w-> module {
                        <w->int</w-> io;
                        <w->alias</w-> .io <w->as</w-> io;

                        <t->void</t-> <f->main</f->(){
                            io.<f->write</f->(<f->sum</f->((<k->8</k->, <k->9</k->, <k->10</k->)));
                        }
                    }
                }
            </div>
        </example->
    </split-example-container-right->
</split-example-container->


<h1 id="export-directive"></h1>
<p>
    The <b>Export directive</b> allows the module to <b>state and rename</b> the <b><a href="#name-resolution">symbols</a> other <a href="#modules">modules</a></b> are allowed to <b>use</b> when importing from the current <a href="#modules">module</a>.<br>
    Only <a href="#namespaces">namespaces</a>, <a href="#enums">enums</a>, <a href="#structs">structs</a>, <a href="#routines">routines</a>, <a href="#variables">variables</a> and <a href="#templates">templates</a>
    declared in the <a href="#modules">module</a> <a href="#scopes">scope</a> or whose parent <a href="#scopes">scopes</a> are only <a href="#namespaces">namespaces</a> can be exported.<br>
    Any additional <a href="#name-resolution">symbol</a> upon which an exported <a href="#name-resolution">symbol</a> depends is automatically exported but hidden from the other <a href="#modules">modules</a>.
</p>
<p>
    The <code>*</code> character can be used to export all the <a href="#name-resolution">symbols</a> inside the <a href="#modules">module</a>. <code>*</code> doesn't allow renaming.
</p>
<p>
    It is possible to define an export <a href="#identifiers">identifier</a> which will be used by the other <a href="#modules">modules</a> to name the <a href="#namespaces">namespace</a> containing the imported <a href="#name-resolution">symbols</a>.<br>
    If an export <a href="#identifiers">identifier</a> is not specified, the name of the file without its extensions is used.<br>
    If the file has a name that is not a valid <a href="#identifiers">identifier</a>, a custom export <a href="#identifiers">identifier</a> must be specified.
</p>
<syntax->
    <label- id="copy.syntax--misc-export-directive">Export syntax</label->
</syntax->

<example- class="full-example">
    <label->Example</label->
    <div>
        <t->float</t-> pi = <k->3.14</k->;   <c->// Automatically exported as it is required by the "getTau" function, but not accessible</c->

        <t->float</t-> <f->getTau</f->(){
            <w->return</w-> <k->pi</k-><f->*</f-><k->2</k->;
        }

        <w->export</w-> <w->as</w-> notPi;
        <w->export</w-> <f->getTau</f->;
    </div>
</example->

<p>
    While the Export directive doesn't preserve the parent <a href="#namespaces">namespaces</a> of a <a href="#name-resolution">symbol</a> nor can it add new ones, it can be used in conjunction with <a href="#symbol-aliases">Symbol aliases</a>
    and <a href="#namespaces">Namespaces</a> to create a clean interface while preserving the internal structure of the <a href="#modules">module</a>.
</p>
<example- class="full-example">
    <label->Example</label->
    <div>
        <w->from</w-> <s->&lt;math&gt;</s-> <w->import</w-> <f->pow</f->;

        <t->float</t-> pi = <k->3.14</k->

        <t->float</t-> <f->cube_v</f->(<t->float</t-> <p->side</p->) { <w->return</w-> math.<p->pow</p->(side, <k->3</k->) }
        <t->float</t-> <f->cube_s</f->(<t->float</t-> <p->side</p->) { <w->return</w-> math.<p->pow</p->(side, <k->2</k->) <f->*</f-> <k->6</k->; }

        <t->float</t-> <f->sphere_v</f->(<t->float</t-> <p->r</p->) { <w->return</w-> <k->pi</k-><f->/</f-><k->3</k-><f->*</f-><k->4</k-><f->*</f->math.<f->pow</f->(r, <k->3</k->); }
        <t->float</t-> <f->sphere_s</f->(<t->float</t-> <p->r</p->) { <w->return</w-> <k->pi</k-><f->*</f-><k->4</k-><f->*</f->math.<f->pow</f->(r, <k->2</k->); }


        <w->namespace</w-> volume {
            <w->alias</w-> <f->cube_v</f-> <w->as</w-> <f->cube</f->;
            <w->alias</w-> <f->sphere_v</f-> <w->as</w-> <f->sphere</f->;
        }
        <w->namespace</w-> surface {
            <w->alias</w-> <f->cube_s</f-> <w->as</w-> <f->cube</f->;
            <w->alias</w-> <f->sphere_s</f-> <w->as</w-> <f->sphere</f->;
        }
        <w->export</w-> volume, surface;
    </div>
</example->


<h1 id="construct-directive"></h1>
<p>

</p>
<syntax->
    <label- id="copy.syntax--misc-construct-directive">Construct syntax</label->
</syntax->


<h1 id="types"></h1>
<p>
    <b>Data types</b> define how <b><a href="#values">values</a></b> are <b>interpreted</b> during runtime and how they can be used within <a href="#expressions">expressions</a>.<br>
</p>
<p>
    Both languages are statically types.<br>
    Every <a href="#values">value</a> has an associated type, regardless of it being a <a href="#left-and-right-values">right</a> or a <a href="#left-and-right-values">left value</a>.<br>
    The type of each <a href="#values">value</a> must be known at compile time, as there are no runtime type informations.
</p>
<p>
    There are no classes, characters, matrices or vectors. The latter 2 are <a href="#symbol-aliases">aliases</a> of <a href="#arrays">array</a> types. See <a href="#standard-modules">Standard Modules</a>.
    //FIXME ^

    //TODO specify that types are a subset of symbol paths that contains any path to structs, enums, primitive types or special types, which are all considered symbols
</p>


<h1 id="primitive-types"></h1>
<p>Lux and Umbra feature <b>7 primitive types</b>, which can be used to define more complex types such as <a href="#structs">structs</a>, <a href="#arrays">arrays</a> and <a href="#tuples">tuples</a>.</p>
<p>
    These types are always defined and they act as if they were declared in the <a href="#core-module">core module</a>.<br>
    Primitive types are <b>not <a href="#keywords">keywords</a></b> and can be <a href="#name-shadowing">shadowed</a> like any other <a href="#semantic-elements">symbol</a>.
</p>
<p>The primitive types are:</p>
<div class="table-container"><table>
    <tr>
        <th>Type name   </th>
        <th>Size (bytes)</th>
        <th>Value type  </th>
    </tr>
    <tr>
        <td class="center"><code><t->uint</t-></code></td>
        <td class="center">4</td>
        <td rowspan="2">Unsigned integral number</td>
    </tr>
    <tr>
        <td class="center"><code><t->ulong</t-></code></td>
        <td class="center">8</td>
    </tr>
    <tr>
        <td class="center"><code><t->int</t-></code></td>
        <td class="center">4</td>
        <td rowspan="2">Signed integral number</td>
    </tr>
    <tr>
        <td class="center"><code><t->long</t-></code></td>
        <td class="center">8</td>
    </tr>
    <tr>
        <td class="center"><code><t->float</t-></code></td>
        <td class="center">4</td>
        <td rowspan="2">Floating point number</td>
    </tr>
    <tr>
        <td class="center"><code><t->double</t-></code></td>
        <td class="center">8</td>
    </tr>
    <tr>
        <td class="center"><code><t->bool</t-></code></td>
        <td class="center">4</td>
        <td>Boolean value</td>
    </tr>
</table></div>
<p>
    All primitives types are convertible to each other. This is explained in detail in <a href="#implicit-conversions">Implicit conversions</a>.<br>
</p>


<h1 id="integral-types"></h1>
<p>
    <code><t->int</t-></code>, <code><t->uint</t-></code>, <code><t->long</t-></code>, <code><t->ulong</t-></code>.<br>
    <b>Integral types</b> are used to <b>represent integers</b>.<br>
    Unsigned integers cannot represent negative numbers, but the maximum value is twice as high as their signed counterpart.
</p>
<p>
    All signed integral types use the Two's Complement to represent negative numbers.<br>
    Positive numbers and <code><k->0</k-></code> use the corresponding binary value in both signed and unsigned integral types.
</p>
<example- class="full-example">
        <div style="border-top-left-radius: var(--code-decoration-r);">
                                            <c->  1              31</c->
                                            <c->sign           value</c->
                                            <c-></c->  <t->int</t->
                                            <sr-></sr-><s-></s->
                                                              <c->32</c->
                                                            <c->value</c->
                                            <c-></c->  <t->uint</t->
                                            <s-></s->
            <c->  1                              63</c->
            <c->sign                           value</c->
            <c-></c->  <t->long</t->
            <sr-></sr-><s-></s->
                                              <c->64</c->
                                            <c->value</c->
            <c-></c->  <t->ulong</t->
            <s-></s->
        </div>
</example->
<p>
    //TODO GL_EXT_shader_explicit_arithmetic_types_int64
</p>


<h1 id="floating-point-types"></h1>
<p>
    <code><t->float</t-></code>, <code><t->double</t-></code>.<br>
    <b>Floating point types</b> are used to <b>approximately represent real numbers</b>.<br>
</p>
<p>
    Both floating point types are encoded according to the IEEE 754 Standard.<br>
    Positive and negative inf, nan and signed <code><k->0</k-></code> are all supported.<br>
    <code><k->+0</k-></code> and <code><k->-0</k-></code> are equal.
</p>
<example- class="full-example">
        <div style="border-top-left-radius: var(--code-decoration-r);">
                                            <c-> 1      8          23</c->
                                            <c->sign exponent   mantissa</c->
                                            <c-></c->  <t->float</t->
                                            <sr-></sr-><sg-></sg-><s-></s->
                                            <c->00000000000000000000000000000000</c->  <k->+0.0</k->
                                            <c->10000000000000000000000000000000</c->  <k->-0.0</k->
                                            <c->01111111100000000000000000000000</c->  <k->+inf</k->
                                            <c->11111111100000000000000000000000</c->  <k->-inf</k->
                                            <c->011111111&lt; not 0 &gt;</c->  <k->nan</k->
                                            <c->111111111&lt; not 0 &gt;</c->  <k->nan</k->

            <c-> 1      11                           52</c->
            <c->sign  exponent                    mantissa</c->
            <c-></c->  <t->double</t->
            <sr-></sr-><sg-></sg-><s-></s->
            <c->0000000000000000000000000000000000000000000000000000000000000000</c->  <k->+0.0</k->
            <c->1000000000000000000000000000000000000000000000000000000000000000</c->  <k->-0.0</k->
            <c->0111111110000000000000000000000000000000000000000000000000000000</c->  <k->+inf</k->
            <c->1111111110000000000000000000000000000000000000000000000000000000</c->  <k->-inf</k->
            <c->011111111&lt; not 0 &gt;</c->  <k->nan</k->
            <c->111111111&lt; not 0 &gt;</c->  <k->nan</k->
        </div>
</example->
<p>
    inf values are generated as required by the standard.<br>
    nan values are not generated for consistency and performance reasons.
</p>


<h1 id="boolean-type"></h1>
<p>
    <code><t->bool</t-></code>.<br>
    The <b>Boolean type</b> is used to <b>represent boolean values</b>.<br>
    <code><k->true</k-></code> and <code><k->false</k-></code> are the only values that can be stored in a <code><t->bool</t-></code>.
</p>
<example- class="full-example">
        <div style="border-top-left-radius: var(--code-decoration-r);">
                            <c->32</c->
                          <c->value</c->
            <c-></c->  <t->bool</t->
            <s-></s->
            <c->00000000000000000000000000000001</c->  <k->true</k->
            <c->00000000000000000000000000000000</c->  <k->false</k->
        </div>
</example->
<p>
    Booleans purposely waste 31 bits for performance reasons.<br>
    Smaller types require additional bitwise operations and expensive conversions between the CPU and GPU data.
</p>


<h1 id="enums"></h1>
<p>
    <b>Enums</b> are used to create <b>new types</b> whose allowed values are a <b>subset</b> of the possible values of their <b>base <a href="#types">type</a></b> and can only be used throught their names.<br>
    The base <a href="#types">type</a> of an enum is specified after its name and, differently from most languages, it can be any type, including <a href="#structs">structs</a> or other enums.<br>
    Enum elements are declared in the same way as <a href="#variables">variables</a>, but the type is not specified explicitly and their initializer values must be <a href="#compile-time-values">known at compile time</a>.<br>
    These elements identify the allowed values.
</p>
<p>
    Elements of <a href="#integral-types">integral</a> enums which are not initialized are given the value of the preceding element + <code><k->1</k-></code>, or <code><k->0</k-></code> if first.<br>
    Elements of enums with any other base <a href="#types">type</a> must always be initialized.<br>
    Multiple elements can have identical <a href="#values">values</a>, but each <a href="#identifiers">identifier</a> can only be declared once.<br>
    Empty enums are allowed.
</p>

<syntax->
    <label- id="copy.syntax--declaration-enum">Declaration syntax</label->
    <label- id="copy.syntax--declaration-enum-element">Element declaration syntax</label->
</syntax->

<p>
    Enum elements are <a href="#constant-values">constant values</a>.<br>
    <a href="#expressions">Expressions</a> of enum <a href="#types">type</a> are <a href="#implicit-conversions">implicitly convertible</a> to any type their base type is implicitly convertible to and the base type itself.<br>
    This is detailedly explained in <a href="#implicit-conversions">Implicit conversions</a>.
</p>


<example- class="full-example">
    <label->Example</label->
    <div>
        <w->enum</w-> <t->e</t-> : <t->int</t-> {
            a, b;              <c->// a = 0, b = 1</c->
            c = <k->-266250</k->;       <c->// c = -266250</c->
            d, e = <k->0</k->;          <c->// d = -266249, e = 0</c->
        }

        <t->float</t-> <f->main</f->(){
            <w->return</w-> e.<k->c</k->; <c->// Implicitly convert e to float</c->
        }
    </div>
</example->


<h1 id="struct-enums"></h1>
<p style="margin-bottom: 0;">
    Enums with a <b>struct</b> as <b>base type</b> behave <b>slightly differently</b> than standard enums:<br>
</p>
<ul><ul>
    <li>Elements are initialized through one of the constructors of the base type and destroyed before the process ends as if they were global variables.</li>
    <li>The size of the type is always 8 bytes, regardless of the size of the base struct.</li>
    <li>Struct methods declared in the base struct are not inherited.</li>
    <li>Creating or destroying enum values doesn't call constructors or destructors declared in the base struct.</li>
</ul></ul>
<example- class="full-example">
    <label->Example</label->
    <div>
        <w->struct</w-> <t->s</t-> {
            <t->uint</t-> n1, n2;
        }

        <w->enum</w-> <t->e</t-> : <t->s</t-> {
            a = (<k->10</k->, <k->90</k->),
            b = (<k->8</k->, <k->140</k->),
            c = (<k->50</k->, <k->60</k->)
        }
    </div>
</example->













//TODO improve wording



<h1 id="automatic-enum-scoping"></h1>
<p>
    <b>Automatic enum scoping</b> can be used to <b>skip</b> the idenfiers of <b>parent scopes</b> in a symbol path and reference an enum element through its name alone.<br>
    This is done by replacing the path to the element with a single <code>.</code> keyword.<br>
    Automatic scoping can only be used where the only accepted values are of a specific enum type.
</p>
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;

                <w->enum</w-> <t->day</t-> : <t->uint</t-> {
                    <k->mon</k->, <k->two</k->, <k->wed</k->, <k->thu</k->, <k->fri</k->, <k->sat</k->, <k->sun</k->;
                }

                <t->void</t-> <f->check_day</f->(<t->day</t-> <p->d</p->) {
                    <w->match</w-> d {
                        .<k->mon</k-> to .<k->fri</k-> { io.<f->print</f->(<s->"TwT"</s->); }
                        .<k->sat</k-> or .<k->sun</k-> { io.<f->print</f->(<s->"OwO"</s->); }
                    }
                }

                <t->void</t-> <f->main</f->(){
                    <f->check_day</f->(.<k->sun</k->);
                    io.print("\n");
                    <f->check_day</f->(.<k->mon</k->);
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Output</label->
            <div>
                OwO
                TwT<cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->


<h1 id="structs"></h1>
<p>
    <b>Structs</b> are used to <b>create</b> new <b>types</b> composed by 0 or more separate members that can have differing type.<br>
    The members are declared in the same way as <a href="#variables">variables</a> but cannot have initializer values.
</p>
<p>
    Empty structs are allowed.<br>
    Struct members can be of any <a href="#types">type</a>, including other structs.
</p>
<syntax->
    <label- id="copy.syntax--declaration-struct">Declaration syntax</label->
    <label- id="copy.syntax--declaration-struct-signature">Struct signature</label->
    <label- id="copy.syntax--declaration-struct-body">Struct body</label->
    <label- id="copy.syntax--declaration-specialization-constraint">Specialization constraint</label->
    <label- id="copy.syntax--declaration-struct-member">Member declaration syntax</label->
</syntax->
<example- class="full-example">
    <label->Example</label->
    <div>
        <w->struct</w-> <t->idk</t-> {
            <t->uint</t-> a, b;        <c->// Ok</c->
            <t->double</t->[<k->4</k->] c;      <c->// Ok</c->
        }

        <t->void</t-> <f->main</f->(){
            <t->idk</t-> var;
            var.a = <k->4</k->;              <c->// Ok, var = (4, ?, ?)</c->
            var.b = <k->var.a</k-> * <k->4</k->;      <c->// Ok, var = (4, 8, ?)</c->
        }
    </div>
</example->


<h1 id="struct-methods"></h1>
<p>
    <b>Structs</b> can contain <b>functions</b>. These functions are called <b>methods</b>.<br>
    They are part of the struct scope and are called in the same way as standard functions.
</p>
<p>
    Struct methods can access the members of the value they are called on, and the special identifier <code>this</code> can be used to reference the value itself.<br>
    If the value they are called on is a constant, <code>this</code> and all the members are also constants. Attempting to change their value generates a semantic error.<br>
    Template methods are allowed.
</p>
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example</label->
            <div>
                <c->// 2D uint vector</c->
                <w->struct</w-> <t->uint2</t-> {
                    <t->uint</t-> x, y;

                    <t->void</t-> <f->print</f->(){
                        io.<f->print</f->(<s->"x:"</s-> <f->+</f-> <t->str</t->(x));
                        io.<f->print</f->(<s->"\ny: "</s-> <f->+</f-> <t->str</t->(this.y));
                        <c->// Notice that this. is not required when accessing members</c->
                    }

                }

                <t->void</t-> <f->main</f->(){
                    <t->uint2</t-> v = { <k->15</k->, <k->9</k-> };
                    <k->v</k->.<f->print</f->();
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Output</label->
            <div>
                x: 15
                y: 9<cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->


<h1 id="constructor-function"></h1>
<p>
    The <b>constructor</b> function is a <b>special</b> struct <b>method</b> that is called each time a value of its parent struct type is created.<br>
    It has <b>no name</b> and <b>no explicit return type</b> and it's declared using the <code><w->constructor</w-></code> meta keyword. Constructor calls always return an l-value of type their parent struct.<br>
    Differently from other struct methods, the constructor can modify members when called on constant values.
</p>
<p>
    Each struct can only have one constructor, but it can be specialized.<br>
    Template constructors are allowed, although it is not possible to reference a specific template through the <elm-><code>&lt;</code><code>&gt;</code></elm->
    meta keyword while creating a new value, meaning that the declaration is chosen solely based on the passed arguments.<br>
    Constructors cannot be called after the value has been created, but each constructor declaration can call other declarations in the same struct.
</p>
<p>
    By default, each struct contains one implicit constructor that takes a reference parameter for each member in the same order in which they were declared and initializes them by copying the value from their respective parameter.<br>
    This constructor is not present in structs declared using the <code><w->nodefault</w-></code> meta keyword.<br>
    Constructors are allowed to take no arguments.
</p>
<example- class="full-example">
    <label->Example</label->
    <div>
        <w->struct</w-> <t->uint2</t-> {
            <t->uint</t-> x, y;
        }


        <w->struct</w-> <t->uint3</t-> <w->nodefault</w-> {
            <t->uint</t-> x, y, z;

            <w->constructor</w->(<t->uint2</t-> <p->a</p->, <t->uint</t-> <p->b</p->) {
                x <f->=</f-> a.x;
                y <f->=</f-> a.y;
                z <f->=</f-> b;
            }

            <w->constructor</w->(<t->uint</t-> <p->a</p->, <t->uint2</t-> <p->b</p->) {
                x <f->=</f-> a;
                y <f->=</f-> b.x;
                z <f->=</f-> b.y;
            }
        }


        <t->void</t-> <f->main</f->(){
            <t->uint2</t-> a = { <k->1</k->, <k->2</k-> };     <c->// Default constructor</c->
            <t->uint3</t-> b = { <k->a</k->, <k->5</k-> };     <c->// User-defined constructor</c->
            <t->uint3</t-> c = { <k->5</k->, <k->a</k-> };     <c->// User-defined constructor</c->
            <c->//uint3 d = (1, 2, 3);</c->  <ce->// Error, no suitable constructor declaration</ce->
        }
    </div>
</example->


<h1 id="destructor-function"></h1>
<p>
    The <b>destructor</b> function is a <b>special</b> struct <b>method</b> that is called each time a value of its parent struct type is destroyed.<br>
    It has <b>no name</b> and <b>no return value</b> and it's declared using the <code><w->destructor</w-></code> meta keyword.<br>
</p>
<p>
    Each struct can only have one destructor. It cannot be specialized and cannot take any argument, nor can it be called explicitly.<br>
    Template destructors are not allowed.<br>
    There is no default destructor.
</p>
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;
                <t->int</t-> last = <k->0</k->;

                <w->struct</w-> <t->s</t-> {
                    <t->float</t-> n;
                    <t->int</t-> i;

                    <w->constructor</w->(<t->float</t-> <p->n</p->){
                        i <f->=</f-> last<f->++</f->;
                        this.n <f->=</f-> n;
                    }

                    <w->destructor</w->(){
                        io.<f->print</f->(<s->"Destroyed instance n."</s-> <f->+</f-> <t->str</t->(i) <f->+</f-> <s->"\n"</s->);
                    }
                }


                <t->void</t-> <f->main</f->(){
                    <t->s</t-> var = { <k->0.5</k-> };
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Output</label->
            <div>
                Destroyed instance n.0
                Destroyed instance n.1
                <cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->


<h1 id="struct-specialization"></h1>
<p>
    Struct specialization allows structs to contain different methods and data based on user-defined constraints.<br>
    This is achieved by declaring the same struct multiple times. Each declaration must be <b>unique</b>.
    Arguments passed to the constructor don't affect the chosen struct declaration.
</p>
<p>
    Struct declarations whose specialization constraint is not satisfied are discarded.<br>
    As with routine specialization, if zero or more than one declaration is suitable, a semantic error is generated.
</p>
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example</label->
            <div>
                <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <w->struct</w-> <t->s</t-> <w->when</w->(<t->t</t->::id <f->!=</f-> <t->void</t->::id) {
                    <t->t</t-> n;
                    <w->constructor</w->() {
                        io.<f->print</f->(<s->"Not void\n"</s->);
                    }
                }
                <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <w->struct</w-> <t->s</t-> <w->when</w->(<t->t</t->::id <f->==</f-> <t->void</t->::id) {
                    <w->constructor</w->() {
                        io.<f->print</f->(<s->"Void\n"</s->);
                    }
                }

                <t->void</t-> <f->main</f->(){
                    <t->t</t->&lt;<t->int</t->&gt;  <k->a</k->;
                    <t->t</t->&lt;<t->void</t->&gt; <k->b</k->;
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Output</label->
            <div>
                Not void
                Void
                <cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->


<h1 id="special-types"></h1>
<p></p>


<h1 id="void-type"></h1>
<p>
    The <code><t->void</t-></code> type is used to declare routines that don't return any value.<br>
    It has no other purpose but it can be passed to type template parameters to generate different declarations.
</p>
<example- class="full-example">
    <label->Example 1</label->
    <div>
        <f->uint</f-> counter = <k->0</k->;
        <t->void</t-> <f->inc_counter</f->(){ counter<f->++</f->; }

        <t->void</t-> <f->main</f->(){
            <f->inc_counter</f->();
        }
    </div>
</example->
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example 2</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;
                <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <t->void</t-> <f->print_template_info</f->()
                <w->when</w->(<t->t</t->::<k->id</k-> <f->!=</f-> <t->void</t->::<k->id</k->) { io.<f->print</f->(<s->"not void"</s->); }
                <w->when</w->(<t->t</t->::<k->id</k-> <f->==</f-> <t->void</t->::<k->id</k->) { io.<f->print</f->(<s->"void"</s->); }

                <t->void</t-> <f->main</f->(){
                    <f->print_template_info</f->&lt;<t->void</t->&gt;();
                    <f->print_template_info</f->&lt;<t->int</t->&gt;();
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Output</label->
            <div>
                void
                not void
                <cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->


<h1 id="pointer-types"></h1>
<p>
    Pointer types are implicit types that can store a memory address of a specific type. Their size is always 8 byes.<br>
    They are referenced through the symbol path of the pointed type, also known as base type, followed by the <code>@</code> keyword.<br>
    The <code><t->const</t-></code> meta keyword can be placed between the base type and the <code>@</code> keyword to reference the corresponding const pointer. Const pointers are detailedly explained in <a href="#const-qualifier">Const qualifier</a>.
</p>
<p>
    The <code>@</code> keyword is also used to access the value pointed by a pointer expression.<br>
    The address of any l-value can be retrieved through the <code>$</code> keyword.
</p>
<p>
    Pointer types don't have to be declared. Each existing type but <code><t->void</t-></code> has its own corresponding pointer type and <code><t->const</t-></code> pointer type ready to use, including the pointer types themselves.
    <code><t->void</t-></code> pointers are not allowed.<br>
    There is no limit to the amount of nested pointer types one can use as base type.
</p>
//TODO add memory allocation examples
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example 1</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;

                <t->void</t-> <f->main</f->(){
                    <t->int</t-> n = <k->5</k->;
                    <t->int@</t-> p = $<k->n</k->;

                    @p = <k->6</k->;
                    io.<f->print</f->(<t->str</t->(<k->n</k->));
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Output</label->
            <div>
                6<cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example 2 - Nested pointer types</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;

                <t->void</t-> <f->main</f->(){
                    <t->int</t-> a = <k->5</k->;
                    <t->int@</t-> p;
                    <t->int@@</t-> p2 = $p;
                    @p2 = $<k->n</k->;

                    @@p2 = <k->6</k->;
                    io.<f->print</f->(<t->str</t->(<k->a</k->));
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Output</label->
            <div>
                6<cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->


<h1 id="function-types"></h1>
<p>
    Function types are implicit types that can store functions.<br> //TODO add size info
    These are used for callbacks and higher level functions.<br>
    They are referenced by specifying the return type, followed by <elm-><code>(</code><code>)</code></elm-> keywords containing the types of each parameter.
</p>
<p>
    Referencing a function or using a function inline declaration without calling them generate function r-values which can be stored in function types.<br>
    This is only allowed for non-specialized routines, as specialization is not compatible with function values. The only exception are <a href="#default-values">default values</a> which get disabled when retrieving the function value.<br>
    Operators cannot be stored as values, but it's still possible to create a wrapper function and save that instead.
</p>
<p>
    Function type expressions can be called like standard functions.<br>
    As with pointers, function types don't require a declaration in order to be used.<br>
    Function values can only be implicitly converted based on the constness of their parameters. This is explained in <a href="#implicit-conversions">Implicit conversions</a>.
</p>
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example 1 - Callback</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;

                <w->struct</w-> <t->t</t-> {
                    <w->constructor</w->(<t->void</t->() <p->callback</p->) {
                        <f->callback</f->();
                    }
                }

                <t->void</t-> <f->print_owo</f->(){
                    io.<f->print</f->(<s->"OwO"</s->);
                }

                <t->void</t-> <f->main</f->(){
                    <t->t</t-> a = { <t->void</t->(){ io.<f->print</f->(<s->"Variable \"a\" created\n"</s->); } };
                    <t->t</t-> b = { <f->print_owo</f-> };
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Output</label->
            <div>
                Variable "a" created
                OwO<cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example 2 - Higher level function</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;

                <t->void</t-> <f->map</f->(<t->arr</t->&lt;?<t->t</t->&gt;<t->*</t-> <p->a</p->, ?<t->r</t->(<t->t*</t->) <p->f</p->) {
                    <w->for</w->(e <w->in</w-> a) <f->f</f->(e);
                }

                <t->void</t-> <f->main</f->(){
                    <t->arr</t->&lt;<f->int</f->&gt; a = { <k->1</k->, <k->2</k-> };
                    io.<f->print</f->(<s->"Before map: "</s-> <f->+</f-> <t->str</t->(<k->a</k->) <f->+</f-> <s->"\n"</s->);

                    <f->map</f->($<k->a</k->, <t->void</t->(<t->int@</t-> <p->n</p->){ @n <f->*=</f-> <k->5</k->; });
                    io.<f->print</f->(<s->"After  map: "</s-> <f->+</f-> <t->str</t->(<k->a</k->));
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Output</label->
            <div>
                Before map: [1, 2]
                After  map: [5, 10]<cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->


<h1 id="const-qualifier"></h1>
<p>
    When used between the base type and the <code>@</code> keyword of a pointer type, the <b><code><t->const</t-></code> qualifier</b> indicates that the type is a <b>const pointer</b>.<br>
    Data accessed by dereferencing a <code><t->const</t-></code> pointer value cannot be modified.<br>
    Non-<code><t->const</t-></code> pointers are implicitly convertible to their respective <code><t->const</t-></code> pointer type. This is explained in <a href="implicit-conversions">Implicit coversions</a>.
</p>
<p>
    <b><code><w->const</w-></code></b> can also be used before the name of a <b>variable</b> or <b>routine parameter</b> to <b>prevent them from being modified</b> after their declaration, although this doesn't turn the type of the symbol into a const type.<br>
    The address of <code><w->const</w-></code> variables or <code><w->const</w-></code> routine parameters is always returned as a <code><t->const</t-></code> pointer.
</p>
<example- class="full-example">
    <label->Example 1 - Const pointer</label->
    <div>
        <t->void</t-> <f->main</f->(){
            <t->int</t-> var = <k->8</k->;
            <t->int const@</t-> ptr = @<k->var</k->;

            <k->var</k-> <f->=</f-> <k->9</k->;     <c->// Ok</c->
            <c->//@ptr = 9;</c->  <ce->// Error, cannot modify data pointed by const pointers</ce->
        }
    </div>
    <label->Example 2 - Const variable</label->
    <div>
        <t->void</t-> <f->main</f->(){
            <t->int</t-> var <w->const</w-> = <k->8</k->;

            <c->var = 9;</c->  <ce->// Error, cannot modify const variables</ce->
        }
    </div>
</example->


<h1 id="auto-specifier"></h1>
<p>
    The <b><code><t->auto</t-></code></b> specifier can be <b>used as</b> a <b><a href="#types">type</a></b> when declaring a <a href="#semantic-elements">symbol</a>.<br>
    The actual <a href="#types">type</a> of the <a href="#semantic-elements">symbol</a> is determined by the initializer value if a <a href="#variables">variable</a>, or by the <a href="#return-statement">return value</a> if a <a href="#routines">routine</a>.<br>
</p>
<p>
    <code><t->auto</t-></code> is not allowed in <a href="#structs">struct</a> member declarations or <a href="#routine-parameters">routine parameters</a>.<br>
    The <a href="#types">types</a> of the <a href="#expressions">expressions</a> returned from an <code><t->auto</t-></code> <a href="#routines">routine</a> must match.
</p>
<example- class="full-example">
    <label->Example 1</label->
    <div>
        <t->auto</t-> <f->func</f->(){
            <w->return</w-> <k->true</k->;        <c->// func has type bool</c->
        }

        <t->auto</t-> <f->main</f->(){
            <t->auto</t-> a = <k->2</k->;         <c->// a has type ulong</c->
            <t->auto</t-> b = <k->5.4</k-> * <k->a</k->;   <c->// b has type double</c->
            <t->auto</t-> c = <f->func</f->();    <c->// c has type bool</c->
            <c->// No return statement, main has type void</c->
        }
    </div>
</example->


<h1 id="typeof-specifier"></h1>
<p>
    The <b><code><t->typeof</t-></code></b> specifier is used in the same way as <code><t->auto</t-></code>, but the <b>type</b> is defined by the <b><a href="#expressions">expression</a></b> that is passed to it.<br>
    The <a href="#expressions">expression</a> is exclusively used to determine the type and never evaluated.<br>
    Circular dependencies generate a semantic error. //TODO LINK
</p>
<example- class="full-example">
    <label->Example 1</label->
    <div>
        <t->auto</t-> <f->f</f->(){}                  <c->// f has type void</c->

        <t->typeof</t->(<f->f</f->()) <f->main</f->(){         <c->// main has type void</c->
            <t->int</t-> a = <k->1</k->;              <c->// a has type int</c->
            <t->typeof</t->(<k->a</k->) b = <k->a</k-> * <k->2</k->;    <c->// b has type int</c->
        }
    </div>
</example->
<example- class="full-example">
    <label->Example 2</label->
    <div>
        <c->//typeof(b) a(){};</c->  <ce->//Error, circular dependency with b</ce->
        <c->//typeof(a) b(){};</c->  <ce->//Error, circular dependency with a</ce->
    </div>
</example->


<h1 id="implicit-conversions"></h1>
<p>
    <b>Implicit conversions</b> are performed when an <b><a href="#expressions">expression</a></b> of the <b>incorrect <a href="#types">type</a></b> is used in place of the expected one.<br>
    This includes anything whose syntax requires an <a href="#expressions">expression</a>.<br>
</p>


<h1 id="implicit-conversions.primitive-types"></h1>
<p>
    <a href="#primitive-types">Primitive types</a> are all implicitly convertible to each other.<br>
    In Lux, some conversions have <a href="#undefined-values">undefined result</a>.<br>
    In Umbra, the same conversions cause <a href="#undefined-behaviour">undefined behaviour</a>.<br>
    The result of the conversions follow these rules:
    //TODO use fedisableexcept(FE_ALL_EXCEPT);
    //TODO it only works on  floating points. integers throw exceptions anyway
</p>

<div class="table-container"><table>
        <tr>
            <th colspan="2">From / To</th>
            <th><t->uint</t-></th>
            <th><t->int</t-></th>
            <th><t->ulong</t-></th>
            <th><t->long</t-></th>
            <th><t->float</t-></th>
            <th><t->double</t-></th>
            <th><t->bool</t-></th>
        </tr>

        <tr class="even">
            <th rowspan="13"><t->uint</t-><br><br><t->int</t-><br><br><t->ulong</t-><br><br><t->long</t-></th>
            <th><range-val->== <k->-9223372036854775808</k-><br><range-var->long::min</range-var-></range-val-></th>
            <td class="center wrap conv-cell-m" rowspan="5">Overflows to (-n - <k->1</k->) % (uint::<k->max</k-> - <k->1</k->)</td>
            <td class="center wrap conv-cell-n" rowspan="3">Undefined</td>
            <td class="center wrap conv-cell-m" rowspan="5">Overflows to (-n - <k->1</k->) % (ulong::<k->max</k-> - <k->1</k->)</td>
            <td class="center wrap conv-cell-y" rowspan="11">Correct result</td>
            <td class="center wrap conv-cell-m" rowspan="4">Conversions are not symmetric</td>
            <td class="center wrap conv-cell-m" rowspan="2">Conversions are not symmetric</td>
            <td class="center wrap conv-cell-y" rowspan="5"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-9007199254740992</k-><br><range-var->double::min_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-2147483648</k-><br><range-var->int::min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="8">Correctly rounded</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-16777216</k-><br><range-var->float::min_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="5">Correct result</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->0</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->0</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-y" rowspan="4">Correct result</td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="8">Correct result</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y"><k->false</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->0</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="7"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+16777216</k-><br><range-var->float::max_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-m" rowspan="6">Conversions are not symmetric</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+2147483647</k-><br><range-var->int::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+4294967295</k-><br><range-var->uint::max</range-var-></range-val-></th>
            <td class="center wrap conv-cell-m" rowspan="4">Overflows to n % (uint::<k->max</k-> + <k->1</k->)</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+9007199254740992</k-><br><range-var->double::max_precise_int</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-m" rowspan="3">Conversions are not symmetric</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+9223372036854775807</k-><br><range-var->long::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->+18446744073709551615</k-><br><range-var->ulong::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr>
            <th colspan="2">From / To</th>
            <th><t->uint</t-></th>
            <th><t->int</t-></th>
            <th><t->ulong</t-></th>
            <th><t->long</t-></th>
            <th><t->float</t-></th>
            <th><t->double</t-></th>
            <th><t->bool</t-></th>
        </tr>

        <tr class="even">
            <th rowspan="16"><t->float</t-><br><br><t->double</t-></th>
            <th><range-val->== <k->-inf</k-><br><range-var->-double::inf</range-var-><br><range-var->-float::inf</range-var-></range-val-></th>
            <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
            <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
            <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
            <td class="center wrap conv-cell-n" rowspan="4">Undefined</td>
            <td class="center wrap conv-cell-y" rowspan="1">Correct result</td>
            <td class="center wrap conv-cell-y" rowspan="1">Correct result</td>
            <td class="center wrap conv-cell-y" rowspan="6"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->-1.7976931348623157081e+308</k-><br><range-var->double::min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
            <td class="center wrap conv-cell-y" rowspan="13">Correctly rounded</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-3.4028234663852885981e+38</k-><br><range-var->float::min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-9223372036854775808.0</k-><br><range-var->long::min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="9">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->-2147483648.0</k-><br><range-var->int::min</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="6">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&lt; <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
            <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="5">Correctly rounded</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="1"><k->false</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="8"><k->true</k-></td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+2147483647.0</k-><br><range-var->int::max</range-var-></range-val-></th>
            <td class="center wrap conv-cell-n" rowspan="8">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+4294967297.0</k-><br><range-var->uint::max</range-var-></range-val-></th>
            <td class="center wrap conv-cell-n" rowspan="7">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+9223372036854775807.0</k-><br><range-var->long::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+18446744073709551615.0</k-><br><range-var->ulong::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->&gt; <k->+3.4028234663852885981e+38</k-><br><range-var->float::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->+1.7976931348623157081e+308</k-><br><range-var->double::max</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val->== <k->+inf</k-><br><range-var->double::inf</range-var-><br><range-var->float::inf</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-y" rowspan="2">Correct result</td>
            <td class="center wrap conv-cell-y" rowspan="2">Correct result</td>
            <fake-td></fake-td>
        </tr>
        <tr class="even">
            <fake-td></fake-td>
            <th><range-val-><f->isnan</f->(n)<br><br><range-var->double::nan</range-var-><br><range-var->float::nan</range-var-></range-val-></th>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <fake-td></fake-td>
            <td class="center wrap conv-cell-n" rowspan="1">undefined</td>
        </tr>
        <tr>
            <th colspan="2">From / To</th>
            <th><t->uint</t-></th>
            <th><t->int</t-></th>
            <th><t->ulong</t-></th>
            <th><t->long</t-></th>
            <th><t->float</t-></th>
            <th><t->double</t-></th>
            <th><t->bool</t-></th>
        </tr>

        <tr>
            <th rowspan="2"><t->bool</t-></th>
            <th class="nowrap small"><k->false</k-></th>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0</k-></td>
            <td class="center wrap conv-cell-y"><k->0.0</k-></td>
            <td class="center wrap conv-cell-y"><k->0.0</k-></td>
            <td class="center wrap conv-cell-y"><k->false</k-></td>
        </tr>
        <tr>
            <fake-td></fake-td>
            <th class="nowrap small"><k->true</k-></th>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
            <td class="center wrap conv-cell-y"><k->1.0</k-></td>
            <td class="center wrap conv-cell-y"><k->1.0</k-></td>
            <td class="center wrap conv-cell-y"><k->true</k-></td>
        </tr>
</table></div>


<h1 id="implicit-conversions.enums"></h1>

<p>
    <a href="#expressions">Expressions</a> of enum <a href="#types">types</a> are <a href="#implicit-conversions">implicitly convertible</a> to their base <a href="#types">type</a>
    and those whose base <a href="#types">type</a> is a <a href="#primitive-types">primitive type</a> are implicitly convertible to any <a href="#primitive-types">primitive type</a>,
    following all the <a href="#impliti-conversions">implicit conversion rules</a> their base <a href="#types">type</a> is subject to.
</p>
<example- class="full-example">
    <label->Example</label->
    <div>
        <w->enum</w-> <t->e</t-> : <t->int</t-> {
            <k->a</k->, <k->b</k->, <k->c</k->;
        }

        <w->enum</w-> <t->e2</t-> : <t->e</t-> {
            <k->a</k-> = e:<k->b</k->, <k->b</k-> = e:<k->a</k->;
        }

        <t->void</t-> <f->main</f->(){
            <t->int</t->   a = e.<k->b</k->;
            <t->float</t-> b = e.<k->c</k->;

            <t->e</t->   c = e2.<k->a</k->;
            <t->int</t-> d = <k->c</k->;
        }
    </div>
</example->


<h1 id="implicit-conversions.pointer-types"></h1>

<p>
    All pointer types are implicitly convertible to <code><t->ulong</t-></code> values.
</p>
<example- class="full-example">
    <label->Example</label->
    <div>
        <t->void</t-> <f->main</f->(){
            <t->ulong</t-> var = @var;
        }
    </div>
</example->


<h1 id="implicit-conversions.constness-conversions"></h1>
<p>
    Non-<code><t->const</t-></code> pointer types are implicitly convertible to their respective <code><t->const</t-></code> pointer type.<br>
    If the base type is itself a pointer type, then it must be convertible to the base type of the target type.<br>
    For instance, an <code><t->int@</t-></code> expression would be convertible to <code><t->int const@</t-></code> only,
    and an <code><t->int const@ const@</t-></code> would be convertible to <code><t->int@ const@</t-></code>, <code><t->int const@@</t-></code> and <code><t->int@@</t-></code>.
</p>
<p>
    This also applies to const pointer types used as part of function types, with the added constraint that
    all of the pointer types used in the source function type must be implicitly convertible to their respective pointer types in the target function type.
</p>
<example- class="full-example">
    <label->Example 1</label->
    <div>
        <t->void</t-> <f->main</f->(){
            <t->int</t-> <k->n</k->;
            <t->int</t-> <t->const</t->@ p = $<k->n</k->;    <c->// Ok, non-const to const conversion</c->
            <c->//int@ p2 = p;</c->        <ce->// Error, cannot convert int const@ to int@</ce->
        }
    </div>
    <label->Example 2</label->
    <div>
        <t->void</t-> <f->main</f->(){
            <t->double const@</t->(<t->float@</t->, <t->float const@ const@</t->) f;
            <f->f</f-> <f->=</f-> <t->double@</t->(<t->float@</t-> <p->a</p->, <t->float@@</t-> <p->b</p->) { <w->return</w-> <k->0</k->; };              <c->// Ok</c->
            <f->f</f-> <f->=</f-> <t->double</t-> <t->const@</t->(<t->float@</t-> <p->a</p->, <t->float@</t-> <t->const@</t-> <p->b</p->) { <w->return</w-> <k->0</k->; };  <c->// Ok</c->
            <c->//f = double const @(float const@ a, float@ const@ b) { return 0; };</c->
            <ce->//  ^ Error, cannot convert double const@(float const@, float@ const@) to double const@(float@, float const@ const@)</ce->
        }
    </div>
</example->


<h1 id="expressions"></h1>


<h1 id="inline-values"></h1>
<p>
    Inline values are <a href="#right-and-left-values">r-values</a> that are explicitly created and used within a single <a href="#runtime-statements">runtime statement</a>.<br>
    They can be <a href="#literals">Literals</a> or <a href="#try-expression"><code><w->try</w-></code> expressions</a>.
</p>


<h1 id="literals"></h1>
<p>
    <b>Literals</b> are used to <b>create</b> compile time known <b><a href="#left-and-right-values">r-values</a></b>.<br>
    The type of the value is determined by the way it is represented in the source code, and it can only be of <code><t->ulong</t-></code>, <code><t->double</t-></code> or <code><t->bool</t-></code> type.<br>
    Literals can be used in place of any expression of compatible type. Their value is converted following the <a href="#implicit-conversions">implicit conversions</a> rules.
</p>
<p>
    Base prefixes can be used to specify the numerical base of the value.<br>
    The decimal prefix is optional.<br>
    Hexadecimal literals are case insensitive, leading zeroes and trailing decimal zeroes are ignored.<br>
    Unary <a href="#common-operators"><code>+</code></a> and <a href="#common-operators"><code>-</code></a> operators are not part of the literal.
</p>
<p>
    Literals are not sequences of <a href="#syntaxtic-elements">syntactic elements</a> like other <a href="#semantic-elements">semantic elements</a>, but a category of <a href="#syntaxtic-elements">syntactic element</a>.<br>
    Regex syntax is used to describe their pattern:
</p>
<div class="table-container"><table>
    <tr>
        <th>Type/Base</th>
        <th>Hexadecimal (hex)</th>
        <th>Decimal (dec)</th>
        <th>Octal (oct)</th>
        <th>Binary (bin)</th>
    </tr>
    <tr>
        <th rowspan="2"><t->ulong</t-></th>
        <td class="center"><code>0x([0-9a-z_]+)</code></td>
        <td class="center"><code>(0d)?([0-9][0-9_]+)</code></td>
        <td class="center"><code>0o([0-7_]+)</code></td>
        <td class="center"><code>0b([01_]+)</code></td>
    </tr>
    <tr>
        <fake-td></fake-td>
        <td class="center" colspan="4"><code>inf|nan</code></td>
        <fake-td></fake-td>
        <fake-td></fake-td>
        <fake-td></fake-td>
    </tr>
    <tr>
        <th rowspan="2"><t->double</t-></th>
        <td class="center"><code>0x([0-9a-z_]+)\.([0-9a-z_]+)</code></td>
        <td class="center"><code>(0d)?([0-9][0-9_]*)\.([0-9_]+)</code></td>
        <td class="center"><code>0o([0-7_]+)\.([0-7_]+)</code></td>
        <td class="center"><code>0b([01_]+)\.([01_]+)</code></td>
    </tr>
    <tr>
        <fake-td></fake-td>
        <td class="center" colspan="4"><code>inf|nan</code></td>
        <fake-td></fake-td>
        <fake-td></fake-td>
        <fake-td></fake-td>
    </tr>
    <tr>
        <th><t->bool</t-></th>
        <td class="center" colspan="4"><code>true|false</code></td>
    </tr>
</table></div>
<example- class="full-example">
    <label->Example</label->
    <div>
        <t->int</t-> n = <k->4</k->;             <c->// Ok</c->
        <t->bool</t-> b =<k-> true</k->;         <c->// Ok</c->
        <t->float</t-> f1 = <k->0x0d.aAb4</k->;  <c->// Ok</c->
        <t->float</t-> f2 = <k->inf</k->;        <c->// Ok</c->
        <t->float</t-> f3 = <k->nan</k->;        <c->// Ok</c->
        <c->float f4 = AAAB4;      </c-><ce->// Error, undeclared identifier "AAAB4"</ce->
        <c->float f4 = 0o97;       </c-><ce->// Error, invalid octal literal</ce->
        <c->float f4 = 0xAEGF;     </c-><ce->// Error, invalid hexadecimal literal</ce->
    </div>
</example->
<p>
    The <code>_</code> character can be used anywhere after the base prefix of numerical literals to separate digits and improve readability.<br>
    Decimal literals without base prefix cannot start with <code>_</code>.
</p>
<example- class="full-example">
    <label->Example</label->
    <div>
        <t->int</t-> n = <k->395_935</k->;             <c->// Ok</c->
        <t->int</t-> n = <k->654_3_21___</k->;         <c->// Ok, doesn't make sense but it is allowed</c->
        <t->int</t-> n = <k->0x_32_A4_FF_E2</k->;      <c->// Ok</c->
        <c->//int n = _123_456;</c->          <ce->// Error, undeclared identifier "_123_456".</ce->
    </div>
</example->
<p>
    There are no literal suffixes and no <code><t->float</t-></code>, <code><t->uint</t-></code> or <code><t->int</t-></code> literals.<br>
    To create inline values of specific types, <a href="#constructors">Constructors</a> are used.
</p>


<h1 id="function-calls"></h1>
<p>
    <b>Functions</b> are <b>called</b> using their <b>name</b> and a list of <b>arguments</b>.<br>
    A function call must provide an argument for each parameter of the function.<br>
    Reference parameters (<a href="#references"><code>&</code></a>) only allow <a href="#left-and-right-values">l-values</a> as arguments.
</p>
<p>
    The result is returned by the function through the return statement, which is detailedly explained in <a href="#return-statement">Return statement</a>
    //TODO templates
    //TODO functions are called with *function reference* and a list of parameters. not just their name
</p>

<syntax->
    <label- id="copy.syntax--expression-function-call">Syntax</label->
</syntax->


<example- class="full-example">
    <label->Example</label->
    <div>
        <t->void</t-> <f->empty_function_1</f->() { <w->return</w->; }    <c->// Ok</c->
        <t->void</t-> <f->empty_function_2</f->() {}             <c->// Ok</c->

        <t->uint</t-> <f->empty_function_3</f->() { <w->return</w-> <k->0</k->; }  <c->// Ok</c->
        <c->//uint empty_function_4() {}           </c-><ce->// Error, non-void functions must return a value</ce->

        <t->uint</t-> <f->f</f->(<t->uint</t-> <p->n</p->) { <w->return</w-> n * <k->2</k->; }       <c->// Ok</c->
        <c->//void f() { }                         </c-><ce->// Error, f is already defined</ce->

        <t->void</t-> <f->main</f->(){
            <t->uint</t-> n = <f->empty_function_3</f->();       <c->// Ok</c->
            n = <f->f</f->(<f->f</f->(<k->n</k->));                       <c->// Ok</c->
        }
    </div>
</example->
//TODO update example


<h1 id="operator-calls"></h1>
<p>

</p>

<syntax->
    <label- id="copy.syntax--expression-operator-call">Syntax</label->
</syntax->


<h1 id="try-expression"></h1>
<p>
</p>


<h1 id="stored-values"></h1>
<p>
    <b>Stored values</b> are <b>named memory locations</b> that can contain values of the specified type.<br>
</p>


<h1 id="variables"></h1>
<p>
    <b>Variables</b> are <b>named memory locations</b> used to <b>store values</b> of the corresponding <a href="#types">type</a>.<br>
    Multiple variables of the same <a href="#types">type</a> can be declared in one declaration. If an initializer <a href="#expressions">expression</a> is not specified, the variable has <a href="#undefined-values">undefined value</a>.<br>
</p>
<p>
    Differently from other <a href="#name-resolution">symbols</a>, each variable <b>must be declared</b> before being <a href="#name-resolution">referenced</a>. Variables <b>cannot be redeclared</b> and their <b><a href="#types">type</a> cannot be changed</b> after the declaration.<br>
</p>
<syntax->
    <label- id="copy.syntax--declaration-variable">Declaration syntax</label->
</syntax->

<example- class="full-example">
    <label->Example</label->
    <div>
        <t->uint</t-> var = <k->0</k->;              <c->// Ok, var has value 0</c->
        <t->float</t-> nya = <k->5</k-> + <k->var</k->;       <c->// Ok, nya has value 5.0</c->
        <t->bool</t-> var2, &var3 = var2;   <c->// Ok, both var2 and var3 have undefined value.</c->
    </div>
</example->


<h1 id="temporary-variables"></h1>
<p>
    <b>Temporary variables</b> are a special set of identifiers that have <b>dynamic type</b> and don't need to be declared.<br>
    These identifiers are meant to replace local variables whose only purpose is holding values that don't need to be used more than a few times.<br>
    A temporary variable is identified by the <code>$</code> character followed by a <a href="#integral-types"><code><t->ulong</t-></code></a> <a href="#literals">literal</a>, which denotes its name.<br>
</p>
<p>
    They are always <b>function-level scoped</b> and cannot be used outside of function definitions.<br>
    There is no limit to the number of temporary variables a function can use.<br>
</p>
<p>
    The type of a temporary variable can only be changed through direct assignments (<a href="#assignments"><code>=</code></a>) and it must be unambiguously determinable in order for the variable to be evaulated.
    This means that reading the value of a temporary variable after one or more branches that may have assigned it different types is not allowed and will result in a semantic error.<br>
    Using temporary variables whose type is undefined will also result in a semantic error.
</p>
<p>They act as normal variables for anything else.</p>

<example- class="full-example">
    <label->Example 1</label->
    <div>
        <t->uint3</t-> <f->fun1</f->(<t->bool</t-> <p->arg</p->) {
            $0 = <k->1</k->;             <c->// Ok, $0 has type uint and value 1</c->
            <c->//$2 = $1;          </c-><ce->// Error, $1 has undefined type</ce->

            <t->uint3</t-> vec = { <k->0</k->, <k->1</k->, <k->2</k-> };
            $2 = <k->true</k->;          <c->// Ok, $2 has type b and value true</c->
            $2 = <k->vec</k->;           <c->// Ok, $2 has type uint3 and value { 0, 1, 2 }</c->
        }

        <t->void</t-> <f->fun2</f->(<t->uint3</t-> <p->vec</p->) {
            <c->//uint var = $2;    </c-><ce->// Error, $2 has undefined type. fun2.$2 has nothing to do with fun1.$2</ce->
        }

        <c->//uint var = $9;        </c-><ce->// Error, temporary variables cannot be used outside of functions</ce->
    </div>
</example->
<example- class="full-example">
    <label->Example 2</label->
    <div>
        <t->void</t-> <f->fun3</f->(<t->bool</t-> <p->arg</p->, <t->uint2</t-> &<p->ref</p->) {
            <w->if</w->(arg) $0 = <k->1</k->;             <c->// $0 has type uint</c->
            <w->else</w->    $0 = { <k->0</k->, <k->1</k-> };      <c->// $0 has type uint2</c->
            <c->//ref = $0;                 </c-><ce->// Error, cannot determine the type of $0</ce->
            $0 = ref;                   <c->// Ok, $0 has type uint2 and the same value as ref</c->

            <w->if</w->(arg) $0 = { <k->0</k->, <k->1</k-> };      <c->// $0 has type uint2</c->
            <w->else</w->    $0 = { <k->2</k->, <k->3</k-> };      <c->// $0 has type uint2</c->
            ref = <k->$0</k->;                   <c->// Ok, $0 has type uint2</c->
        }
    </div>
</example->
<p>
    See
    <a href="#types">Types</a>,
    <a href="#selection">Selection</a>,
    <a href="#functions">Functions</a>,
    <a href="#expressions">Expressions</a>
</p>


<h1 id="exp.routine-parameters"></h1>
<p></p>


<h1 id="routines"></h1>
<p>
    <b>Routines</b> are the <b>main component</b> of the <b>language</b>. They contain the <a href="#statements"><b>statements</b></a> that will be executed during runtime.<br>
    They are used to organize the module, provide features and prevent code duplication.<br>
    The routine execution starts from its first <a href="#statements">statement</a> and ends after the first encountered <a href="#return-statements">return statement</a>.
</p>
<p>
    There are 2 types of routines: <a href="#declarations.functions">Functions</a> and <a href="#declarations.operators">Operators</a>.<br>
    They use different signatures and <a href="#routine-calls">calling</a> syntaxes but share the same <a href="#declarations.routine-parameters">parameter</a> and body declarations.
</p>
<p>
    Each routine can <a href="#return-statement">return</a> a single value when <a href="#routine-calls">called</a>.<br>
    The <a href="#types">type</a> of the <a href="#return-statement">returned</a> value is defined by the <a href="#types">type</a> of the routine.<br>
    Routines that don't return a value have to be declared using the <code><t->void</t-></code> type.
</p>


<h1 id="routine-parameters"></h1>
<p>
    Routine parameters are named memory locations used to pass arguments to <a href="#routine-calls">routine calls</a>.<br>
    They work in the same way as <a href="#variables">variables</a>, but the initializer value is defined by the caller routine or copied from the <a href="#default-values">default value</a>.<br>
    As with <a href="#variables">variables</a>, routine parameters are first allocated and then initialized by calling the <code>=</code> operator, one parameter at a time, following the order in which they were declared.
</p>
<syntax->
    <label- id="copy.syntax--declaration-routine-parameter">Declaration syntax</label->
</syntax->
<example- class="full-example">
    <label->Example</label->
    <div>
        <t->int</t-> <f->add</f->(<t->uint</t-> <p->a</p->, <t->uint</t-> <p->b</p->) {
            <w->return</w-> a <f->+</f-> b;
        }

        <t->void</t-> <f->main</f->(){
            <t->uint</t-> a = <k->5</k->;
            <t->uint</t-> r = <f->add</f->(<k->a</k->, <k->6</k->);
        }
    </div>
</example->


<h1 id="functions"></h1>


<h1 id="function-declarations"></h1>
<p>
    <b>Functions</b> are a type of <b><a href="declarations.routines">routine</a></b> that requires parentheses to be called.<br>
    They always use the infix notation and can take any number of <a href="#declarations.routine-parameters">parameters</a>.
</p>
<p>
    Function <a href="#identifiers">identifiers</a> must be alphanumeric.
</p>
<syntax->
    <label- id="copy.syntax--declaration-function">Declaration syntax</label->
    <label- id="copy.syntax--declaration-function-signature">Function signature</label->
    <label- id="copy.syntax--declaration-routine-body">Routine body</label->
    <label- id="copy.syntax--declaration-specialization-constraint">Specialization constraint</label->
</syntax->
<example- class="full-example">
    <label->Example - Add function</label->
    <div>
        <t->int</t-> <f->add</f->(<t->int</t-> <p->a</p->, <t->int</t-> <p->b</p->){
            <w->return</w-> a + b;
        }

        <t->void</t-> <f->main</f->(){
            <t->int</t-> n = </t-><f->add</f->(<k->4</k->, <k->6</k->)
        }
    </div>
</example->


<h1 id="the-main-function"></h1>
<p>
    The <b><code><f->main</f-></code> function</b> is where the <b>code execution starts and ends</b>.<br>
    Every module passed to the compiler <b>must define</b> a <b><code><f->main</f-></code></b> function.<br>
</p>
<p>
    //TODO interaction btween the languages
</p>
<p>
    The main function cannot use templates and cannot be <a href="#routine-specialization">specialized</a> in any way.
</p>


<h1 id="default-values"></h1>
<p>
    <b>Default values</b> are used to <b>initialize</b> a routine parameter <b>when no argument is provided</b>.<br>
    They are defined in the same way as <a href="#variables">variable initializer values</a>.
</p>
<p>
    A function can have multiple parameters <b>with</b> a default value, but they must all be declared <b>after</b> the <b>last</b> parameter that <b>doesn't have one</b>.<br>
    Parameters of <a href="#operators">operators</a> cannot have default value.
</p>
<example- class="full-example">
    <label->Example</label->
    <div>
        <w->import</w-> <s->&lt;math&gt;</s->;
        <t->double</t-> <f->pow</f->(<t->double</t-> <p->a</p->, <t->double</t-> <p->b</p-> = <k->2</k->) {
            <w->return</w-> math.<f->pow</f->(a, b);
        }

        <t->void</t-> <f->main</f->(){
            <f->pow</f->(<k->3</k->, <k->3</k->);  <c->// Returns 27</c->
            <f->pow</f->(<k->3</k->);     <c->// Returns 9</c->
        }
    </div>
</example->


<h1 id="parameter-packs"></h1>
<p>
    <b>Parameter packs</b> allow <a href="#functions">functions</a> to take an <b>arbitrary number</b> of <b>arguments</b>.<br>
    They are decalred in the same way as <a href="#routine-parameters">routine parameters</a>, but their name is followed by the <code>...</code> <a href="#meta-keywords">meta keyword</a> and their type can be a <a href="#template-parameter-packs">template parameter pack</a>.<br>
    When a <a href="#template-parameter-packs">template parameter pack</a> is used as type, each element of the parameter pack can have a different type. The types are defined by the passed arguments.<br>
    When a <a href="#types">type</a> or a type <a href="#templates">template parameter</a> is used, all the arguments have the same type. The type is determined by following the implicit conversion rules for template routine calls.//TODO link
</p>
<p>
    Parameter packs take zero or more arguments and can only be used as arguments of routine parameters.<br>
    The taken arguments are the ones that remain after all the routine parameters have been assigned their argument. Parameters with default values take priority over the arguments.<br>
    Arguments and parameter pack elements are all initialized in the same order in which they were declared.
</p>
<p>
    Each <a href="#funcitons">function</a> can only use a single parameter pack.<br>
    <a href="#operators">Operators</a> cannot use parameter packs.
</p>
<syntax->
    <label- id="copy.syntax--declaration-function-parameter-pack">Declaration syntax</label->
</syntax->
<example- class="full-example">
    <label->Example 1</label->
    <div>
        <w->struct</w-> <t->NoArg</t-> { };

        <c->// This function returns the value of the argument in the middle, or a value of type NoArg if an even number of arguments is passed</c->
        <w->template</w-> &lt;<w->type</w-> <t->t</t->, <w->type</w-> <t->u</t->..., <w->type</w-> <t->v</t->&gt; <t->auto</t-> <f->get_middle_arg</f->(<t->t</t-> <p->l</p->, <t->u</t-> <p->c</p->..., <t->v</t-> <p->r</p->) {
            <w->return</w-> <f->get_middle_arg</f->(c);
        }
        <w->template</w-> &lt;<w->type</w-> <t->t</t->, <w->type</w-> <t->u</t->&gt; <t->NoArg</t-> <f->get_middle_arg</f->(<t->t</t-> <p->l</p->, <t->u</t-> <p->r</p->) {
            <w->return</w-> { };
        }
        <w->template</w-> &lt;<w->type</w-> <t->t</t->&gt; <t->t</t-> <f->get_middle_arg</f->(<t->t</t-> <p->c</p->) {
            <w->return</w-> c;
        }


        <t->void</t-> <f->main</f->(){
            <t->auto</t-> a = <f->get_middle_arg</f->(<k->5</k->, <k->false</k->, <k->1</k->, <k->17</k->, <k->true</k->);  <c->// a has type ulong and value 1</c->
            <t->auto</t-> b = <f->get_middle_arg</f->(<k->1</k->, <k->2</k->);                   <c->// b has type NoArg</c->
        }
    </div>
</example->
<p>
    Parameter packs can be used in conjunction with the <a href="#abbreviated-template-syntax">abbreviated template syntax</a>.<br>
    This is explained in <a href="#abbreviated-template-syntax">Abbreviated template syntax</a>.
</p>
<example- class="full-example">
    <label->Example 2 - Summation function</label->
    <div>
        <t->auto</t-> <f->sum</f->(?<t->t</t-> <p->a</p->, ?<t->u</t->... <p->vals</p->...) {
            <w->return</w-> a <f->+</f-> <f->sum</f->(vals);
        }
        <t->auto</t-> <f->sum</f->(?<t->t</t-> <p->a</p->, ?<t->u</t-> <p->b</p->) {
            <w->return</w-> a <f->+</f-> b;
        }


        <t->void</t-> <f->main</f->(){
            <t->int</t-> n = <k->5</k->;
            <t->float</t-> r = <f->sum</f->(<k->5.9</k->, <k->n</k->, <k->1</k->, <k->true</k->);  <c->// r has value 12.9</c->
        }
    </div>
</example->


<h1 id="operators"></h1>


<h1 id="operator-declarations"></h1>
<p>
    <b>Operators</b> are a type of <b><a href="#declarations.routines">routine</a></b> that doesn't require parentheses to be <a href="#routine-calls">called</a> and can use <b>multiple <a href="#identifiers">identifiers</a></b>.<br>
    Each <a href="#identifiers">identifier</a> can be prefix, infix or postfix, depending on where it is declared in the operator signature.<br>
    Operators can take any number of <a href="#declarations.routine-parameters">parameters</a>, but they cannot be 0 and must be separated by exactly 1 <a href="#identifiers">identifier</a>.
</p>
<p>
    Operator <a href="#identifiers">identifiers</a> can be alphanumeric or symbolic.<br>
    Declaring consecutive <a href="#idnetifiers">identifiers</a> is not allowed.<br>
    Operator precedence is explained in <a href="#declarations.operator-precedence">Operator precedence</a>.
</p>
<syntax->
    <label- id="copy.syntax--declaration-operator">Declaration syntax</label->
    <label- id="copy.syntax--declaration-operator-signature">Operator signature</label->
    <label- id="copy.syntax--declaration-routine-body">Routine body</label->
    <label- id="copy.syntax--declaration-specialization-constraint">Specialization constraint</label->
</syntax->
<example- class="full-example">
    <label->Example 1 - Promotion operator</label->
    <div>
        <t->int</t-> <f->+</f-> (<t->int</t-> <p->n</p->) <w->priority</w->(<k->3</k->) {
            <w->return</w-> n;
        }

        <t->void</t-> <f->main</f->(){
            <t->int</t-> r = <f->+</f->2;
        }
    </div>
</example->
<example- class="full-example">
    <label->Example 2 - Python-like ternary operator</label->
    <div>
        <t->int</t-> (<t->int</t-> <p->a</p->) <f->if_</f-> (<t->bool</t-> <p->condition</p->) <f->else_</f-> (<t->int</t-> <p->b</p->) <w->priority</w->(<k->15</k->) {
            <w->if</w->(condition) <w->return</w-> a;
            <w->else</w-> <w->return</w-> b;
        }

        <t->void</t-> <f->main</f->(<t->bool</t-> <p->c</p->){
            <t->int</t-> r = 5 <f->if_</f-> c <f->else_</f-> 6;
        }
    </div>
</example->


<h1 id="operator-precedence"></h1>
<p>
    In <b>absence</b> of <b>parentheses</b>, the order in which <b><a href="#declarations.operators">operators</a></b> in the <b>same <a href="#expressions">expression</a></b> are <b><a href="#operator-calls">called</a></b> depends on their <b>priority</b> and <b>associativity</b>.<br>
    Priority and associativity are specified in the <a href="#declarations.operators">operator signature</a> as a <a href="#compile-time-expressions">compile time</a> <a href="#integral-types"><code><t->ulong</t-></code></a> <a href="#expressions">expression</a>
    ranging from <code><k->0</k-></code> to <code><k->15</k-></code>, followed by the <code><w->r</w-></code> or <code><w->l</w-></code> <a href="#meta-keywords">meta keyword</a>.<br>
</p>
<p>
    The value indicates the priority.<br>
    Operators declared with lower values have higher priority and are evaluated first.<br>
    Left-associative operators are always evaluated before right-associative operators with the same priority.
</p>
<p>
    The <code><w->r</w-></code> and <code><w->l</w-></code> <a href="#meta-keywords">meta keywords</a> indicate right and left associativity.<br>
    Associativity defines the order in which operators with the same priority and associativity are evaluated.<br>
    Right-associative operators are evaluated starting from the right, whilst left-associative operators are evaluated starting from the left.<br>
</p>
<example- class="full-example">
    <label->Example 1 - Priority</label->
    <div>
        <t->int</t-> (<t->int</t-> <p->a</p->) <f->o</f-> (<t->int</t-> <p->b</p->) <w->priority</w->(<k->4</k-> <w->l</w->) {
            <w->return</w-> a <f->+</f-> b <f->*</f-> b;
        }

        <t->int</t-> (<t->int</t-> <p->a</p->) <f->p</f-> (<t->int</t-> <p->b</p->) <w->priority</w->(<k->4</k-> <w->r</w->) {
            <w->return</w-> a <f->*</f-> 2 <f->+</f-> b;
        }

        <t->int</t-> (<t->int</t-> <p->a</p->) <f->q</f-> (<t->int</t-> <p->b</p->) <w->priority</w->(<k->5</k-> <w->r</w->) {
            <w->return</w-> b <f->-</f-> a;
        }

        <t->void</t-> <f->main</f->(<t->int</t-> <p->a</p->, <t->int</t-> <p->b</p->, <t->int</t-> <p->c</p->){
            <c->// Evaluated as ((a o (b p c)) q a)</c->
            <t->int</t-> r = a <f->o</f-> b <f->p</f-> c <f->q</f-> a;
        }
    </div>
</example->
<example- class="full-example">
    <label->Example 2 - Associativity</label->
    <div>
        <t->int</t-> (<t->int</t-> <p->a</p->) <f->o</f-> (<t->int</t-> <p->b</p->) <w->priority</w->(<k->4</k-> <w->l</w->) {
            <w->return</w-> a <f->+</f-> b <f->*</f-> b;
        }

        <t->int</t-> (<t->int</t-> <p->a</p->) <f->p</f-> (<t->int</t-> <p->b</p->) <w->priority</w->(<k->4</k-> <w->l</w->) {
            <w->return</w-> a <f->*</f-> 2 <f->+</f-> b;
        }

        <t->void</t-> <f->main</f->(<t->int</t-> <p->a</p->, <t->int</t-> <p->b</p->, <t->int</t-> <p->c</p->){
            <c->// Evaluated as ((a o b) p c)</c->
            <t->int</t-> r = a <f->o</f-> b <f->p</f-> c
        }
    </div>
</example->


<h1 id="reference-parameters"></h1>
<p>
    <b>Reference parameters</b> use the <b>address of the argument</b> as <b>initializer value</b> instead of the argument itself.<br>
    They are declared by preceding the name of the parameter with the <code>&</code> <a href="#meta-keywords">meta keyword</a> and are only available for operators.<br>
</p>
<p>
    Reference parameters can only be of <a href="#pointer-types">pointer type</a> and the passed arguments must be <a href="#left-and-right-values">l-values</a>.<br>
    Inside the <a href="#routines">routine</a>, reference parameters act exactly as normal parameters.
</p>
<example- class="full-example">
    <label->Example</label->
    <div>
        <t->void</t-> <f->halve</f->(<t->float</t->@ &<p->n</p->) <w->priority</w->(<k->1</k-> <w->l</w->) {
            @n <f->/=</f-> <k->2</k->;
        }

        <t->void</t-> <f->main</f->(){
            <t->float</t-> n = <k->8</k->;    <c->// n has value 8</c->
            <f->halve</f-> <k->n</k->;         <c->// n has value 4</c->
            <c->//halve 8;</c->       <ce->// Error, 8 is not an l-value</ce->
        }
    </div>
</example->


<h1 id="routine-specialization"></h1>
<p style="margin-bottom: 0;">
    <b>Routine specialization</b> allows routines to <b>act differently</b> based on the numer of arguments <b>in each routine call</b>, their types and user-defined constraints.<br>
    This is achieved by declaring the same routine multiple times. Each declaration must be <b>unique</b> and can differ by:
</p>
<ul><ul>
    <li>Number of parameters (and position of the parameters for operators)</li>
    <li>Types of the parameters</li>
    <li>Suitability constraints</li>
</ul></ul>
<br>
<p style="margin-bottom: 0;">
    Declarations that have less than <i>#a</i> parameters or more than <i>#a</i> parameters without a default value (and for operators, those whose position of the parameters don't match with the position of the arguments in the operator call) are discarded.<br>
    <span class="small hidden">[with <i>#a</i> = number of passed arguments]</span><br>
    <br>
    The remaining declarations are organized in categories and the best one is chosen from one of these.<br>
    The categories are checked one at a time, in the order a, b, c. If no declaration is found, the next category is checked.<br>
    If zero or more than one declaration are found withing the same category, a semantic error is generated.
</p>
<ol style="list-style: lower-alpha;">
    <li>Declarations that can take all the parameters without performing implicit conversions.</li>
    <li>Declarations that can take all the parameters by performing one or more constness-only implicit conversions.</li>
    <li>Declarations that can take all the parameters by performing one or more implicit conversions of any kind.</li>
</ol>
<br>
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example 1</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;

                <t->void</t-> <f->f</f->(<t->int</t-> <t->const@</t-> <p->p</p->){
                    io.<f->print</f->(<s->"a"</s->);
                }
                <t->void</t-> <f->f</f->(<t->int@</t-> <p->p</p->){
                    io.<f->print</f->(<s->"b"</s->);
                }
                <t->void</t-> <f->f</f->(<t->ulong</t-> <p->p</p->){
                    io.<f->print</f->(<s->"c"</s->);
                }


                <t->void</t-> <f->main</f->(){
                    <t->const</t-> <t->int</t-> n1;
                    <t->int</t->       n2;
                    <t->float</t->     n3;

                    <f->f</f->(@n1);   <c->// No implicit conversions</c->
                    <f->f</f->(@n2);   <c->// 1 constness-only implicit conversion</c->
                    <f->f</f->(@n3);   <c->// 1 implicit conversion</c->
                    <f->f</f->(<k->0.5</k->);   <c->// No implicit conversions</c->
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Output</label->
            <div>
                abcc<cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->
<p style="margin-bottom: 0;">
    Declarations with parameter packs and/or templates undergo an additional instantiation phase before the best declaration is chosen, in which these features are replaced with standard types and parameters.
</p>
<ol style="list-style: decimal;">
    <li>
        Each declaration that uses a function parameter pack and has <i>#a</i> or less parameters has its parameter pack replaced with the exact number of parameters of the correct type in order to bring the total to exactly <i>#a</i>.<br>
        <span class="small hidden">[with <i>#a</i> = number of passed arguments]</span>.<br>
        This phase is skipped if the template arguments are specified explicitly.
    </li>
    <li>
        Generated declarations whose number of arguments and argument types are identical to the ones in declarations that don't use function parameter packs are discarded.
    </li>
    <li>
        Each declaration that uses a template is instantiated.<br>
        This phase is skipped if the template arguments are specified explicitly.
    </li>
    <li>
        Generated declarations whose number of arguments and argument types are identical to the ones in declarations that don't use templates are discarded
    </li>
    <li>
        Any declaration whose suitability constraint is not satisfied is discarded
    </li>
</ol>
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example 2</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;

                <t->void</t-> <f->f</f->(?<t->t</t->... <p->args</p->...){
                    io.<f->print</f->(<s->"More than one argument provided\n"</s->);
                }
                <t->void</t-> <f->f</f->(?<t->t</t-> <p->arg</p->) {
                    io.<f->print</f->(<s->"The first argument is not a double\n"</s->);
                }
                <t->void</t-> <f->f</f->(<t->double</t-> <p->arg</p->) {
                    io.<f->print</f->(<s->"The first argument is a double\n"</s->);
                }


                <t->void</t-> <f->main</f->(){
                    <f->f</f->(<k->1</k->);
                    <f->f</f->(<k->1.0</k->);
                    <f->f</f->(<k->1.0</k->, <k->2</k->);
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Output</label->
            <div>
                The first argument is not a double
                The first argument is a double
                More than one argument provided
                <cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->


<h1 id="templates"></h1>
<p>
    Templates allow structs and routines to generate different declarations based on the explicit template arguments or the passed routine argunents.<br>
    They are compatible with specialization constraints, function parameter packs, default values and reference parameters.
</p>
<p>
    Generated declarations are called template instances, and the act of generating them is called template instantiation.<br>
    A template is instantiated every time the template symbol is referenced in the code.<br>

</p>


<h1 id="template-declarations"></h1>
<p>
    Struct and routines that use templates are introduced by the <code><w->template</w-></code> meta keyword,
    followed by the <elm-><code>&lt;</code><code>&gt;</code></elm-> meta keywords, in which the template parameters are specified.<br>
    The rest of the declaration is identical to standard routines or structs.<br>
    Notice that //TODO (maybe?) in specialization constraints, the value of template parameters is decided after the instantiation, but everything else is done from the position of the parameter declaration
</p>
<syntax->
    <label- id="copy.syntax--declaration-template-struct">Template struct declaration</label->
    <label- id="copy.syntax--declaration-template-function">Template function declaration</label->
    <label- id="copy.syntax--declaration-template-operator">Template operator declaration</label->
    <label- id="copy.syntax--declaration-template-signature">Template signature</label->
</syntax->
<example- class="full-example">
    <label->Example</label->
    <div>
        <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <t->t</t-> <f->add</f->(<t->t</t-> <p->a</p->, <t->t</t-> <p->b</p->){
            <w->return</w-> a <f->+</f-> b;
        }
    </div>
</example->


<h1 id="template-parameters"></h1>
<p>
    Template parameters can either be values of enum or integral type or type paths, and can be used as such by each declaration after it has been instantiated.<br>
    Value parameters are declared using their respective type, whilst type parameters have to be declared using the <code><w->type</w-></code> meta keyword.
</p>
<p>
    By default, each template parameter must be specified explicitly when referencing a template symbol.<br>
    If the declaration of a routine parameter uses a type template parameter as type, the <code>!</code> meta keyword can be placed after the type to allow it to be deduced from the passed argument.<br>
    This also applies to function parameter packs that use a type template parameter pack as type, in which case each type of the type template parameter pack is deduced from the respective argument in the routine parameter pack.<br>
    If one or more template arguments cannot be deduced, then all the arguments must be specified explicitly.
</p>
<p>
    Type template arguments deduced from multiple routine arguments are explained in <a href="multi-argument-type-deduction">Multi argument type deduction</a><br>
    Type deduction is not performed when the template arguments are specified.
</p>
<syntax->
    <label- id="copy.syntax--declaration-template-parameter">Template parameter declaration</label->
</syntax->
<example- class="full-example">
    <label->Example 1</label->
    <div>
        <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <t->t</t-> <f->twice</f->(<t->t</t->! <p->n</p->){
            <w->return</w-> n <f->*</f-> <k->2</k->;
        }
        <w->template</w->&lt;<t->int</t-> <p->n</p->&gt; <t->int</t-> <f->return_n</f->(){
            <w->return</w-> <k->n</k->;
        }

        <t->void</t-> <f->main</f->(){
            <t->auto</t-> var1 = <f->twice</f->(<k->8</k->);         <c->// Ok, type t deduced as ulong</c->
            <t->auto</t-> var2 = <f->twice</f->&lt;<t->float</t->&gt;(<k->8</k->);  <c->// Ok, type t specified as float, 8 is converted to from ulong to float</c->
            <t->auto</t-> var3 = <f->return_n</f->&lt;<k->5</k->&gt;();    <c->// Ok, value n specified as 5</c->
        }
    </div>
    <label->Example 2</label->
    <div>
        <w->template</w->&lt;<t->int</t-> <p->n</p->, <w->type</w-> <t->t</t->&gt; <t->t</t-> <f->mult_by_n</f->(<t->t</t->! <p->arg</p->){
            <w->return</w-> arg <f->*</f-> <k->n</k->;
        }

        <t->void</t-> <f->main</f->(){
            <c->//auto var3 = mult_by_n&lt;5&gt;(2);</c->       <ce->// Error, n cannot be deduced. All arguments must be specified</ce->
            <t->auto</t-> var3 = <f->mult_by_n</f->&lt;<k->5</k->, <t->ulong</t->&gt;(<k->2</k->);  <c->// Ok, value n specified as 5, type t specified as ulong</c->
        }
    </div>
</example->


<h1 id="template-parameter-packs"></h1>
<p>
    <b>Template parameter packs</b> allow <b>templates</b> to take an <b>arbitrary number</b> of <b>arguments</b>.<br>
    They are decalred in the same way as <a href="#template-parameters">template parameters</a>, but their name is followed by the <code>...</code> <a href="#meta-keywords">meta keyword</a>.<br>
</p>
<p>
    Template parameter packs take zero or more arguments.
    Type template parameter packs can be used as arguments of type template parameters or used in conjunction with a <a href="function-parameter-packs">function parameter packs</a> to allow each of its elements to accept a different type.<br>
    Value template parameter packs can be used as arguments of routine parameters or value template parameters.
</p>
<p>
    Each template declaration can only use a single template parameter pack.<br>
</p>
<syntax->
    <label- id="copy.syntax--declaration-template-parameter-pack">Template parameter pack declaration</label->
</syntax->
<example- class="full-example">
    <label->Example</label->
    <div>
        <w->template</w->&lt;<w->type</w-> <t->t</t->, <w->type</w-> <t->u</t->...&gt; <t->str</t-> <f->to_str</f->(<t->t</t->! <p->arg</p->, <t->u</t->! <p->args</p->...) {
            <w->return</w-> <t->str</t->(arg) + <f->to_str</f->(args);
        }
        <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <t->str</t-> <f->to_str</f->(<t->t</t->! <p->arg</p->) {
            <w->return</w-> <t->str</t->(a);
        }

        <t->void</t-> <f->main</f->(){
            <t->int</t-> p = <k->101</k->;
            io.<f->print</f->(<f->to_str</f->(<s->"Programming "</s->, <k->p</k->, <s->" UwU"</s->));
        }
    </div>
</example->


<h1 id="abbreviated-template-syntax"></h1>
<p>
    The abbreviated template syntax allows template symbols to be declared without specifying the template signature explicitly.<br>
    In these cases, the <code>?</code> meta keyword is used to identify type template parameters, and type template parameter packs are identified through the <code>...</code> meta keyword.
</p>
<p>
    The order of template parameters and template parameter packs is the same in which their first occurrence in the routine or struct declaration is found and its still possible to specify the arguments explicitly when referencing the symbol.<br>
    Value template parameters are not allowed, as well as value template parameter packs.
</p>
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example</label->
            <div>
                <t->t</t-> <f->add</f->(<t->u</t->?! <p->a</p->, <t->t</t->?! <p->b</p->) {
                    <w->return</w-> a <f->+</f-> b;
                }

                <t->void</t-> <f->main</f->(){
                    <f->add</f->(<k->5</k->, <k->0.5</k->)                <c->// Returns a double</c->
                    <f->add</f->&lt;<t->ulong</t->, <t->double</t->&gt;(<k->5</k->, <k->0.5</k->) <c->// Returns a ulong, both routine arguments are implicitly converted</c->
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Equivalent code</label->
            <div>
                <w->template</w->&lt;<w->type</w-> <t->t</t->, <w->type</w-> <t->u</t->&gt; <t->t</t-> <f->add</f->(<t->u</t->! <p->a</p->, <t->t</t->! <p->b</p->) {
                    <w->return</w-> a <f->+</f-> b;
                }

                <t->void</t-> <f->main</f->(){
                    <f->add</f->(<k->5</k->, <k->0.5</k->)
                    <f->add</f->&lt;<t->ulong</t->, <t->double</t->&gt;(<k->5</k->, <k->0.5</k->)
                }
            </div>
        </example->
    </split-example-container-right->
</split-example-container->
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example</label->
            <div>
                <t->t</t-> <f->mul</f->(<t->t</t->?! <p->arg</p->, <t->u</t->...! <p->args</p->...) {
                    <w->return</w-> arg <f->*</f-> <f->mul</f->&lt;<t->u</t->...&gt;(args); //TODO this is ambiguous
                }
                <t->t</t-> <f->mul</f->(<t->t</t->?! <p->arg</p->) {
                    <w->return</w-> arg;
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Equivalent code</label->
            <div>
                <w->template</w->&lt;<w->type</w-> <t->t</t->, <w->type</w-> <w->u</w->&gt; <t->t</t-> <f->mul</f->(<t->t</t->! <p->arg</p->, <t->u</t->! <p->args</p->...) {
                    <w->return</w-> arg <f->*</f-> <f->mul</f->&lt;<t->u</t->&gt;(args);
                }
                <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <t->t</t-> <f->mul</f->(<t->t</t->! <p->arg</p->) {
                    <w->return</w-> arg;
                }
            </div>
        </example->
    </split-example-container-right->
</split-example-container->


<h1 id="multi-argument-type-deduction"></h1>
<p>
    When a type template parameter has to be deduced from multiple routine arguments of different types,
    the primitive type with rank the highest rank between the types of all the significant arguments is selected in order to avoid data losses.<br>
    Significant arguments with lower rank are converted to the selected rank through implicit conversions.
</p>
<div class="table-container"><table>
    <tr>
        <th>Type</th>
        <th>Rank</th>
    </tr>
    <tr>
        <td class="center"><code><t->bool</t-></code>, <even-elm-><code><t->bool</t-></code> <code><w->enum</w-></code></even-elm-></td>
        <td class="center">1</td>
    </tr>
    <tr>
        <td class="center"><code><t->int</t-></code>, <even-elm-><code><t->int</t-></code> <code><w->enum</w-></code></even-elm-></td>
        <td class="center">2</td>
    </tr>
    <tr>
        <td class="center"><code><t->uint</t-></code>, <even-elm-><code><t->uint</t-></code> <code><w->enum</w-></code></even-elm-></td>
        <td class="center">3</td>
    </tr>
    <tr>
        <td class="center"><code><t->long</t-></code>, <even-elm-><code><t->long</t-></code> <code><w->enum</w-></code></even-elm-></td>
        <td class="center">4</td>
    </tr>
    <tr>
        <td class="center"><code><t->ulong</t-></code>, <even-elm-><code><t->ulong</t-></code> <code><w->enum</w-></code></even-elm-></td>
        <td class="center">5</td>
    </tr>
    <tr>
        <td class="center"><code><t->float</t-></code>, <even-elm-><code><t->float</t-></code> <code><w->enum</w-></code></even-elm-></td>
        <td class="center">6</td>
    </tr>
    <tr>
        <td class="center"><code><t->double</t-></code>, <even-elm-><code><t->double</t-></code> <code><w->enum</w-></code></even-elm-></td>
        <td class="center">7</td>
    </tr>
</table></div>
<example- class="full-example">
    <label->Example 1</label->
    <div>
        <t->t</t-> <f->add</f->(<t->t</t->?! <p->a</p->, <t->t</t->?! <p->b</p->) {
            <w->return</w-> a <f->+</f-> b;
        }

        <t->void</t-> <f->main</f->(){
            <f->add</f->( <k->1</k->, <k->0.2</k->);  <c->// Ok, t deduced as double</c->
            <f->add</f->(<k->-5</k->, <k->5</k->  );  <c->// Ok, t deduced as ulong</c->
        }
    </div>
</example->
<split-example-container->
    <split-example-container-left->
        <example- class="full-example">
            <label->Example 2</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;

                <t->void</t-> <f->print_selected_type</f->(<t->t</t->?! <p->args</p->...) {
                    io.<f->print</f->(<t->t</t-> <f->+</f-> <s->"\n"</s->);
                }

                <t->void</t-> <f->main</f->(){
                    <f->print_selected_type</f->(<k->5</k->, <t->float</t->(<k->0.5</k->), <k->-99</k->);
                    <f->print_selected_type</f->(<k->-1</k->, <k->+1</k->);
                    <f->print_selected_type</f->(<w->enum</w->:<t->int</t->{ <k->a</k->, <k->b</k-> }.<k->b</k->, <w->enum</w->:<t->bool</t->{ <k->a</k-> = <k->true</k->, <k->b</k-> = <k->false</k-> }.<k->a</k->);
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- class="full-example">
            <label->Output</label->
            <div>
                float
                ulong
                int
                <cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->


<h1 id="statements"></h1>
<p>
    <b>Statements</b> are the <b>instructions</b> that are <b>executed during runtime</b>.<br>
    They determine the behaviour of the shader, its execution time and <a href="#compiler-optimizations">compiler optimizations</a>.<br>
    The <code>;</code> <a href="#syntactic-elements">token</a> defines the end of a statement.
</p>
<p>
    A statement can be an expression or a flow control <a href="#keywords">keyword</a>.<br>
    Any sequence of <a href="#semantic-elements">semantic elements</a> entirely composed of <a href="#left-and-right-values">values</a> and <a href="#function-calls">function calls</a> is considered an expression.
</p>
<p>
    Statements can only be used within <a href="#functions">functions</a> and <a href="#unnamed-scopes">unnames scopes</a>.
</p>


<h1 id="selection"></h1>


<h1 id="if-statement"></h1>


<h1 id="match-statement"></h1>


<h1 id="iteration"></h1>


<h1 id="for-loops"></h1>


<h1 id="while-loops"></h1>


<h1 id="continue-and-break-statements"></h1>
<p>
    //TODO break 2; continue 40;
</p>


<h1 id="once-statement"></h1>


<h1 id="then-statement"></h1>


<h1 id="non-local-flow-control"></h1>


<h1 id="return-statement"></h1>
<p>
    The <b><code><w->return</w-></code></b> statement skips all remaining statements in the function and <b>returns</b> the <b>code execution</b> to the <b>caller function</b>.<br>
    Multiple return statements are allowed, but their value must be implicitly convertible to the type of the function.
</p>
<p>
    All execution paths of non-<code><t->void</t-></code> functions must return a value.<br>
    The return value can then be used by the caller function or be ignored.<br>
    Calls to <code><t->void</t-></code> functions cannot be used in expressions.
</p>
<p>
    There is no default return value.
</p>
<syntax->
    <label- id="copy.syntax--statement-return">Syntax</label->
</syntax-><p>
    //TODO EXAMPLE
</p>


<h1 id="defer-statement"></h1>


<h1 id="statements.misc"></h1>


<h1 id="else-statement"></h1>


<h1 id="expression-statement"></h1>


<h1 id="empty-statement"></h1>


<h1 id="unnamed-scope"></h1>


<h1 id="misc"></h1>


<h1 id="declarations.namespaces"></h1>
<p>
    <b>Namespaces</b> are used to create <b>named <a href="#scopes">scopes</a></b> to group <a href="#name-resolution">symbols</a>.<br>
    The <a href="#name-resolution">symbol</a> categories they can contain are the same as their parent <a href="#scopes">scope</a>.<br>
    They cannot contain <a href="#statements">statements</a>.
</p>
<p>
    Namespaces don't affect compiler <a href="#optimizations">optimizations</a> or the <a href="#runtime-performance">runtime performance</a> of the program and can be declared in any <a href="#scopes">scope</a>.<br>
    Unnamed namespaces are allowed. Empty namespaces are also allowed.
</p>
<syntax->
    <label- id="copy.syntax--declaration-namespace">Declaration syntax</label->
</syntax->

<example- class="full-example">
    <label->Example</label->
    <div>
        <w->namespace</w-> a {
            <t->int</t-> n = <k->4</k->;
        }
        <w->namespace</w-> {
            <t->int</t-> n = <k->4</k->;
        }

        <t->int</t-> n2 = a.<k->n</k->;
    </div>
</example->


<h1 id="symbol-aliases"></h1>
<p>
    <b>Symbol aliases</b> are <b>alternative names</b> for symbols.
    Symbols can be aliased using the <code><w->alias</w-></code> keyword.<br>
    Any declared symbol can be aliased, including modules, generated functions and other aliases.
</p>
<p>
    An alias is not simply replaced like a <a href="#macros">macro</a> but it identifies the symbol itself in a unique way.<br>
    Once an alias is declared, the alias and the symbol it aliases can be used interchangeably.
</p>
<p>
    Variables can be aliased before their declaration, but the alias can only be used after the declaration of the variable.
</p>

<syntax->
    <label- id="copy.syntax--declaration-symbol-alias">Syntax</label->
</syntax->

<example- class="full-example">
    <label->Example 1</label->
    <div>
        <w->namespace</w-> n {
            <t->void</t-> <f->f</f->(){}
        }
        <w->alias</w-> n2 = n;        <c->// Ok, n2 = module.n</c->
        <w->alias</w-> f2 = n2.<f->f</f->;    <c->// Ok, f2 = (module.n2).f = module.n.f</c->
        <w->alias</w-> f3 = n2.<f->f2</f->;   <c->// Ok, f2 = (module.n2).(module.f2) = module.n.f</c->

        <t->void</t-> <f->main</f->(){
            <f->f2</f->();            <c->// Ok, calls n.f()</c->
            <f->f3</f->();            <c->// Ok, calls n.f()</c->
        }
    </div>
</example->


<h1 id="inline-declarations"></h1>
<p>
</p>


<h1 id="inline-glsl"></h1>



<h1 id="reflection"></h1>


<h1 id="syntactic-sugar"></h1>
                    <h1 id="compilation"></h1>
                    <h1 id="modules"></h1>
                    <h1 id="compilation-phases-and-error-types"></h1>
                    <h1 id="global-initialization-order"></h1>
                    <h1 id="runtime-performance"></h1>
                    <h1 id="branching-performance"></h1>
                    <h1 id="value-precomputation"></h1>


<h1 id="core-module"></h1>
<p>
    //TODO
</p>


<h1 id="core.operators"></h1>
<p style="margin-bottom: 20px;">
    The language defines a total of 44 operators.<br>
</p>
<ul>
    <li>Common operators<ul>
        <li>Arithmetic operators</li>
        <li>Bitwise operators</li>
        <li>Logical operators</li>
        <li>Relational operators</li>
    </ul></li>
    <li>Assignment operators</li>
    <li>Special operators</li>
</ul>


<h1 id="common-operators"></h1>
<p>
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO //TODO this is mod

    //TODO the mod function returns the same sign of /
    //TODO add other types

    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
</p>
<p>
    <b>Common operators</b> include operators to perform <b>comparisons</b>, <b>arithmetic operations</b>, <b>bit manipulation</b> and <b>logical operations</b>.<br>
</p>
<div class="table-container"><table>
    <thead><tr>
        <th class="center">Priority</th>
        <th class="center">Operator</th>
        <th class="center">Function signature</th>
        <th class="left">Name</th>
        <th class="left">Category</th>
    </tr></thead>
    <tbody>
            <tr>
                <td class="center" rowspan="2">2</td>
                <td class="center"><code>++</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> &<p->n</p->) <f->++</f-></code></td>
                <td class="left">Postfix increment</td>
                <td class="left" rowspan="6">Arithmetic</td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>--</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> &<p->n</p->) <f->--</f-></code></td>
                <td class="left">Postfix decrement</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <td class="center" rowspan="6">3</td>
                <td class="center"><code>++</code></td>
                <td class="center nowrap"><code><t->T</t-> <f->++</f-> (?<t->T</t-> &<p->n</p->)</code></td>
                <td class="left">Prefix increment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>--</code></td>
                <td class="center nowrap"><code><t->T</t-> <f->--</f-> (?<t->T</t-> &<p->n</p->)</code></td>
                <td class="left">Prefix decrement</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>+</code></td>
                <td class="center nowrap"><code><t->T</t-> <f->+</f-> (?<t->T</t-> <p->n</p->)</code></td>
                <td class="left">Promotion</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>-</code></td>
                <td class="center nowrap"><code><t->T</t-> <f->-</f-> (?<t->T</t-> <p->n</p->)</code></td>
                <td class="left">Inversion</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>~</code></td>
                <td class="center nowrap"><code><t->T</t-> <f->~</f-> (?<t->T</t-> <p->n</p->)</code></td>
                <td class="left">Bitwise NOT</td>
                <td class="left">Bitwise</td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>!</code></td>
                <td class="center nowrap"><code><t->bool</t-> <f->!</f-> (<t->bool</t-> <p->n</p->)</code></td>
                <td class="left">Logical NOT</td>
                <td class="left">Logical</td>
            </tr>
            <tr>
                <td class="center" rowspan="3">4</td>
                <td class="center"><code>*</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->*</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Multiplication</td>
                <td class="left" rowspan="5">Arithmetic</td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>/</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->/</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Division</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>%</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->%</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Modulus</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <td class="center" rowspan="2">5</td>
                <td class="center"><code>+</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->+</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Addition</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>-</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->-</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Subtraction</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <td class="center" rowspan="2">6</td>
                <td class="center"><code>&lt;&lt;</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->&lt;&lt;</f-> (<t->uint</t-> <p->b</p->)</code></td>
                <td class="left">Left bit shift</td>
                <td class="left" rowspan="2">Bitwise</td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&gt;&gt;</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->&gt;&gt;</f-> (<t->uint</t-> <p->b</p->)</code></td>
                <td class="left">Right bit shift</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <td class="center" rowspan="4">7</td>
                <td class="center"><code>&lt;</code></td>
                <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <p->a</p->) <f->&lt;</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Less than</td>
                <td class="left" rowspan="8">Relational</td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&lt;=</code></td>
                <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <p->a</p->) <f->&lt;=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Less or equal than</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&gt;</code></td>
                <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <p->a</p->) <f->&gt;</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Greater than</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&gt;=</code></td>
                <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <p->a</p->) <f->&gt;=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Greater or equal than</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <td class="center" rowspan="4">8</td>
                <td class="center"><code>==</code></td>
                <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <p->a</p->) <f->==</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Equality</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>!=</code></td>
                <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <p->a</p->) <f->!=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Inequality</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>=:</code></td>
                <td class="center nowrap"><code><t->bool</t-> (<t->baseof</t->(<t->T</t->) <p->a</p->) <f->=:</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Existence</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>!:</code></td>
                <td class="center nowrap"><code><t->bool</t-> (<t->baseof</t->(<t->T</t->) <p->a</p->) <f->!:</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Inexistence</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <td class="center">9</td>
                <td class="center"><code>&</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->&</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Bitwise AND</td>
                <td class="left" rowspan="3">Bitwise</td>
            </tr>
            <tr>
                <td class="center">10</td>
                <td class="center"><code>^</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->^</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Bitwise XOR</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <td class="center">11</td>
                <td class="center"><code>|</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->|</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Bitwise OR</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <td class="center">12</td>
                <td class="center"><code>&&</code></td>
                <td class="center nowrap"><code><t->bool</t-> (<t->bool</t-> <p->a</p->) <f->&&</f-> (<t->bool</t-> <p->b</p->)</code></td>
                <td class="left">Logical AND</td>
                <td class="left" rowspan="3">Logical</td>
            </tr>
            <tr>
                <td class="center">13</td>
                <td class="center"><code>^^</code></td>
                <td class="center nowrap"><code><t->bool</t-> (<t->bool</t-> <p->a</p->) <f->^^</f-> (<t->bool</t-> <p->b</p->)</code></td>
                <td class="left">Logical XOR</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <td class="center">14</td>
                <td class="center"><code>||</code></td>
                <td class="center nowrap"><code><t->bool</t-> (<t->bool</t-> <p->a</p->) <f->||</f-> (<t->bool</t-> <p->b</p->)</code></td>
                <td class="left">Logical OR</td>
                <fake-td></fake-td>
            </tr>
    </tbody>
</table></div>

<h1 id="arithmetic-operators"></h1>
<p>
    Arithmetic operators can be used on any <a href="#primitive-types">primitive type</a> or <a href="#enums">enum</a>.
</p>
<p>
    <code>++</code>, <code>--</code>.<br>
    Increment and decrement operators add and subtract <code><k->1</k-></code> to the value of the operand.<br>
    Prefix operators return the value of the operand after the operation, postfix operators return the value of the operand before the operation.<br>
    Incrementing or decrementing a <code><t->bool</t-></code> has the same effect of converting its value to <code><t->int</t-></code>, performing the operation and converting it back to <code><t->bool</t-></code>.<br>
    Increment and decrement are the only common operators which modify the original value.
</p>
<p>
    <code>-</code>, <code>+</code>.<br>
    The promotion operator has no effect and only exists for completeness.<br>
    The inversion operator inverts the sign of the operand.<br>
    Inverting a <code><t->bool</t-></code> has no effect.
</p>
<p>
    <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>.<br>
    Addition, subtraction, multiplication, division and modulus operators perform their corresponding operations between two operators.<br>
    Using these operators with <code><t->bool</t-></code> values has the same effect of converting their value to <code><t->int</t-></code>, performing the operation and converting them back to <code><t->bool</t-></code>.<br>
    <br>
    Differently from GLSL and C++, the result of the modulus operator has the same sign of the result of the division.<br>
    Using <code><k->0</k-></code> as second operand of in division or modulus operator with <a href="#primitive-types">integral types</a> has <b>undefined</b> result.
</p>

<h1 id="logical-operators"></h1>
<p>
    Logical operators can only be used on <code><t->bool</t-></code> types.
</p>
<p>
    <code>!</code>, <code>&&</code>, <code>||</code>, <code>^^</code>.<br>
    NOT returns the inverse of the value.<br>
    AND, OR and XOR perform their corresponding operations between two values.<br>
    <div style="min-width: 100%; display: flex;">
        <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-right: calc(var(--def-margin) / 2); display: inline-block;">
            <div class="table-container"><table>
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>A || B</th>
                </tr>
                <tr>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
            </table></div>
            <div class="table-container"><table>
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>A && B</th>
                </tr>
                <tr>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
            </table></div>
        </div>
        <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-left: calc(var(--def-margin) / 2); display: inline-block;">
            <div class="table-container"><table>
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>A ^^ B</th>
                </tr>
                <tr>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
            </table></div>
            <div class="table-container"><table>
                <tr>
                    <th colspan="2">A</th>
                    <fake-td></fake-td>
                    <th>!A</th>
                </tr>
                <tr>
                    <td class="center" colspan="2"><code><k->1</k-></code></td>
                    <fake-td></fake-td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center" colspan="2"><code><k->0</k-></code></td>
                    <fake-td></fake-td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
            </table></div>
        </div>
    </div>
</p>

<h1 id="bitwise-operators"></h1>
<p>
    Bitwise operators can be used on any <a href="#primitive-types">primitive type</a> or <a href="#enums">enum</a>.
    //TODO convert floats to int without changing the bit value
    //TODO floatBitsToInt intBitsToFloat
</p>
<p>
    <code>&lt;&lt;</code>, <code>&gt;&gt;</code>.<br>
    Bit shift operators shift the bits of the value of the left operand by the value of the right operand.<br>
    The right operand is converted to <code><t->uint</t-></code>. Discarded bits are set to <code><k->0</k-></code>.<br>
    Shifting non-<code><t->bool</t-></code> types by <code><f->sizeof</f->(<t->type</t->) * <k->8</k-></code> or more causes <b>undefined behaviour</b>.<br>
    Shifting <code><t->bool</t-></code> values is equivalent to setting them to <code><k->false</k-></code>.<br>
</p>
<p>
    <code>~</code>, <code>&</code>, <code>|</code>, <code>^</code>.<br>
    The bitwise NOT performs the logical NOT operation on every bit of the operand.<br>
    Bitwise AND, OR and XOR operators are equivalent to their corresponding logical operators, but the operation is performed between each bit of the two operands.<br>
    The types of the operand must have the same size.<br>
    <b><a href="#implicit-conversions">Implicit conversions</a> don't apply</b> on these operators. The return type has the same type of the first opeand.
    //TODO this is different than c++ and  glsl
</p>

<h1 id="relational-operators"></h1>
<p>
    Relational operators can be used on any <a href="#primitive-types">primitive type</a> or <a href="#enums">enum</a>,
    with the exception of <code>==</code>, <code>!=</code>, <code>=:</code> and <code>!:</code> which can be used with any type, including <a href="#structs">structs</a> and <a href="#typename">typenames</a>.
</p>
<p>
    <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.<br>
    The equality operator returns <code><k->true</k-></code> if the operands have the same value.<br>
    The inequality operator returns <code><k->true</k-></code> if the operands have different values.<br>
    The other operators return <code><k->true</k-></code> if the first operand is less than, greater than, less or equal than or greater or equal than the second operand, respectively.
</p>
<p>
    <code>=:</code>, <code>!:</code>.<br>
    The existence operator returns <code><k->true</k-></code> if the first operand has the value of one of the elements of the second operand.<br>
    The inexistence operator returns <code><k->true</k-></code> if all the elements of the second operand are different than the value of the first operand.<br>
    The second operand must be an array with a base type that is the same as the type of the first operand or can be implicitly converted to it.
</p>
<p>
    Their return value is the same as if they were declared in the following way:
</p>
<div style="min-width: 100%; display: flex;">
    <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-right: calc(var(--def-margin) / 2); display: inline-block;">
        <example- style="margin: 0;">
            <label->Existence</label->
            <div>
                <t->bool</t-> (<t->baseof</t->(<t->t</t->) <p->a</p->) <f->=:</f-> (?<t->t</t-> <p->b</p->) { 
                    <w->for</w->(<t->uint</t-> i = <k->0</k->; i &lt; b.<f->len</f->(); ++i) {
                        <w->if</w->(a == b[i]) <w->return</w-> <k->true</k->;
                    }
                    <w->return</w-> <k->false</k->;
                }
            </div>
        </example->
    </div>
    <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-left: calc(var(--def-margin) / 2); display: inline-block;">
        <example- style="margin: 0;">
            <label->Inexistence</label->
            <div>
                <t->bool</t-> (<t->baseof</t->(<t->t</t->) <p->a</p->) <f->!:</f-> (?<t->t</t-> <p->b</p->) { 
                    <w->for</w->(<t->uint</t-> i = <k->0</k->; i &lt; b.<f->len</f->(); ++i) {
                        <w->if</w->(a == b[i]) <w->return</w-> <k->false</k->;
                    }
                    <w->return</w-> <k->true</k->;
                }
            </div>
        </example->
    </div>
</div>


<h1 id="assignment-operators"></h1>
<p>
    <b>Assignment operators</b> are used to <b>change the value</b> of <a href="#left-and-right-values">l-value</a> symbols.<br>
    The original value is set to the result of the operation.
</p>
<p>
    The direct assignment (<code>=</code>) changes the value of the first operand to the one of the second operand.<br>
    It can be used with type, including typenames and composite types. <a href="#structs">Structs</a> must be of the same exact type to be assigned.
</p>
<p>
    The result of the other assignment operators and the types they can be used with are the same as their corresponding <a href="#common-operators">common operators</a>.<br>
</p>
<div class="table-container"><table>
    <thead><tr>
        <th class="center">Priority</th>
        <th class="center">Operator</th>
        <th class="center">Function signature</th>
        <th class="left">Name</th>
        <th class="left">Category</th>
    </tr></thead>
    <tbody>
            <tr>
                <td class="center" rowspan="11">16</td>
                <td class="center"><code>=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Direct assignment</td>
                <td class="left" rowspan="11">Assignment</td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>+=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->+=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Addition assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>-=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->-=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Subtraction assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>*=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->*=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Multiplication assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>/=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->/=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Division assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>%=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->%=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Modulus assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->&=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Bitwise AND assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>^=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->^=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Bitwise XOR assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>|=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->|=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Bitwise OR assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&lt;&lt;=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->&lt;&lt;=</f-> (<t->uint</t-> <p->b</p->)</code></td>
                <td class="left">Left bit shift assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&gt;&gt;=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->&gt;&gt;=</f-> (<t->uint</t-> <p->b</p->)</code></td>
                <td class="left">Right bit shift assignment</td>
                <fake-td></fake-td>
            </tr>
    </tbody>
</table></div>


<h1 id="special-operators"></h1>
<div class="table-container"><table>
    <thead><tr>
        <th class="center">Priority</th>
        <th class="center">Operator</th>
        <th class="center">Function signature</th>
        <th class="left">Name</th>
        <th class="left">Category</th>
    </tr></thead>
    <tbody>
            <tr>
                <td class="center" >1</td>
                <td class="center"><elm-><code>(</code><code>)</code></elm-></td>
                <td class="center nowrap"><code><t->T</t-> <f->(</f-> (?<t->T</t-> <p->n</p->) <f->)</f-></code></td>
                <td class="left">Grouping</td>
                <td class="left" rowspan="10">Misc</td>
            </tr>
            <tr>
                <td class="center">15</td>
                <td class="center"><elm-><code>?</code><code>:</code></elm-></td>
                <td class="center nowrap"><code><t->T</t-> (<t->bool</t-> <p->a</p->) <f->?</f-> (?<t->T</t-> <p->b</p->) <f->:</f-> (?<t->T</t-> <p->c</p->)</code></td>
                <td class="left">Selection operator</td>
            </tr>
    </tbody>
</table></div>
<p>
    <elm-><code>(</code><code>)</code></elm->.<br>
    The grouping operator is used to change the precedence of other functions.<br>
    The expression between the <code>(</code> and <code>)</code> characters is evaluated before the rest and used as a single value.
</p>
<p>
    <elm-><code>?</code><code>:</code></elm->.<br>
    The selection operator works like an <a href="#if-statement"><code><w->if</w-></code> statement</a>.<br>
    If the first operand is <code><k->true</k-></code>, it returns the value of the second operand.<br>
    If it is <code><k->false</k-></code>, the value of the third operand is returned.
</p>


<h1 id="arithmetic-exceptions"></h1>
<p>
    Only <b>certain</b> <a href="#primitive-types">floating point</a> <b>operations</b> that generate or use <b>special double literals</b> have <b>defined</b> result.<br>
    Their result is the same as in real arithmetic operations:
</p>
<div class="table-container"><table>
    <tr>
        <th>Operation</th>
        <th>Result</th>
    </tr>
    <tr>
        <td class="center"><code>n</code> + <code><k->inf</k-></code></td>
        <td class="center" rowspan="3"><code><k->inf</k-></code></td>
    </tr>
    <tr>
        <td class="center"><code>n</code> - <code><k->inf</k-></code></td>
        <fake-td></fake-td>
    </tr>
    <tr>
        <td class="center"><code>n</code> * <code><k->inf</k-></code></td>
        <fake-td></fake-td>
    </tr>
    <tr>
        <td class="center"><code>n</code> / <code><k->inf</k-></code></td>
        <td class="center"><code><k->0</k-></code></td>
    </tr>
    <tr>
        <td class="center"><code><k->inf</k-></code> + <code>n</code></td>
        <td class="center" rowspan="4"><code><k->inf</k-></code></td>
    </tr>
    <tr>
        <td class="center"><code><k->inf</k-></code> - <code>n</code></td>
        <fake-td></fake-td>
    </tr>
    <tr>
        <td class="center"><code><k->inf</k-></code> * <code>n</code></td>
        <fake-td></fake-td>
    </tr>
    <tr>
        <td class="center"><code><k->inf</k-></code> / <code>n</code></td>
        <fake-td></fake-td>
    </tr>
    <tr>
        <td class="center"><code><k->+inf</k-></code> + <code><k->+inf</k-></code></td>
        <td class="center"><code><k->+inf</k-></code></td>
    </tr>
    <tr>
        <td class="center"><code><k->-inf</k-></code> - <code><k->-inf</k-></code></td>
        <td class="center"><code><k->-inf</k-></code></td>
    </tr>
    <tr>
        <td class="center"><code><k->inf</k-></code> * <code><k->inf</k-></code></td>
        <td class="center"><code><k->inf</k-></code></td>
    </tr>
    <tr>
        <th>Operation (special cases)</th>
        <th>Result</th>
    </tr>
    <tr>
        <td class="center"><code><k->0</k-></code> * <code><k->inf</k-></code></td>
        <td class="center"><code><b>undefined</b></code></td>
    </tr>
    <tr>
        <td class="center"><code><k->inf</k-></code> * <code><k->0</k-></code></td>
        <td class="center"><code><b>undefined</b></code></td>
    </tr>
</table></div>
<p>
    Where <code>n</code> is any non-<code><k->nan</k-></code>, non-<code><k->inf</k-></code> <a href="#primitive-types">floating point</a> value.
</p>
<p>
    All the above operations behave in the same way when performed through their corresponding <a href="#assignment-operators">assignment operators</a> (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>).<br>
    Direct assignments, relational operators and binary operators
        (<code>=</code>, <code>==</code>, <code>!=</code>, <code>=:</code>, <code>!:</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&</code>, <code>|</code>, <code>^</code>)
        are fully supported and can be used with <code><k->inf</k-></code> and any other non-<code><k->nan</k-></code> floating point value, according to the required types of each operator.<br>
    Any remaining operation with special floating point values has <b>undefined</b> result.
</p>
<p>
    The <code><f->isnan</f-></code> function can be used to check for <code><k->nan</k-></code> values.<br>
    Any operation with <code><k->nan</k-></code> values has <b>undefined</b> result.<br>
    Converting special values to non-floating point types also has <b>undefined</b> result.
</p>
<p>
    Some <b>special cases</b> of <b>integral operations</b> have <b>undefined</b> result:
</p>
<div class="table-container"><table>
    <tr>
        <th>Operation (special cases)</th>
        <th>Result</th>
    </tr>
    <tr>
        <td class="center"><code>n</code> / <code><k->0</k-></code></td>
        <td class="center"><code><b>undefined</b></code></td>
    </tr>
    <tr>
        <td class="center"><code>n</code> % <code><k->0</k-></code></td>
        <td class="center"><code><b>undefined</b></code></td>
    </tr>
</table></div>
<p>
    Where <code>n</code> is any non-<code><k->0</k-></code> <a href="#primitive-types">integral</a> value.
</p>
<p>
    Undefined results don't stop the program execution and are not detected in any way.
</p>


<h1 id="array-operations"></h1>
<p>
    All <a href="#common-operators">common</a> and <a href="#assignment-operators">assignment</a> operators in the core module, excluding <a href="#common-operators"><code>=:</code></a> and <a href="#common-operators"><code>!:</code></a>, can be used to operate on whole <a href="#arrays">arrays</a>.
</p>
<p>
    When arrays are used with unary operators, the operation is performed on all the elements of the array and the return value is an array of the same length,
    containing the results of the operations.
</p>
<split-example-container->
    <split-example-container-left->
        <example- style="margin: 0;">
            <label->Example</label->
            <div>
                <t->auto</t-> <f->main</f->(){
                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                    <w->return</w-> <f->~</f->a;
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- style="margin: 0;">
            <label->Equivalent code</label->
            <div>
                <t->auto</t-> <f->main</f->(){
                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                    <t->uint</t->[<k->4</k->] ret;
                    <w->for</w->(<t->int</t-> i <f->=</f-> <k->0</k->; i <f->&lt;</f-> a.<f->len</f->(); <f->++</f->){
                        ret[i] <f->=</f-> <f->~</f->a[i];
                    }
                    <w->return</w-> ret;
                }
            </div>
        </example->
    </split-example-container-right->
</split-example-container->

<p>
    When arrays are used as both the first and second operand of binary operators, the arrays must have identical length.
    The operation is performed between each element of the first operand and the respective element of the second operand,
    and the return value is an array of the same length containing the results of the operations.
</p>
<split-example-container->
    <split-example-container-left->
        <example- style="margin: 0;">
            <label->Example</label->
            <div>
                <t->void</t-> <f->main</f->(){
                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                    <t->int</t->[<k->4</k->] b;
                    b = a;
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- style="margin: 0;">
            <label->Equivalent code</label->
            <div>
                <t->void</t-> <f->main</f->(){
                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                    <t->int</t->[<k->4</k->] b;
                    <w->for</w->(<t->int</t-> i <f->=</f-> <k->0</k->; i <f->&lt;</f-> a.<f->len</f->(); <f->++</f->){
                        a[i] <f->=</f-> a[i];
                    }
                }
            </div>
        </example->
    </split-example-container-right->
</split-example-container->

<p>
    When an array is used as the first operand of binary operators and a value of its base type is used as the second operand,
    the operation is performed between each element of the first operand and the value of second operand.
    The return value is an array of the same length of the first operand containing the results of the operations.
</p>
<split-example-container->
    <split-example-container-left->
        <example- style="margin: 0;">
            <label->Example</label->
            <div>
                <t->void</t-> <f->main</f->(){
                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                    <t->int</t-> b <f->=</f-> <k->8</k->;
                    a <f->*=</f-> b;
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- style="margin: 0;">
            <label->Equivalent code</label->
            <div>
                <t->void</t-> <f->main</f->(){
                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                    <t->int</t-> b <f->=</f-> <k->8</k->;
                    <w->for</w->(<t->int</t-> i <f->=</f-> <k->0</k->; i <f->&lt;</f-> a.<f->len</f->(); <f->++</f->){
                        a[i] <f->*=</f-> b;
                    }
                }
            </div>
        </example->
    </split-example-container-right->
</split-example-container->



<h1 id="core.data-types"></h1>
<p>
    //TODO
</p>


<h1 id="core.arrays"></h1>
<p>
</p>


<h1 id="core.tuples"></h1>
<p>
</p>



<h1 id="standard-modules"></h1>


<h1 id="limits-module"></h1>


<h1 id="math-module"></h1>


<h1 id="bits-module"></h1>


<h1 id="types-module"></h1>


<h1 id="memory-module"></h1>



<h1 id="quick-reference-tabs"></h1>


<h1 id="syntaxes"></h1>


<h1 id="preprocessor-syntaxes"></h1>







<syntax->
    <label- id="syntax--preprocessor-comment">Comment</label->
    <table>
        <tr>
            <td data-arrows="br ar"></td>
            <td><code>//</code></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td data-arrows="br ar"></td>
            <td><code><nl-></nl-></code></td>
            <td data-arrows="lb"></td>
        </tr>
        <tr>
            <td data-arrows="lt lb"></td>
            <td></td>
            <td data-arrows="tr-high ar-high br-low ar-low"></td>
            <td><elm->comment string</elm-></td>
            <td data-arrows="lt-high lb-low"></td>
            <td></td>
            <td data-arrows="tr br ar"></td>
        </tr>
        <tr>
            <td data-arrows="tr ar"></td>
            <td><code>/*</code></td>
            <td data-arrows="lt"></td>
            <td></td>
            <td data-arrows="tr ar"></td>
            <td><code>*/</code></td>
            <td data-arrows="lt"></td>
        </tr>
    </table>
</syntax->











<syntax->
    <label- id="syntax--preprocessor-include">Include</label->
    <table>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><code>#include</code></td>
            <td data-arrows="lr ar"></td>
            <td><code><space-></space-></code></td>
            <td data-arrows="lr ar lb"></td>
            <td><code>"</code></td>
            <td data-arrows="lr ar"></td>
            <td class="center"><elm->path/to/file</elm-></td>
            <td data-arrows="lr ar"></td>
            <td><code>"</code></td>
            <td data-arrows="lr br ar"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="tr ar"></td>
            <td><code>&lt;</code></td>
            <td data-arrows="lr ar"></td>
            <td class="center"><elm->module name</elm-></td>
            <td data-arrows="lr ar"></td>
            <td><code>&gt;</code></td>
            <td data-arrows="lt"></td>
        </tr>
    </table>
</syntax->











<syntax->
    <label- id="syntax--preprocessor-line-continuation-token">Line continuation token</label->
    <table>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><code>&bsol;</code></td>
            <td data-arrows="lr ar"></td>
            <td><code><nl-></nl-></code></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->


<h1 id="misc-syntaxes"></h1>
















<syntax- class="qrt">
    <label- id="syntax--declaration-module" class="s-decl"><a href="#modules">Module</a></label->
    <table class="s-decl">
        <tr>
            <td data-arrows="lr br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr ar lb"></td>
        </tr>
        <tr>
            <td data-arrows="rt bt"></td>
            <td><s-decl->import directive</s-decl-></td>
            <td data-arrows="tl al tb"></td>
        </tr>
        <tr>
            <td data-arrows="rt bt"></td>
            <td><s-decl->export directive</s-decl-></td>
            <td data-arrows="tl al tb"></td>
        </tr>
        <tr>
            <td data-arrows="rt"></td>
            <td><s-decl->declaration<span class="hidden">&nbsp;*</span></s-decl-></td>
            <td data-arrows="tl al"></td>
        </tr>
    </table>
    <syntax-note->
        * A
        <a href="#syntax--declaration-namespace">   namespace</a>,
        <a href="#syntax--declaration-enum">        enum</a>,
        <a href="#syntax--declaration-struct">      struct</a>,
        <a href="#syntax--template-declaration">    struct template</a>,
        <a href="#syntax--function-declaration">    function</a>,
        <a href="#syntax--template-declaration">    function template</a>,
        <a href="#syntax--operator-declaration">    operator</a>,
        <a href="#syntax--template-declaration">    operator template</a>,
        <a href="#syntax--declaration-variable">    variable</a> or a
        <a href="#syntax--declaration-symbol-alias">symbol alias</a>.
    </syntax-note->
</syntax->





















<syntax- class="qrt">
    <label- class="s-decl" id="syntax--misc-import-directive"><a href="#import-directive">Import directive</a></label->
    <table class="s-decl">
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="br ar"></td>
            <td><s-vbtm->&lt;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-any->module name</s-any-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->&gt;</s-vbtm-></td>
            <td data-arrows="lb"></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr ar lb"></td>
            <td><s-vbtm->include</s-vbtm-></td>
            <td data-arrows="lb"></td>
            <td data-arrows="br ar"></td>
            <td><s-vbtm->*</s-vbtm-></td>
            <td data-arrows="br lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr br ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->from</s-vbtm-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->"</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-any->path/to/module</s-any-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->"</s-vbtm-></td>
            <td data-arrows="lr tr"></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->as</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="tr lr ar"></td>
            <td><s-vbtm->import</s-vbtm-></td>
            <td data-arrows="lr tr"></td>
            <td data-arrows="lr br ar lt"></td>
            <td><s-path->symbol</s-path-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->as</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->,</s-vbtm-></td>
            <td data-arrows="lb"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
</syntax->
















<syntax- class="qrt">
    <label- class="s-decl" id="syntax--misc-export-directive"><a href="#export-directive">Export directive</a></label->
    <table class="s-decl">
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->as</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->export</s-vbtm-></td>
            <td data-arrows="lr lt lb"></td>
            <td><s-vbtm->*</s-vbtm-></td>
            <td data-arrows="br lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="br tr ar lr"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="tr br ar"></td>
            <td><s-path->symbol</s-path-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->as</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->,</s-vbtm-></td>
            <td data-arrows="lb"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
</syntax->




















<syntax- class="qrt">
    <label- class="s-decl" id="syntax--misc-construct-directive"><a href="#construct-directive">Construct directive</a></label->
    <table class="s-decl">
        <tr>
            <td></td>
        </tr>
    </table>
</syntax->


<h1 id="symbol-path-syntaxes"></h1>




<syntax- class="qrt">
    <label- id="syntax--path-standard" class="s-path">Standard path</label->
    <table class="s-path">
        <tr>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr br ar"></td>
        </tr>
        <tr>
            <td data-arrows="lr br ar"></td>
            <td><s-sub->synbol name</s-sub-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->.</s-vbtm-></td>
            <td data-arrows="lb lt"></td>
        </tr>
        <tr>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
</syntax->








<syntax- class="qrt">
    <label- id="syntax--path-type" class="s-path">Type path</label->
    <table class="s-path">
        <tr>
            <td data-arrows="br ar"></td>
            <td><s-vbtm->typeof</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->(</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-expr->value</s-expr-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->)</s-vbtm-></td>
            <td data-arrows="lb"></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr lb"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr br ar"></td>
        </tr>
        <tr>
            <td data-arrows="lt lb lr ar"></td>
            <td><s-path->base type</s-path-></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="tr br lr"></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->const</s-vbtm-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-vbtm->@</s-vbtm-></td>
            <td data-arrows="lt"></td>
        </tr>
        <tr>
            <td data-arrows="tr ar"></td>
            <td><s-path->return type</s-path-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->(</s-vbtm-></td>
            <td data-arrows="lr br ar"></td>
            <td><s-path->parameter type</s-path-></td>
            <td data-arrows="lr ar lb"></td>
            <td><s-vbtm->)</s-vbtm-></td>
            <td data-arrows="lt"></td>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
        </tr>
        <tr>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
            <td data-arrows="rt"></td>
            <td><s-vbtm->,</s-vbtm-></td>
            <td data-arrows="tl al"></td>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
            <td data-arrows=""></td>
        </tr>
    </table>
</syntax->









<syntax- class="qrt">
    <label- id="syntax--path-reflection" class="s-path">Reflection path</label->
    <table class="s-path">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-path->path to target symbol</s-path-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->::</s-sbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-path->path to element</s-path-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->










<syntax->
    <label- id="syntax--path-name" class="s-sub">Symbol name</label->
    <table class="s-sub">
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr br ar"></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-any->symbol identifier<span class="hidden">&nbsp;*</span></s-any-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->&lt;</s-vbtm-></td>
            <td data-arrows="lr br"></td>
            <td data-arrows="lr ar lb"></td>
            <td><s-path->type</s-path-></td>
            <td data-arrows="lr br"></td>
            <td data-arrows="lr ar lb"></td>
            <td><s-vbtm->&gt;</s-vbtm-></td>
            <td data-arrows="lt"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="bt"></td>
            <td data-arrows="tr ar"></td>
            <td><s-expr->value</s-expr-></td>
            <td data-arrows="lt"></td>
            <td data-arrows="tr ar"></td>
            <td><s-vbtm->,</s-vbtm-></td>
            <td data-arrows="lb"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
    <syntax-note->
        * For operators, the first identifier is used.
    </syntax-note->
</syntax->


<h1 id="symbol-declarations"></h1>
<p>
    This section summarizes all the syntaxes used to declare user-defined symbols.<br>
</p>















<syntax- class="qrt">
    <label- class="s-decl" id="syntax--declaration-namespace"><a href="#namespaces">Namespace declaration</a></label->
        <table class="s-decl">
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->namespace</s-vbtm-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar tr"></td>
            <td><s-vbtm->{</s-vbtm-></td>
            <td data-arrows="lr br ar lt"></td>
            <td><s-decl->declaration<span class="hidden">&nbsp;*</span></s-decl-></td>
            <td data-arrows="lr tr ar lb"></td>
            <td><s-vbtm->}</s-vbtm-></td>
            <td data-arrows="lr"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
            <td></td>
            <td></td>
        </tr>
    </table>
    <syntax-note->
        * One of the <a href="#symbol-declarations">declarations</a> allowed in the parent scope.
    </syntax-note->
</syntax->
















<syntax- class="qrt">
    <label- class="s-decl" id="syntax--declaration-enum"><a href="#enums">Enum declaration</a></label->
    <table class="s-decl">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->enum</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->:</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-path->base type</s-path-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->{</s-vbtm-></td>
            <td data-arrows="lr br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr ar lb"></td>
            <td><s-vbtm->}</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="rt bt"></td>
            <td><s-decl->declaration<span class="hidden">&nbsp;*</span></s-decl-></td>
            <td data-arrows="tl al tb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td><s-decl->enum element</s-decl-></td>
            <td data-arrows="tl al"></td>
            <td></td>
            <td></td>
        </tr>

    </table>
    <label- class="s-decl" id="syntax--declaration-enum-element"><a href="#enums">Enum element</a></label->
    <table class="s-decl">
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td data-arrows="br ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td data-arrows="lr br ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->=</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-expr-><t->[base type]</t->&nbsp;value</s-expr-></td>
            <td data-arrows="lr tr"></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->,</s-vbtm-></td>
            <td data-arrows="lb"></td>
        </tr>
        <tr>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
    <syntax-note->
        * An
        <a href="#syntax--declaration-enum">enum</a>,
        <a href="#syntax--declaration-struct">struct</a>,
        <a href="#syntax--template-declaration">struct template</a> or a
        <a href="#syntax--declaration-symbol-alias">symbol alias</a>.
    </syntax-note->
</syntax->















<syntax- class="qrt">
    <label- class="s-decl" id="syntax--declaration-struct"><a href="#structs">Struct declaration</a></label->
    <table class="s-decl">
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-sub->struct signature</s-sub-></td>
            <td data-arrows="lr br"></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-sub->specialization constraint</s-sub-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-sub->struct body</s-sub-></td>
            <td data-arrows="lr ar lb"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
    <label- class="s-sub" id="syntax--declaration-struct-signature"><a href="#structs">Struct signature</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->struct</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
    <label- class="s-sub" id="syntax--declaration-struct-body"><a href="#structs">Struct body</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->{</s-vbtm-></td>
            <td data-arrows="lr br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr ar lb"></td>
            <td><s-vbtm->}</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="rt bt"></td>
            <td><s-decl->declaration<span class="hidden">&nbsp;*</span></s-decl-></td>
            <td data-arrows="tl al tb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td><s-decl->struct member</s-decl-></td>
            <td data-arrows="tl al"></td>
            <td></td>
            <td></td>
        </tr>
    </table>
    <label- class="s-decl" id="syntax--declaration-struct-member"><a href="#structs">Struct member</a></label->
    <table class="s-decl">
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="br ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-path->type</s-path-></td>
            <td data-arrows="lr br ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->,</s-vbtm-></td>
            <td data-arrows="lb"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
    <syntax-note->
        * An
        <a href="#syntax--declaration-enum">enum</a>,
        <a href="#syntax--declaration-struct">struct</a>,
        <a href="#syntax--template-declaration">struct template</a> or a
        <a href="#syntax--declaration-symbol-alias">symbol alias</a>.
    </syntax-note->
</syntax->















<syntax- class="qrt">
    <label- class="s-decl" id="syntax--declaration-function"><a href="#functions">Function declaration</a></label->
    <table class="s-decl">
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-sub->function signature</s-sub-></td>
            <td data-arrows="lr br"></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-sub->specialization constraint</s-sub-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-sub->routine body</s-sub-></td>
            <td data-arrows="lr ar lb"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
    <label- class="s-decl" id="syntax--declaration-operator"><a href="#operators">Operator declaration</a></label->
    <table class="s-decl">
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-sub->operator signature</s-sub-></td>
            <td data-arrows="lr br"></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-sub->specialization constraint</s-sub-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-sub->routine body</s-sub-></td>
            <td data-arrows="lr ar lb"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
    <label- class="s-sub" id="syntax--declaration-function-signature"><a href="#functions">Function signature</a></label->
    <table class="s-sub">
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-path->return type</s-path-></td>
            <td data-arrows="lr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->(</s-vbtm-></td>
            <td data-arrows="lt lr br"></td>
            <td data-arrows="lr ar lb"></td>
            <td><s-decl->routine parameter</s-decl-></td>
            <td data-arrows="lr br"></td>
            <td data-arrows="lr tr ar lb"></td>
            <td><s-vbtm->)</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="bt"></td>
            <td data-arrows="tr ar"></td>
            <td><s-decl->function parameter pack<span class="hidden">&nbsp;***</span></s-decl-></td>
            <td data-arrows="lt"></td>
            <td data-arrows="tr ar"></td>
            <td><s-vbtm->,</s-vbtm-></td>
            <td data-arrows="lb"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
    <label- class="s-sub" id="syntax--declaration-operator-signature"><a href="#operators">Operator signature</a></label->
    <table class="s-sub">
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr ar"></td>
            <td><s-any->name<span class="hidden">&nbsp;**</span></s-any-></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-path->return type</s-path-></td>
            <td data-arrows="lt lb rt-high rb-low"></td>
            <td data-arrows="rl-high rl-low"></td>
            <td data-arrows="rl-high rl-low"></td>
            <td data-arrows="rl-high rl-low"></td>
            <td data-arrows="rl-high rl-low"></td>
            <td data-arrows="rl-high rl-low"></td>
            <td data-arrows="bl-high tr br ar lt-low"></td>
            <td><s-vbtm->priority</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->(</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-expr-><t->[ulong]</t-> &nbsp;priority</s-expr-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->)</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="tr ar"></td>
            <td><s-vbtm->(</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-decl->routine parameter<span class="hidden">&nbsp;**</span></s-decl-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->)</s-vbtm-></td>
            <td data-arrows="tl"></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </table>
    <label- class="s-sub" id="syntax--declaration-routine-body"><a href="#routines">Routine body</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->{</s-vbtm-></td>
            <td data-arrows="lr br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr ar lb"></td>
            <td><s-vbtm->}</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="rt bt"></td>
            <td><s-sub-><a href="#statement-syntaxes">statement</a></s-sub-></td>
            <td data-arrows="tl al tb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td><s-decl->declaration<span class="hidden">&nbsp;*</span></s-decl-></td>
            <td data-arrows="tl al"></td>
            <td></td>
            <td></td>
        </tr>
    </table>
    <syntax-note->
        * An
        <a href="#syntax--declaration-enum">enum</a>,
        <a href="#syntax--declaration-struct">struct</a>,
        <a href="#syntax--template-declaration">struct template</a>,
        <a href="#syntax--variables">variable</a> or a
        <a href="#syntax--declaration-symbol-alias">symbol alias</a>.<br>

        ** At least one name and one parameter declaration.<br>

        *** No more than once.
    </syntax-note->
    <label- class="s-decl" id="syntax--declaration-routine-parameter"><a href="#routine-parameters">Routine parameter</a></label->
    <table class="s-decl">
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-path->type</s-path-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->&<span class="hidden">&nbsp;*</span></s-vbtm-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->=</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-expr-><t->[type]</t->&nbsp;value</s-expr-></td>
            <td data-arrows="lr tr ar"></td>
        </tr>
    </table>
    <syntax-note->
        * Only if type is a <a href="#pointer-types">pointer type</a>.
    </syntax-note->
    <label- class="s-decl" id="syntax--declaration-function-parameter-pack"><a href="#function-parameter-packs">Function parameter pack</a></label->
    <table class="s-decl">
        <tr>
            <td data-arrows="br ar"></td>
            <td><s-path->template parameter pack</s-path-></td>
            <td data-arrows="lr br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar lt"></td>
            <td><s-path->type</s-path-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->&<span class="hidden">&nbsp;*</span></s-vbtm-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->...</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->













































<syntax- class="qrt">
    <label- class="s-decl" id="syntax--declaration-variable"><a href="#variables">Variable declaration</a></label->
    <table class="s-decl">
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td data-arrows="br ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-path->type</s-path-></td>
            <td data-arrows="lr br ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->=</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-expr-><t->[type]</t->&nbsp;value</s-expr-></td>
            <td data-arrows="lr tr"></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->,</s-vbtm-></td>
            <td data-arrows="lb"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
</syntax->












<syntax- class="qrt">
    <label- class="s-decl" id="syntax--declaration-symbol-alias"><a href="#symbol-aliases">Symbol alias declaration</a></label->
    <table class="s-decl">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->alias</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-path->symbol</s-path-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->as</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->












<syntax- class="qrt">
    <label- class="s-sub" id="syntax--declaration-specialization-constraint"><a href="#specialization-constraints">Specialization constraint</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->when</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->(</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-expr-><t->[bool]</t->&nbsp;condition</s-expr-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->)</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->






























<syntax- class="qrt">
    <label- class="s-decl" id="syntax--declaration-template-struct"><a href="#templates">Struct template declaration</a></label->
    <table class="s-decl">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-sub->template signature<span class="hidden">&nbsp;*</span></s-sub-></td>
            <td data-arrows="lr ar"></td>
            <td><s-decl->struct declaration</s-decl-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
    <label- class="s-decl" id="syntax--declaration-template-function"><a href="#templates">Function template declaration</a></label->
    <table class="s-decl">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-sub->template signature<span class="hidden">&nbsp;*</span></s-sub-></td>
            <td data-arrows="lr ar"></td>
            <td><s-decl->function declaration</s-decl-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
    <label- class="s-decl" id="syntax--declaration-template-operator"><a href="#templates">Operator template declaration</a></label->
    <table class="s-decl">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-sub->template signature<span class="hidden">&nbsp;*</span></s-sub-></td>
            <td data-arrows="lr ar"></td>
            <td><s-decl->operator declaration</s-decl-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
    <label- class="s-sub" id="syntax--declaration-template-signature"><a href="#templates">Template signature</a></label->
    <table class="s-sub">
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="br ar"></td>
            <td><s-decl->template parameter</s-decl-></td>
            <td data-arrows="lb"></td>
            <td data-arrows="br ar"></td>
            <td><s-vbtm->&gt;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->template</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->&lt;</s-vbtm-></td>
            <td data-arrows="br lr"></td>
            <td data-arrows="lt lr ar"></td>
            <td><s-decl->template parameter pack<span class="hidden">&nbsp;**</span></s-decl-></td>
            <td data-arrows="lr tr"></td>
            <td data-arrows="lt lr ar"></td>
            <td><s-vbtm->,</s-vbtm-></td>
            <td data-arrows="lb"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
    <syntax-note->
        * Can be omitted when using the <a href="#abbreviated-template-syntax">Abbreviated template syntax</a>.<br>
        ** No more than once.
    </syntax-note->
    <label- class="s-decl" id="syntax--declaration-template-parameter"><a href="#template-parameters">Template parameter</a></label->
    <table class="s-decl">
        <tr>
            <td data-arrows="br ar"></td>
            <td><s-vbtm->type</s-vbtm-></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar lt"></td>
            <td><s-path->type<span class="hidden">&nbsp;*</span></s-path-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
    <label- class="s-decl" id="syntax--declaration-template-parameter-pack"><a href="#template-parameter-packs">Template parameter pack</a></label->
    <table class="s-decl">
        <tr>
            <td data-arrows="br ar"></td>
            <td><s-vbtm->type</s-vbtm-></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar lt"></td>
            <td><s-path->type<span class="hidden">&nbsp;*</span></s-path-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->...</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
    <syntax-note->
        * Can be an integral type or an enum.
    </syntax-note->
</syntax->


<h1 id="statement-syntaxes"></h1>









<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-if"><a href="#if-statement">If statement</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->if</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->(</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-expr-><t->[bool]</t->&nbsp;condition</s-expr-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->)</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-sub->statement</s-sub-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->
<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-match"><a href="#match-statement">Match statement</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->match</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->(</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-expr-><t->[t]</t->&nbsp;value</s-expr-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->)</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->{</s-vbtm-></td>
            <td data-arrows="lr br ar"></td>
            <td><s-sub->match case</s-sub-></td>
            <td data-arrows="lr ar lb"></td>
            <td><s-vbtm->}</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
            <td></td>
            <td></td>
        </tr>
    </table>
    <label- class="s-sub"><a href="#match-statement">Match case</a></label->
    <table class="s-sub">
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td data-arrows="br ar"></td>
            <td><s-vbtm->{</s-vbtm-></td>
            <td data-arrows="lr br ar"></td>
            <td><s-sub->statement</s-sub-></td>
            <td data-arrows="lr ar lb"></td>
            <td><s-vbtm->}</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td data-arrows="lr br ar"></td>
            <td><s-expr-><t->[t]</t->&nbsp;a</s-expr-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->to</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-expr-><t->[t]</t->&nbsp;b</s-expr-></td>
            <td data-arrows="lr tr"></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->,</s-vbtm-></td>
            <td data-arrows="rt lb"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="rt"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </table>
</syntax->
















<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-for"><a href="#for-statement">For statement</a></label->
    <table class="s-sub">
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="br ar bt"></td>
            <td><s-expr->initializer</s-expr-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-expr-><t->[bool]</t->&nbsp;condition</s-expr-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-expr->iteration</s-expr-></td>
            <td data-arrows="lb tb"></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->for</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->(</s-vbtm-></td>
            <td data-arrows="lr ar lt lb"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->in</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-expr->value</s-expr-></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr tr br ar"></td>
            <td><s-vbtm->)</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-sub->statement</s-sub-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="tb tr ar"></td>
            <td><s-expr-><t->[t]</t->&nbsp;a</s-expr-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->to</s-vbtm-></td>
            <td data-arrows="lr br ar"></td>
            <td><s-expr-><t->[t]</t->&nbsp;b</s-expr-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->as</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-any->name</s-any-></td>
            <td data-arrows="lt"></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="tr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lt"></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </table>
</syntax->















<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-while"><a href="#while-statement">While statement</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-sub->while signature</s-sub-></td>
            <td data-arrows="lr ar"></td>
            <td><s-sub->statement</s-sub-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
    <label- class="s-sub" id="syntax--statement-do-while"><a href="#while-statement">Do-while statement</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->do</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-sub->statement</s-sub-></td>
            <td data-arrows="lr ar"></td>
            <td><s-sub->while signature</s-sub-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
    <label- class="s-sub" id="syntax--statement-while-signature"><a href="#while-statement">While signature</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->while</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->(</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-expr-><t->[bool]</t->&nbsp;condition</s-expr-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->)</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->















<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-continue"><a href="#continue-and-break-statements">Continue statement</a></label->
    <table class="s-sub">
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->continue</s-vbtm-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-expr-><t->[ulong]</t->&nbsp;amount</s-expr-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->











<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-break"><a href="#continue-and-break-statements">Break statement</a></label->
    <table class="s-sub">
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->break</s-vbtm-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-expr-><t->[ulong]</t->&nbsp;amount</s-expr-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->















<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-once"><a href="#once-statement">Once statement</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->once</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-sub->statement</s-sub-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->














<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-then"><a href="#then-statement">Then statement</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->then</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-sub->statement</s-sub-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->














<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-return"><a href="#return-statement">Return statement</a></label->
    <table class="s-sub">
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->return</s-vbtm-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-expr-><t->[return type]</t->&nbsp;value<span class="hidden">&nbsp;*</span></s-expr-></td>
            <td data-arrows="lr tr ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
    <syntax-note->
        * "return type" = routine return type used in the function or operator signature
    </syntax-note->
</syntax->











<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-defer"><a href="#defer-statement">Defer statement</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->defer</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><a href="#syntax--expression-routine-call"><s-expr->call<span class="hidden">&nbsp;*</span></s-expr-></a></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
    <syntax-note->
        * The expression must be a <a href="#syntax--expression-routine-call">routine call</a> expression
    </syntax-note->
</syntax->















<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-else"><a href="#else-statement">Else statement</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->else</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-sub->statement</s-sub-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->






<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-unnamed-scope"><a href="#unnamed-scopes">Unnamed scope</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->{</s-vbtm-></td>
            <td data-arrows="lr br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr ar lb"></td>
            <td><s-vbtm->}</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="rt bt"></td>
            <td><s-sub->statement</s-sub-></td>
            <td data-arrows="tl al tb"></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td><s-decl->declaration<span class="hidden">&nbsp;*</span></s-decl-></td>
            <td data-arrows="tl al"></td>
            <td></td>
            <td></td>
        </tr>
    </table>
    <syntax-note->
        * An
        <a href="#syntax--declaration-enum">enum</a>,
        <a href="#syntax--declaration-struct">struct</a>,
        <a href="#syntax--template-declaration">struct template</a>,
        <a href="#syntax--variables">variable</a> or a
        <a href="#syntax--declaration-symbol-alias">symbol alias</a>.<br>
    </syntax-note->
</syntax->
















<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-expression"><a href="#expression-statement">Expression statement</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-expr->expression</s-expr-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->






















<syntax- class="qrt">
    <label- class="s-sub" id="syntax--statement-empty"><a href="#empty-statement">Empty statement</a></label->
    <table class="s-sub">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->;</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->




<h1 id="expression-syntaxes"></h1>








<syntax- class="qrt">
    <label- class="s-expr" id="syntax--expression-literal"><a href="#literals">Literal</a></label->
    <table class="s-expr">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-any->literal token</s-any-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->







<syntax- class="qrt">
    <label- class="s-expr" id="syntax--expression-try"><a href="#try-expression">Try expression</a></label->
    <table class="s-expr">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->try</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->{</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->idk</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->}</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->








<syntax- class="qrt">
    <label- class="s-expr" id="syntax--expression-variable"><a href="#variables">Variables</a></label->
    <table class="s-expr">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-path->path to variable</s-path-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->















<syntax- class="qrt">
    <label- class="s-expr" id="syntax--expression-temporary-variable"><a href="#temporary-variables">Temporary variables</a></label->
    <table class="s-expr">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->$</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
            <td><s-expr-><t->[ulong]</t->&nbsp;name&nbsp<span class="hidden">*</span></s-expr-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
    <syntax-note->
        * Must be a literal
    </syntax-note->
</syntax->















<syntax- class="qrt">
    <label- class="s-expr" id="syntax--expression-routine-parameter"><a href="#declarations.routine-parameters">Routine parameter</a></label->
    <table class="s-expr">
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-path->path to parameter</s-path-></td>
            <td data-arrows="lr ar"></td>
        </tr>
    </table>
</syntax->















<syntax- class="qrt">
    <label- class="s-expr" id="syntax--expression-function-call"><a href="#declarations.functions">Function call</a></label->
    <table class="s-expr">
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="br ar"></td>
            <td><s-vbtm->)</s-vbtm-></td>
            <td data-arrows="lr ar"></td>
        </tr>
        <tr>
            <td data-arrows="lr ar"></td>
            <td><s-path->path to function</s-path-></td>
            <td data-arrows="lr ar"></td>
            <td><s-vbtm->(</s-vbtm-></td>
            <td data-arrows="lr br ar"></td>
            <td><s-expr->argument</s-expr-></td>
            <td data-arrows="lr ar lt"></td>
            <td><s-vbtm->,</s-vbtm-></td>
            <td data-arrows="lb"></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="rt"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="rl"></td>
            <td data-arrows="tl"></td>
        </tr>
    </table>
</syntax->

















<syntax- class="qrt">
    <label- class="s-expr" id="syntax--expression-operator-call"><a href="#declarations.operators">Operator call</a></label->
    <table class="s-expr">
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td data-arrows="br"></td>
            <td data-arrows="lr"></td>
            <td data-arrows="br lr ar"></td>
        </tr>
        <tr>
            <td data-arrows="lr lb"></td>
            <td data-arrows="lr br ar"></td>
            <td><s-path->path to operator<span class="hidden">&nbsp;**</span></s-path-></td>
            <td data-arrows="lr br ar lt"></td>
            <td><s-expr->argument<span class="hidden">&nbsp;*</span></s-expr-></td>
            <td data-arrows="lt lb"></td>
        </tr>
        <tr>
            <td data-arrows="tr-high"></td>
            <td data-arrows="rt-low lr-high"></td>
            <td data-arrows="rl-low lr-high"></td>
            <td data-arrows="rl-low lt-high"></td>
            <td data-arrows="rl-low"></td>
            <td data-arrows="tl-low"></td>
        </tr>
    </table>
    <syntax-note->
        * At least one argument and one path.<br>
        ** Noninitial paths are not required to specify the names of parent symbols or template instantiation types. Their identifier is enough.
    </syntax-note->
</syntax->


<h1 id="undefined-behaviours"></h1>


<h1 id="conversions"></h1>


<h1 id="core-module-operators"></h1>


<h1 id="math-module-functions"></h1>


<h1 id="omitted-features"></h1>

                </main-right-doc-scroll->
            </div><div id="main-right-examples" class="hide-scrollbar">
                <main-right-examples-scroll->
                </main-right-examples-scroll->
            </div><div id="main-right-internal" class="hide-scrollbar">
                <main-right-internal-scroll->
                </main-right-internal-scroll->
            </div>
        </div>
    </right->
    <script src="Scripts/Setup/Fix.js"></script>
    <script src="Scripts/Setup/Syntax.js"></script>
    <script src="Scripts/Setup/DocumentationTabs.js"></script>
    <script src="Scripts/Setup/Index.js"></script>
    <script src="Scripts/Setup/CopySyntax.js"></script>
    <script src="Scripts/main.js"></script>
    <script src="Scripts/UI/Slider.js"></script>
    <script src="Scripts/UI/SmoothLinks.js"></script>
    <script src="Scripts/UI/CopyCode.js"></script>
    <script src="Scripts/UI/SyntaxHover.js"></script>
    <script src="Scripts/Custom/SummaryList.js"></script>
    <script src="Scripts/Readability.js"></script>


    <script>
        document.addEventListener('DOMContentLoaded', init);
        window.addEventListener('popstate', function(){ move_to_view(true); });
        window.addEventListener('beforeunload', unload);
        //
        //TODO implement counter to manage more dynamic css loadings
    </script>
</body>
</html>


