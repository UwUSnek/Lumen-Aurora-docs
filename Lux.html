<!DOCTYPE html>
<html>
<head>
    <!-- HTML boilerplate -->
    <title>The Lux shading language</title>
    <meta charset="UTF-8">
    <meta name="author" content="Snek" />
    <meta name="description" content="Lux language specification" />
    <link rel="icon" href="Lux-logo.png" type="image/icon type">

    <!-- Style -->
    <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, width=device-width, user-scalable=no" />
    <link rel="stylesheet" type="text/css" href="Style.css" media="screen">

    <style>
        .table-1-container {
            white-space: nowrap;
            padding: 0;
            margin: 0;
            min-width: 100%;
            border-radius: 10px 0 0 0;
            overflow: hidden;
            word-spacing: -100vw;
            text-align: center;
        }.table-1-right-container {
            vertical-align: top;
            overflow-x: scroll;
            display: inline-block;
            max-width: calc(100% - 24ch);
        }.table-1-right {
            border-radius: 0 10px 10px 0;
            word-spacing: var(--word-spacing);
        }.table-1-left-container {
            vertical-align: top;
            overflow-x: scroll;
            display: inline-block;
            max-width: 24ch;
            border-bottom-left-radius: 10px;
        }.table-1-left {
            border-radius: 10px 0 0 10px;
            word-spacing: var(--word-spacing);
        }
        .table-1-y { background-color: #0a7a003a; }
        .table-1-n { background-color: #7a00003a; }
        .table-1-y::before { content: "Yes "; }
        .table-1-n::before { content: "No ";  }



        .conv-cell-y { border-left: 2px solid hsla(115, 50%, 20%, 100%); }
        .conv-cell-m { border-left: 2px solid hsla(64,  50%, 20%, 100%); }
        .conv-cell-n { border-left: 2px solid hsla(0,   50%, 20%, 100%); }
    </style>
</head>
<body onresize="_onresize()">
    <!--------------------------------------------------------------------->
    <!-- Mask                                                            -->
    <!--------------------------------------------------------------------->
    <div style="min-width: 100vw; min-height: 100vh; background-color: var(--bg); position: fixed; z-index: 999999;" id="main-mask"></div>


    <!--------------------------------------------------------------------->
    <!-- Slider                                                          -->
    <!--------------------------------------------------------------------->
    <input type="range" min="0" max="99999999" value="0" step="0.00001" class="slider" id="main-slider">
    <!-- !                           ^ not a random value                                            -->


    <!--------------------------------------------------------------------->
    <!-- Index                                                           -->
    <!--------------------------------------------------------------------->
    <left- class="hide-scrollbar" id="main-left">
        <index- class="hide-scrollbar"><indexh-></indexh->
            <indexd->overview</indexd->
            <index-><indexh->preprocessor</indexh->
                <indexd->comments</indexd->
                <indexd->include-statement</indexd->
                <indexd->macros</indexd->
                <indexd->conditionals</indexd->
                <indexd->line-continuation-token</indexd->
            </index->

            <index-><indexh->language</indexh->
                <index-><indexh->language-concepts</indexh->
                    <indexd->character-set</indexd->
                    <index-><indexh->tokens</indexh->
                        <indexd->keywords</indexd->
                        <indexd->literal-tokens</indexd->
                        <indexd->syntax-specific-tokens</indexd->
                        <indexd->identifiers</indexd->
                    </index->
                    <index-><indexh->semantic-elements</indexh->
                        <indexd->symbols</indexd->
                        <indexd->scopes</indexd->
                    </index->
                    <index-><indexh->name-resolution</indexh->
                        <indexd->indices</indexd->
                        <indexd->generated-symbols</indexd->
                        <indexd->name-shadowing</indexd->
                    </index->
                    <indexd->undefined-values</indexd->
                    <indexd->undefined-behaviour</indexd->
                    <indexd->compile-time-values</indexd->
                </index->
                <indexd->namespaces</indexd->
                <index-><indexh->types</indexh->
                    <index-><indexh->primitive-types</indexh->
                        <indexd->integral-types</indexd->
                        <indexd->floating-point-types</indexd->
                        <indexd->bool-type</indexd->
                        <indexd->enums</indexd->
                    </index->
                    <index-><indexh->aggregate-types</indexh->
                        <indexd->structs</indexd->
                        <indexd->arrays</indexd->
                        <indexd->tuples</indexd->
                    </index->
                    <index-><indexh->special-types</indexh->
                        <indexd->void</indexd->
                        <indexd->typename</indexd->
                    </index->
                    <indexd->implicit-conversions</indexd->
                    <indexd->auto-specifier</indexd->
                    <indexd->typeof-and-baseof-specifiers</indexd->
                    <indexd->unnamed-types</indexd->
                </index->
                <index-><indexh->values</indexh->
                    <index-><indexh->inline-values</indexh->
                        <indexd->literals</indexd->
                        <indexd->constructors</indexd->
                    </index->
                    <index-><indexh->stored-values</indexh->
                        <indexd->variables</indexd-> <indexd->temporary-variables</indexd->
                    </index->
                    <indexd->left-and-right-values</indexd->
                </index->
                <index-><indexh->functions</indexh->
                    <indexd->function-definitions</indexd->
                    <indexd->reference-parameters</indexd->
                    <indexd->function-calls</indexd->
                    <indexd->unnamed-scopes</indexd->
                    <indexd->the-main-function</indexd->
                </index->
                <index-><indexh->templates</indexh->
                    <indexd->function-templates</indexd->
                    <indexd->struct-templates</indexd->
                    <indexd->abbreviated-template-syntax</indexd->
                    <indexd->template-constraints</indexd->
                </index->
                <indexd->const-qualifier</indexd->
                <indexd->symbol-aliases</indexd->
                <index-><indexh->statements</indexh->
                    <index-><indexh->selection</indexh->
                            <indexd->if-statement</indexd->
                            <indexd->match-statement</indexd->
                    </index->
                    <index-><indexh->iteration</indexh->
                        <indexd->for-loops</indexd->
                        <indexd->while-loops</indexd->
                        <indexd->continue-and-break-statements</indexd->
                        <indexd->once-statement</indexd->
                        <indexd->then-statement</indexd->
                    </index->
                    <index-><indexh->non-local-flow-control</indexh->
                        <indexd->return-statement</indexd->
                        <indexd->defer-statement</indexd->
                    </index->
                    <indexd->else-statement</indexd->
                </index->
                <index-><indexh->reflection</indexh->
                </index->
                <indexd->inline-glsl</indexd->
            </index->
            <index-><indexh->compilation</indexh->
                <indexd->modules</indexd->
                <indexd->compilation-phases-and-error-types</indexd->
                <indexd->global-initialization-order</indexd->
                <index-><indexh->runtime-performance</indexh->
                    <indexd->value-precomputation</indexd->
                    <indexd->branching-performance</indexd->
                </index->
            </index->
            <index-><indexh->core-module</indexh->
                <index-><indexh->operators</indexh->
                    <indexd->common-operators</indexd->
                    <indexd->assignment-operators</indexd->
                    <indexd->special-operators</indexd->
                    <indexd->arithmetic-exceptions</indexd->
                    <indexd->array-operations</indexd->
                </index->
            </index->
            <index-><indexh->standard-modules</indexh->
                <indexd->limits-module</indexd->
                <indexd->math-module</indexd->
                <indexd->bits-module</indexd->
                <indexd->types-module</indexd->
            </index->
            <indexd->quick-reference-tabs</indexd->
            <indexd->complete-examples</indexd->
        <indexh-></indexh->
    </index->
    </left->

    <right- id="main-right" class="hide-scrollbar">
        <!--------------------------------------------------------------------->
        <!-- Logo                                                            -->
        <!--------------------------------------------------------------------->
        <logo-top-></logo-top->
        <logo- style="background-image: url('Lux-logo.png');"></logo->

        <main-scroll->
            <!--------------------------------------------------------------------->
            <!-- Overview                                                        -->
            <!--------------------------------------------------------------------->
            <div style="margin-top: var(--main-padding-r);"></div>
            <h1 id="overview"></h1>
            <p>
                Lux is a <b>high level compiled shading language</b> with the aim of helping developers to efficiently write shaders without going through the tedious work of manually managing buffers and shaders.<br>
                It compiles to <b>GLSL 4.6</b>.
            </p>
            <p>The language is meant to be used alongside <b>Umbra</b>, the main programming language of the Lynx Engine, as it is highly compatible and interfacing shaders requires little to no effort.</p>
            <p>Lux is part of the <b>Lynx SDK</b>.</p>
            <p><a href="#quick-reference-tabs">Quick reference tabs</a></p>








            <!--------------------------------------------------------------------->
            <!-- Preprocessor                                                    -->
            <!--------------------------------------------------------------------->
            <h1 id="preprocessor"></h1>
            <p>
                The <b>preprocessing</b> phase <b>precedes</b> the code <b>compilation</b>.<br>
                It removes <a href="#comments">comments</a> and evaluates preprocessor directives and <a href="#line-continuation-token">line continuation tokens</a>.
            </p>
            <p>
                <b>Preprocessor directives</b> are special instructions that allow the <b>code</b> to be <b>programmatically modified</b>.<br>
                All the preprocessor directives are identified by the <code>#</code> character followed by their name and definition.<br>
                Each directive spans over a single, complete line of code.<br>
                Preprocessor directives are always case sensitive.
            </p>




            <!--------------------------------------------------------------------->
            <!-- Comments                                                        -->
            <!--------------------------------------------------------------------->
            <h1 id="comments"></h1>
            <p>
                <b>Comments</b> are <b>portions of code</b> that are <b>intentionally ignored</b>.<br>
                They can be used to provide informations or temporarily exclude lines of code.<br>
                Comments are allowed to contain any sequence of unicode characters of any length.<br>
            </p>
            <p>
                Single line comments start with <code>//</code> and end at the first newline character.<br>
                Multiline comments start with <code>/*</code> and end with <code>*/</code>
            </p>
            <p>Comments cannot be nested.</p>

            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        //<elm->Comment string</elm-><nl-></nl->
                        /*<elm->Comment string</elm->*/
                    </scroll-></code->
                </fill->
            </syntax->
            <example->
                <fill->
                    <label->1</label->
                    <code-><scroll->
                        <c->// Single line comment</c->

                        <c->/* Multi
                        line
                        comment */</c->
                    </scroll-></code->
                </fill->
            </example->
            <example->
                <fill->
                    <label->2</label->
                    <code-><scroll->
                        <c->/* Multi line /* Anorhter comment */ comment */
                        // Ok                             </c-><ce->// ^ Error, unexpected token "comment"</ce->
                    </scroll-></code->
                </fill->
            </example->




            <!--------------------------------------------------------------------->
            <!-- Include statement                                               -->
            <!--------------------------------------------------------------------->
            <h1 id="include-statement"></h1>
            <p>
                The <b>include statement</b> is used to <b>paste code</b> from other files.<br>
                Any existent file can be included, regardless of its contents or extension.<br>
                The path of the included file must be enclosed in <code>"</code><code>"</code> and can only contain alphanumeric characters and one of <code>.</code> <code>/</code> <code>-</code> <code>_</code>. //TODO <br>
                Both absolute and relative paths are supported.
            </p>
            <p>
                <code>*</code> (any sequence of characters) and <code>?</code> (any character) wildcards are supported.<br>
                Glob patterns that don't match any file are allowed and have no effect.
            </p>
            <p>
                <a href="#standard-modules">Standard modules</a> are included using the <code>&lt;</code><code>&gt;</code> characters.<br>
                The <a href="#core-module">core module</a> cannot be included.
            </p>
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        #include<space-></space->"<elm->absolute/path/to/file</elm->"<nl-></nl->
                        #include<space-></space->"./<elm->relative/path/to/file</elm->"<nl-></nl->
                        #include<space-></space->"<elm->relative/path/to/file</elm->"<nl-></nl->
                        #include<space-></space->&lt;<elm->standard module name</elm->&gt;<nl-></nl->
                    </scroll-></code->
                </fill->
            </syntax->
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <k->#include</k-> <s->"/home/Lynx/Lux/file.ilsh"</s->   <c->// Ok, absolute path</c->
                        <k->#include</k-> <s->"./file.ilsh"</s->                <c->// Ok, relative path</c->
                        <k->#include</k-> <s->"file.ilsh"</s->                  <c->// Ok, relative path</c->
                        <k->#include</k-> <s->"*.ilsh"</s->                     <c->// Ok, includes any file with ilsl extension in any include path</c->
                        <k->#include</k-> <s->&lt;math&gt;</s->                       <c->// Ok, includes the math standard module</c->

                        <c->//#include ./file.ilsh</c->                <ce->// Error, "" or &lt;&gt; are required</ce->
                        <c->//#include "./non_existent_file"</c->      <ce->// Error, non-glob patterns must exist</ce->
                        <c->//#include ""</c->                         <ce->// Error, file name not specified</ce->
                    </scroll-></code->
                </fill->
            </example->




            <!--------------------------------------------------------------------->
            <!-- Macros                                                          -->
            <!--------------------------------------------------------------------->
            <h1 id="macros"></h1>
            //TODO




            <!--------------------------------------------------------------------->
            <!-- Conditionals                                                    -->
            <!--------------------------------------------------------------------->
            <h1 id="conditionals"></h1>
            //TODO




            <!--------------------------------------------------------------------->
            <!-- Line continuation token                                         -->
            <!--------------------------------------------------------------------->
            <h1 id="line-continuation-token"></h1>
            <p>
                The <b>line continuation token</b> can be used to <b>merge multiple lines</b> and allow single line <a href="#comments">comments</a>, preprocessor directives and multi character <a href="#tokens">tokens</a> to be written across multiple lines.<br>
                It consists of a <code>\</code> immediatly followed by a newline character.
            </p>
            <p>
                Line continuation tokens can be used inside comments or other preprocessor directives, but cannot be nested.
            </p>

            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        \<nl-></nl->
                    </scroll-></code->
                </fill->
            </syntax->

            <example->
                <fill->
                    <label->1</label->
                    <code-><scroll->
                        <c->// single line comment</c->\
                        <c->on two lines</c->

                        <c->// #include "path/to/file"</c->
                        <k->#include</k-> <s->"pat</s->\
                        <s->h/to/file</s->\
                        <s->"</s->

                        <c->// void function() {
                        //   uint var = 0, b = 0;
                        //   var += b;
                        // }</c->
                        <t->vo</t->\
                        <t->id</t-> <f->fun</f->\
                        <f->ction</f->() {
                        <t->uint</t-> va\
                        r = <k->0</k->, b = <k->0</k->;
                        v\
                        ar +\
                        = <k->b</k->;
                        }
                    </scroll-></code->
                </fill->
            </example->
            <example->
                <fill->
                    <label->2</label->
                    <code-><scroll->
                        <ce->// Error, unexpected token "\"</ce->
                        <c->//void ma\\

                        //in(){}</c->
                        <ce->// Error,  unexpected token "in"</ce->
                        </scroll-></code->
                </fill->
            </example->








            <!--------------------------------------------------------------------->
            <!-- Language                                                        -->
            <!--------------------------------------------------------------------->
            <h1 id="language"></h1>







            <!--------------------------------------------------------------------->
            <!-- Language concepts                                               -->
            <!--------------------------------------------------------------------->
            <h1 id="language-concepts"></h1>




            <!--------------------------------------------------------------------->
            <!-- Character set                                                   -->
            <!--------------------------------------------------------------------->
            <h1 id="character-set"></h1>
            <p>
                After the <a href="#preprocessor">preprocessing phase</a>, only a <b>small number</b> of <b>characters</b> are left.<br>
                These characters <b>compose the <a href="#tokens">tokens</a></b> that are used in the compilation phase.<br>
                Any unknown character generates a syntactic error. //TODO LINK
            </p>
            <p>
                The allowed characters are:
            </p>
            <p>
                <code>a</code> <code>b</code> <code>c</code> <code>d</code> <code>e</code> <code>f</code> <code>g</code> <code>h</code> <code>i</code> <code>j</code> <code>k</code> <code>l</code> <code>m</code>
                <code>n</code> <code>o</code> <code>p</code> <code>q</code> <code>r</code> <code>s</code> <code>t</code> <code>u</code> <code>v</code> <code>w</code> <code>x</code> <code>y</code> <code>z</code><br>
                <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> <code>K</code> <code>L</code> <code>M</code>
                <code>N</code> <code>O</code> <code>P</code> <code>Q</code> <code>R</code> <code>S</code> <code>T</code> <code>U</code> <code>V</code> <code>W</code> <code>X</code> <code>Y</code> <code>Z</code><br>
                <code>0</code> <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>8</code> <code>9</code> <code>_</code><br>
                <code>!</code> <code>$</code> <code>%</code> <code>&</code> <code>(</code> <code>)</code> <code>*</code> <code>+</code> <code>-</code> <code>/</code> <code>:</code> <code>&lt;</code> <code>=</code> <code>&gt;</code> <code>?</code> <code>@</code> <code>^</code> <code>`</code> <code>|</code> <code>~</code> <br>
                <code>;</code> <code>{</code> <code>}</code> <code>[</code> <code>]</code> <code>.</code><br>
                <code>space</code> <code>tab</code> <code>newline</code>
            </p>
            <p>
                String <a href="#literals">literals</a> can contain any unicode character. They are converted to allowed characters during the compilation phase.<br>
                Carriage return characters are ignored.
            </p>




            <!--------------------------------------------------------------------->
            <!-- Tokens                                                          -->
            <!--------------------------------------------------------------------->
            <h1 id="tokens"></h1>
            <p>
                <b>Tokens</b> are <b>sequences</b> of <b>characters</b> that follow specific patterns.<br>
                Any semantic element is made of one or more tokens.
            </p>
            <p>
                A token ends when a character that isn't present in its pattern is encountered. Tokens can also be divided by any number of whitespace characters, newlines, and <a href="#comments">comments</a>.<br>
                Longer tokens always take precedence over shorter ones.<br>
                Tokens that aren't defined or part of the language generate a compile time error. //TODO LINK
            </p>
            <p>
                All tokens are case sensitive, with the only exception of hexadecimal <a href="#literals">literals</a>.<br>
                Newlines and whitespace characters are not tokens.
            </p>


            <div class="table-container"><table>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th style="text-align: center;" colspan="4">Pattern</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="line-height: 80px;" class="nowrap" rowspan="2"><a href="#keywords">Keyword</a></td>
                        <td class="center" colspan="2">
                            <a href="#namespaces">                  <code><w->namespace</w-></code></a>
                            <a href="#enums">                       <code><w->enum</w-></code></a>
                            <a href="#structs">                     <code><w->struct</w-></code></a>
                            <a href="#auto-specifier">              <code><t->auto</t-></code></a>
                            <a href="#typeof-and-baseof-specifiers"><code><t->typeof</t-></code></a>
                            <a href="#typeof-and-baseof-specifiers"><code><t->baseof</t-></code></a>
                            <a href="#const-qualifier">             <code><t->const</t-></code></a>
                            <a href="#symbol-aliases">              <code><w->alias</w-></code></a>
                            <a href="#modules">                     <code><w->import</w-></code></a>
                            <a href="#templates">                   <code><w->template</w-></code></a>
                            <a href="#templates">                   <code><w->when</w-></code></a>
                        </td>
                        <td class="center" colspan="2">
                            <a href="#if-statement">                 <code><w->if</w-></code></a>
                            <a href="#match-statement">              <code><w->match</w-></code></a>
                            <a href="#for-loops">                    <code><w->for</w-></code></a>
                            <a href="#while-loops">                  <code><w->while</w-></code></a>
                            <a href="#while-loops">                  <code><w->do</w-></code></a>
                            <a href="#continue-and-break-statements"><code><w->continue</w-></code></a>
                            <a href="#continue-and-break-statements"><code><w->break</w-></code></a>
                            <a href="#once-statement">               <code><w->once</w-></code></a>
                            <a href="#then-statement">               <code><w->then</w-></code></a>
                            <a href="#else-statement">               <code><w->else</w-></code></a>
                            <a href="#return-statement">             <code><w->return</w-></code></a>
                            <a href="#defer-statement">              <code><w->defer</w-></code></a>
                        </td>
                    </tr>
                    <tr>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wide-lines" width="50%" colspan="2">
                            <elm-><code>(</code><code>)</code></elm->
                            <a href="#scopes-and-symbols"><elm-><code>{</code><code>}</code></elm-></a>
                            <a href="#for-loops"><code>:</code></a>
                        </td>
                        <td class="center" width="50%" colspan="2">
                            <a href="#statements"><code>,</code></a>
                            <a href="#statements"><code>;</code></a>
                            <a href="#scopes-and-symbols"><code>.</code></a>
                        </td>
                    </tr>
                    <tr>
                        <td style="line-height: 80px;" class="nowrap"><a href="#literals">Literal</a></td>
                        <td class="left" colspan="4">
                            Any sequence of characters with pattern
                            <code><sg->[</sg-><s->0</s-><sr->-</sr-><s->9</s-><sg->][</sg-><s->a</s-><sr->-</sr-><s->zA</s-><sr->-</sr-><s->Z</s-><s->_</s-><sg->]</sg-><sr->*</sr-><sg->(</sg-><sr->\</sr-><s->.</s-><sg->[</sg-><s->a</s-><sr->-</sr-><s->zA</s-><sr->-</sr-><s->Z</s-><s->_</s-><sg->]</sg-><sr->*</sr-><sg->)</sg-><sr->?</sr-></code>
                        </td>
                    </tr>
                    <tr>
                        <td style="line-height: 80px;" class="nowrap"><a href="#syntax-specific-tokens">Syntax specific token</a></td>
                        <td class="center" colspan="2">
                            <a href="#temporary-variables"><code>$</code></a>
                            <a href="#templates"><elm-><code>&lt;</code><code>&gt;</code></elm-></a>
                            <a href="#arrays"><elm-><code>[</code><code>]</code></elm-></a>
                        </td>
                        <td class="center" colspan="2">
                            <a href="#reference-parameters"><code>&</code></a>
                            <a href="#abbreviated-template-syntax"><code>?</code></a>
                        </td>
                    </tr>
                    <tr>
                        <td style="line-height: 80px;" class="nowrap"><a href="#identifiers">Identifier</a></td>
                        <td class="left" colspan="5">
                            Any sequence of characters with pattern
                            <code><sg->[</sg-><s->a</s-><sr->-</sr-><s->zA</s-><sr->-</sr-><s->Z_</s-><sg->][</sg-><s->a</s-><sr->-</sr-><s->zA</s-><sr->-</sr-><s->Z_0</s-><sr->-</sr-><s->9</s-><sg->]</sg-><sr->*</sr-></code>
                            or
                            <code><sg->[</sg-><s->!$%&()*+</s-><sr->\</sr-><s->-/:&lt;=&gt;?@^`|~;{}</s-><sr->\</sr-><s->[</s-><sr->\</sr-><s->]</s-><sr->\</sr-><s->.</s-><sg->]</sg-><sr->+</sr-></code>
                            that isn't a <a href="#keywords">keyword</a>
                        </td>
                    </tr>
                </tbody>
            </table></div>



            <!--------------------------------------------------------------------->
            <!-- keywords                                                        -->
            <!--------------------------------------------------------------------->
            <h1 id="keywords"></h1>
            <p>
                <b>Keywords</b> are <b>built-in <a href="#tpkens">tokens</a></b> that perform hard coded actions or have <b>special meaning</b>.<br>
                The language defines a total of 21 alphanumeric keywords and 13 symbolic keywrods.<br>
                Their usage is detailedly explained in their respective sections.
            </p>
            <ul>
                <li>Semantic keywords</li>
                <ul>
                    <li><a href="#namespaces">                  <code><w->namespace</w-></code></a> - Declares a <a href="#namespaces">namespace</a>                                           </li>
                    <li><a href="#enums">                       <code><w->enum</w-></code></a>      - Declares an <a href="#enums">enum</a>                                                    </li>
                    <li><a href="#structs">                     <code><w->struct</w-></code></a>    - Declares a <a href="#structs">struct</a>                                                 </li>
                    <li><a href="#auto-specifier">              <code><t->auto</t-></code></a>      - Automatic <a href="#types">type</a>                                                      </li>
                    <li><a href="#typeof-and-baseof-specifiers"><code><t->typeof</t-></code></a>    - Retrieves the <a href="#types">type</a> of a <a href="#symbols">symbol</a>               </li>
                    <li><a href="#typeof-and-baseof-specifiers"><code><t->baseof</t-></code></a>    - Retrieves the <a href="#primitive-types">base type</a> of a <a href="#symbols">symbol</a></li>
                    <li><a href="#const-qualifier">             <code><t->const</t-></code></a>     - Declares a <a href="#symbols">symbol</a> as <a href="#const-specifier">const</a>         </li>
                    <li><a href="#symbol-aliases">              <code><w->alias</w-></code></a>     - Creates an <a href="#aliases">alias</a> of a <a href="#symbols">symbol</a>               </li>
                    <li><a href="#modules">                     <code><w->import</w-></code></a>    - Imports a <a href="#modules">module</a>                                                  </li>
                    <li><a href="#templates">                   <code><w->template</w-></code></a>  - Declares a <a href="#templates">template</a>                                             </li>
                    <li><a href="#templates">                   <code><w->when</w-></code></a>      - Specifies a <a href="#template-constraints">template constraint</a>                      </li>
                </ul><br>
                <li>Flow control keywords</li>
                <ul>
                    <li><a href="#if-statement">                 <code><w->if</w-></code></a>       - Changes execution path based on one <a href="#bool-type">condition</a>                                                    </li>
                    <li><a href="#match-statement">              <code><w->match</w-></code></a>    - Changes execution path based on multiple <a href="#bool-type">conditions</a>                                              </li>
                    <li><a href="#for-loops">                    <code><w->for</w-></code></a>      - Runs the code an arbitrary number of times                                                                                </li>
                    <li><a href="#while-loops">                  <code><w->while</w-></code></a>    - Runs the code until a condition is no longer true                                                                         </li>
                    <li><a href="#while-loops">                  <code><w->do</w-></code></a>       - Used with <a href="#while-loops">while</a> to check the <a href="#bool-type">condition</a> after having ran the code      </li>
                    <li><a href="#continue-and-break-statements"><code><w->continue</w-></code></a> - Skips an arbitrary number of iterations                                                                                   </li>
                    <li><a href="#continue-and-break-statements"><code><w->break</w-></code></a>    - Exits an arbitrary number of innermost <a href="#iteration">loops</a>                                                     </li>
                    <li><a href="#once-statement">               <code><w->once</w-></code></a>     - Runs the code only in the first iteration of a <a href="#iteration">loop</a>                                              </li>
                    <li><a href="#then-statement">               <code><w->then</w-></code></a>     - Runs the code if the immediatly preceeding <a href="#iteration">loop</a> ran all the iterations                           </li>
                    <li><a href="#else-statement">               <code><w->else</w-></code></a>     - Runs the code if the <a href="#bool-type">condition</a> of the immediatly preceeding <a href="#for-loops">for</a>, <a href="#while-loops">while</a> or <a href="#if-statement">if</a> was <code><k->false</k-></code></li>
                    <li><a href="#return-statement">             <code><w->return</w-></code></a>   - Returns the execution to the <a href="#functions">caller function-calls</a>                                               </li>
                    <li><a href="#defer-statement">              <code><w->defer</w-></code></a>    - Runs the code right before the first <a href="#return-statement"><code><w->return</w-></code></a> statement is encountered</li>
                </ul><br>
                <li>Containers</li>
                <ul>
                    <li><elm-><code>(</code><code>)</code></elm->                       - Groups an <a href="#statements">expression, or encloses a list of <a href="#function-parameters">parameters</a></li>
                    <li><a href="#scopes"><elm-><code>{</code><code>}</code></elm-></a> - Declares a new <a href="#scopes">scope</a></li>
                    <li><a href="#arrays"><elm-><code>[</code><code>]</code></elm-></a> - Declares an <a href="#arrays">array</a>, or accesses the elements of an <a href="#arrays">array</a> (see <a href="#name-resolution">name resolution</a>)</li>
                </ul><br>
                <li>Separators</li>
                <ul>
                    <li><a href="#statements"><code>,</code></a>- Separates 2 or more <a href="#statements">expressions</a></li>
                    <li><a href="#statements"><code>;</code></a>- Defines the end of a <a href="#statements">statement</a></li>
                </ul><br>
                <li>Other</li>
                <ul>
                    <li><a href="#name-resolution"><code>.</code></a>- Part of the <a href="#name-resolution">name resolution</a></li>
                    <li><td class="center" width="20%"><a href="#for-loops"><code>:</code></a></td>- Part of the <a href="#for-loops">for each</a> loop syntax</li>
                </ul>
            </ul>
            <p>
                <a href="#keywords">Keywords</a> cannot be <a href="#name-shadowing">shadowed</a> like <a href="#identifiers">identifiers</a>.<br>
                Attempting to do so generates a syntactic error. //TODO LINK
            </p>


            <!--------------------------------------------------------------------->
            <!-- Literals                                                        -->
            <!--------------------------------------------------------------------->
            <h1 id="literal-tokens"></h1>
            <p>
                <b>Literals</b> are a <b>special type</b> of <a href="#tokens"><b>token</b></a>, as they can contain both alphanumeric characters and <code>.</code>.<br>
                Their usage and syntax are explained in <a href="#literals">Literals</a>.
            </p>


            <!--------------------------------------------------------------------->
            <!-- Syntax specific tokens                                          -->
            <!--------------------------------------------------------------------->
            <h1 id="syntax-specific-tokens"></h1>
            <p>
                <b>Syntax specific tokens</b> are <a href="#tokens">tokens</a> that only have meaning when <b>combined</b> with other <a href="#keywords"><b>keywords</b></a>.<br>
                <a href="#identifiers">Identifiers</a> can use the same <a href="#tokens">token</a>.<br>
                When active, they always take precedence over <a href="#identifiers">identifiers</a>.
            </p>
            <ul>
                <li>
                    <a href="#reference-parameters"><code>&</code></a> - Declares a <a href="#functions">function parameter</a> as <a href="#reference-parameters">reference</a>.<br>
                    When used before a <a href="#functions">function parameter</a> name.<br><br>
                </li>
                <li>
                    <a href="#templates"><code>?</code></a> - <a href="#abbreviated-template-syntax">Abbreviated template syntax</a>.<br>
                    When used before the <a href="#types">type</a> of a <a href="#functions">function parameter</a>.<br><br>
                </li>
                <li>
                    <a href="#temporary-variables"><code>$</code></a> - References a <a href="#temporary-variables">temporary variable</a><br>
                    When used before a <a href="#integral-types"><code><t->ulong</t-></code></a> <a href="#literals">literal</a>.<br><br>
                </li>
                <li>
                    <a href="#arrays"><elm-><code>[</code><code>]</code></elm-></a> - States that the corresponding <a href="#arrays">array</a> of a <a href="#types">type</a> must be used.<br>
                    When used after the <a href="#types">type</a> of a declaration or the name of a <a href="#constructors">constructor</a>.<br><br>
                </li>
                <li>
                    <elm-><code>&lt;</code><code>&gt;</code></elm->  - Part of a <a href="#templates">template declaration</a>, or part of the the <a href="#name-resolution">name resolution</a> of <a href="#generated-functions">generated functions</a>.<br>
                    When used after the <a href="#templates"><code><w->template</w-></code></a> keyword or after the name of a <a href="#function-templates">function template</a>.
                </li>
            </ul>


            <!--------------------------------------------------------------------->
            <!-- Identifiers                                                     -->
            <!--------------------------------------------------------------------->
            <h1 id="identifiers"></h1>
            <p>
                <b>Identifiers</b> are used to <b>name and reference <a href="#symbols">symbols</a></b>.<br>
                An identifier can be
                alphanumeric (<code><sg->[</sg-><s->a</s-><sr->-</sr-><s->zA</s-><sr->-</sr-><s->Z_</s-><sg->][</sg-><s->a</s-><sr->-</sr-><s->zA</s-><sr->-</sr-><s->Z_0</s-><sr->-</sr-><s->9</s-><sg->]</sg-><sr->*</sr-></code>)
                or symbolic (<code><sg->[</sg-><s->!$%&()*+</s-><sr->\</sr-><s->-/:&lt;=&gt;?@^`|~;{}</s-><sr->\</sr-><s->[</s-><sr->\</sr-><s->]</s-><sr->\</sr-><s->.</s-><sg->]</sg-><sr->+</sr-></code>).
            </p>
            <p>
                All identifiers must be unique to their <a href="#scopes">scope</a>.<br>
                Declaring more than one <a href="#symbols">symbol</a> with the same identifier in the same <a href="#scopes">scope</a> is a semantic error.<br> //TODO LINK
                Identifiers can be shadowed. This is explained in <a href="#name-shadowing">Name shadowing</a>.
            </p>




            <!--------------------------------------------------------------------->
            <!-- Semantic elements                                               -->
            <!--------------------------------------------------------------------->
            <h1 id="semantic-elements"></h1>
            <p>
                <b>Semantic elements</b> are <b>sequences</b> of one or more <a href="#tokens"><b>tokens</b> that follow specific patterns defined by the syntax of the language.<br>
                They define the contents and interface of the <a href="#modules">module</a>.
            </p>



            <!--------------------------------------------------------------------->
            <!-- Symbols                                                         -->
            <!--------------------------------------------------------------------->
            <h1 id="symbols"></h1>
            <p>
                Certain <b>semantic elements</b> can be <b>referenced</b> to retrieve their value or obtain additional informations. These elements are called <b>symbols</b>.<br>
                Symbols are referenced through their <a href="#name-resolution">name</a>.<br>
                <a href="#unnamed-types">Unnamed types</a> are also symbols.
            </p>
            <ul>
                <li>Unreferenceable elements</li>
                <ul>
                    <li><a href="#literals">Literals</a></li>
                    <li><a href="#constructors">Constructors</a></li>
                    <li><a href="#inline-glsl">Inline GLSL</a></li>
                </ul>
                <li>Symbols</li>
                <ul>
                    <li><a href="#variables">Variables</a></li>
                    <li><a href="#temporary-variables">Temporary variables</a></li>
                    <li><a href="#namespaces">Namespaces</a></li>
                    <li><a href="#structs">Structs</a></li>
                    <li><a href="#structs">Struct members</a></li>
                    <li><a href="#enums">Enums</a></li>
                    <li><a href="#enums">Enum elements</a></li>
                    <li><a href="#functions">Functions</a></li>
                    <li><a href="#function-templates">Function templates</a></li>
                    <li><a href="#function-templates">Generated functions</a></li>
                    <li><a href="#functions">Function parameters</a></li>
                    <li><a href="#arrays">Array elements</a></li>
                </ul>
            </ul>




            <!--------------------------------------------------------------------->
            <!-- Scopes                                                          -->
            <!--------------------------------------------------------------------->
            <h1 id="scopes"></h1>
            <p>
                <b>Scopes</b> define which <a href="#symbols"><b>symbols</b></a> the code can <b>reference</b> and their local, relative and complete <a href="#name-resolution">names</a>.<br>
                Any portion of code enclosed in <code>{</code><code>}</code> defines a new scope. The only exception is the <b><a href="#modules">module</a> scope</b> which contains
                all the <a href="#symbols">symbols</a> and scopes declared in the <a href="#modules">module</a>. It can be referenced using the <code>module</code> identifier.<br>
            </p>
            <p>
                Each scope can only contain certain types of <a href="#symbols">symbols</a>:
            </p>

            <div class="table-1-container">
                <div class="table-container table-1-left-container"><table class="table-1-left">
                    <tr style="height: 80px;"><th class="medium">Scope / Can contain</th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--fg-text)" href="#modules">       Module       </a></th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--fg-text)" href="#namespaces">    Namespace    </a></th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--fg-text)" href="#enums">         Enum         </a></th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--fg-text)" href="#structs">       Struct       </a></th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--fg-text)" href="#functions">     Function     </a></th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--fg-text)" href="#unnamed-scopes">Unnamed scope</a></th></tr>
                    <tr style="height: 80px;"><th class="medium"><a style="color: var(--fg-text)" href="#statements">    Statement    </a></th></tr>
                </table></div>
                <div class="table-container table-1-right-container"><table class="table-1-right">
                    <tr style="height: 80px;">
                        <td><a style="color: var(--fg-text)" href="#namespaces">    Namespace       </a></td>
                        <td><a style="color: var(--fg-text)" href="#enums">         Enum            </a></td>
                        <td><a style="color: var(--fg-text)" href="#structs">       Struct          </a></td>
                        <td><a style="color: var(--fg-text)" href="#functions">     Function        </a></td>
                        <td><a style="color: var(--fg-text)" href="#unnamed-scopes">Unnamed<br>scope</a></td>
                        <td><a style="color: var(--fg-text)" href="#statements">    Statement       </a></td>
                        <td><a style="color: var(--fg-text)" href="#variables">     Variable        </a></td>
                        <td><a style="color: var(--fg-text)" href="#symbol-aliases">Symbol alias    </a></td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y nobefore" colspan="2">Inherited from the enclosing scope</td>
                        <td class="table-1-n"></td>
                        <td class="table-1-y nobefore" colspan="2">Inherited from the enclosing scope</td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-y"></td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-y"></td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                    </tr>
                    <tr style="height: 80px;">
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-n"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                        <td class="table-1-y"></td>
                    </tr>
                </table></div>
            </div>




            <!--------------------------------------------------------------------->
            <!-- Name resolution                                                 -->
            <!--------------------------------------------------------------------->
            <h1 id="name-resolution"></h1>
            <p>
                <a href="#symbols">Symbols</a> are referenced through their name.<br>
                A <b>name</b> is the list of all the <a href="#identifiers">identifiers</a> of the <b>enclosing <a href="#scopes">scopes</a></b>
                and the <a href="#identifiers">identifier</a> of the <a href="#symbols"><b>symbol</b></a> separated by <b><code>.</code> tokens</b>, starting from the outermost.<br>
                The name can start from any of the enclosing <a href="#scopes">scopes</a>.<br>
                If the enclosing <a href="#scopes">scopes</a> are omitted, the <a href="#symbols">symbol</a> <a href="#identifiers">identifier</a> is searched in the current <a href="#scopes">scope</a>.
            </p>
            <p>
                Names that start from the <a href="#modules">module</a> <a href="#scopes">scope</a> are called complete names.<br>
                Names that omit the enclosing <a href="#scopes">scopes</a> are called local names.<br>
                Other names are called relative names.
            </p>
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <c->// Complete name: module</c->


                        <c->// Complete name: module.s</c->
                        <c->// Local name: s</c->
                        <w->namespace</w-> s {
                            <c->// Absolute name: module.s.fun</c->
                            <c->// Relative names: s.fun</c->
                            <c->// Local name: fun</c->
                            <t->void</t-> <f->fun</f->(<t->uint</t-> <a->n</a->) {
                                <c->//        ^</c->
                                <c->// Absolute name: module.s.fun.n</c->
                                <c->// Relative names: s.fun.n, fun.n</c->
                                <c->// Local name: n</c->
                            }
                        }

                        <w->namespace</w-> {
                            <c->// No complete name</c->
                            <c->// No relative names</c->
                            <c->// Local name: n</c->
                            <t->uint</t-> n;
                        }
                    </scroll-></code->
                </fill->
            </example->


            <!--------------------------------------------------------------------->
            <!-- Indices                                                         -->
            <!--------------------------------------------------------------------->
            <h1 id="indices"></h1>
            <p>
                <b>Elements</b> of <b><a href="#structs">structs</a></b>, <b><a href="#enums">enums</a></b> and <b><a href="#tuples">tuples</a></b> can be referenced through their <b>index</b>.<br>
                The index must be a <a href="#compile-time-values">compile time value</a>.
            </p>
            <p>
                <a href="#structs">Struct</a> and <a href="#tuples">tuple</a> indices are part of the <a href="#name-resolution">name resolution</a>.<br>
                <a href="#arrays">Array</a> elements are accessed using the <a href="#special-operators">scubrscipt operator</a>, which is not part of the <a href="#name-resolution">name resolution</a> but a function that can be called during runtime.
            </p>
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <k->struct</k-> s {
                            <t->double</t-> a;
                            <t->float</t->  b;
                        }
                        <k->enum</k-> e {
                            a, b;
                        }

                        <t->void</t-> <f->main</f->(){
                            (<t->int</t->, <t->float</t->) var1;
                            <k->var1</k->[<k->0</k->];                        <c->// Complete name: module.main.var1[0]</c->
                            <k->var1</k->[<k->var1</k->[<k->0</k->] <f->/</f-> <k->2</k->];              <c->// Complete name: module.main.var1[1]</c->

                            <t->s</t-> var2;
                            <k->var2</k->[<k->0</k->] <f->=</f-> <k->1</k->;                    <c->// Complete name: module.main.var2.a</c->
                            <k->var2</k->[<k->var1</k->[<k->1</k->] <f->-</f-> <k->var1</k->[<k->2</k->]] <f->=</f-> <k->1</k->;    <c->// Complete name: module.main.var2.b</c->

                            <t->e</t->[<k->0</k->];                           <c->// Complete name: module.e.a</c->
                        }
                    </scroll-></code->
                </fill->
            </example->


            <!--------------------------------------------------------------------->
            <!-- Generated symbols                                               -->
            <!--------------------------------------------------------------------->
            <h1 id="generated-symbols"></h1>
            <p>
                <a href="#functions"><b>Functions</b></a> and <a href="#structs">structs</a> generated by <a href="#templates">templates</a> are referenced using their <a href="#name-resolution">name</a>,
                followed by <elm-><code>&lt;</code><code>&gt;</code></elm-> tokens containing the types for which the <a href="#symbols">symbol</a> was instantiated.
            </p>
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <table>
                            <tr>
                                <td>
                                    <elm->name<sup>id</sup></elm-><span>&lt;</span><elm-><elm-><t->T0<sup>type</sup></t-></elm->, <elm-><t->...</t-></elm->, <elm-><t->Tn<sup>type</sup></t-></elm-></elm-><span>&gt;</span>
                                </td>
                            </tr>
                        </table>
                    </scroll-></code->
                </fill->
            </syntax->

            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <w->template</w-> &lt;<t->t</t->&gt; <f->f</f->(<t->t</t-> <a->a</a->, <t->t</t-> <a->b</a->) {
                            <k->return</k-> a;
                        }
                        <w->template</w-> &lt;<t->t</t->, <t->u</t->&gt; <w->struct</w-> s {
                            <t->t</t-> a;
                            <t->t</t-> b;
                        }

                        <t->void</t-> <f->main</f->(){
                            <t->s</t->&lt;<t->int</t->, <t->double</t->&gt; var;
                            s.a <f->=</f-> <f->f</f->&lt;<t->int</t->&gt(<k->0</k->);
                            s.b <f->=</f-> <f->f</f->&gt;<t->double</t->&gt;(<k->1</k->);
                        }
                    </scroll-></code->
                </fill->
            </example->


            <!--------------------------------------------------------------------->
            <!-- Name shadowing                                                  -->
            <!--------------------------------------------------------------------->
            <h1 id="name-shadowing"></h1>
            <p>
                The same <a href="#identifiers"><b>identifier</b></a> can be used to declare <b>multiple <a href="#symbols">symbols</a></b> in different <a href="#scopes">scopes</a>.<br>
                When the <a href="#scopes">scopes</a> are one inside another and the <a href="#identifiers">identifier</a> is used in relative or local <a href="#name-resolution">names</a>
                from one of the inner <a href="#scopes">scopes</a>, the innermost <a href="#symbols">symbol</a> takes precedence over the others.<br>
                This is known as <b>name shadowing</b>.
            </p>
            <p>
                <a href="#name-resolution">Absolute names</a> cannot be shadowed
            </p>
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <w->namespace</w-> s {
                            <c->// n references module.s.n</c->
                            <t->void</t-> <f->n</f->(<t->uint</t-> <a->n</a->) {
                                <c->// n references module.s.n.n</c->
                                <w->namespace</w-> {
                                    <t->float</t-> n;
                                    <c->// n references module.s.n.*unnamed*.n</c->
                                }
                            }
                        }
                    </scroll-></code->
                </fill->
            </example->




            <!--------------------------------------------------------------------->
            <!-- Undefined values                                                -->
            <!--------------------------------------------------------------------->
            <h1 id="undefined-values"></h1>
            <p>
                <b>Any unknown value</b> of any type is an <b>undefined value</b>.<br>
                The language can generate undefined values for a variety of reasons.<br>
                Such values are usually the result of errors that occurred during the execution of a <a href="#functions">function</a> and don't contain any useful information.<br>
                Uninitialized <a href="#variables">variables</a> also have undefined value.
            </p>
            <p>
                Generating undefined values doesn't stop the execution and is not signaled in any way, nor is it detectable.<br>
                The <a href="#modules">module</a> is responsible for preventing, discarding or documenting undefined values.
            </p>




            <!--------------------------------------------------------------------->
            <!-- Undefined behaviour                                             -->
            <!--------------------------------------------------------------------->
            <h1 id="undefined-behaviour"></h1>
            <p>
                Certain actions cause undefined behaviour.<br>
                <b>Undefined behaviour</b> means that the <b>code <a href="#compilation">compiles</a> with no erros</b>, but the <b>runtime behaviour is unknown</b> and anything could happen.<br>
                The <a href="#modules">module</a> could work just fine, or it could break and never run again. No one knows.
            </p>
            <p>
                As with <a href="#undefined-values">undefined values</a>, the <a href="#modules">module</a> is responsible for preventing or documenting undefined behaviours.
            </p>




            <!--------------------------------------------------------------------->
            <!-- Compile time values                                             -->
            <!--------------------------------------------------------------------->
            <h1 id="compile-time-values"></h1>
            <p>
                <b>Compile time values</b> are values that can be <b>calculated</b> during the <a href="#compilation"><b>compilation</b></a> phase.<br>
                Whether a value can be calculated or not depends on precise rules:
            </p>
            <ul>
                <li>It cannot depend on <a href="#functions">parameters</a> of the <a href="#the-main-function"><f->main</f-> function</a></li>
                <li>It cannot depend on </li>
            </ul>
            <p>
                A value <code>a</code> is said to depend on a value <code>b</code> if <code>b</code> is used in one of the preceeding function calls where <code>a</code> is passed as argument of a <a href="#reference-parameters">reference parameter</a>.

            </p>
            <p>
                Known special cases that generate constant values, such as <code>n <f->*</f-> <k->0</k-></code> or <code>n <f->-</f-> n</code>,
                are used by the compiler to <a href="#value-precomputation">optimize</a> the code, but for consistency reasons, they have no relevance in determining if a value is compile time or not.
            </p>




            <!--------------------------------------------------------------------->
            <!-- Namespaces                                                      -->
            <!--------------------------------------------------------------------->
            <h1 id="namespaces"></h1>
            <p>
                <b>Namespaces</b> are used to create <b>named scopes</b> which can contain
                <a href="#variables">variables</a>, <a href="#functions">functions</a>, <a href="#structs">structs</a>, <a href="#enums">enums</a> and <a href="#symbol-aliases">symbol aliases</a>.<br>
                They don't affect the runtime behaviour and can be declared in any scope.<br>
                Unnamed namespaces are allowed.
            </p>

            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        namespace<space-></space-><elm->name<sup>id</sup></elm-> { <elm->...</elm-> }
                        namespace { <elm->...</elm-> }
                    </scroll-></code->
                </fill->
            </syntax->
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <w->namespace</w-> a {
                            <t->int</t-> n = <k->4</k->;
                        }
                        <w->namespace</w-> {
                            <t->int</t-> n = <k->4</k->;
                        }

                        <t->int</t-> n2 = a.<k->n</k->;
                    </scroll-></code->
                </fill->
            </example->




            <!--------------------------------------------------------------------->
            <!-- Types                                                           -->
            <!--------------------------------------------------------------------->
            <h1 id="types"></h1>
            <p>
                <b>Data types</b> define how <b>values</b> are <b>interpreted</b> during runtime and how they can be used within expressions.<br>
            </p>
            <p>
                The Lux language is statically typed.<br>
                Every value has an associated type, regardless of it being a <a href="#left-and-right-values">right</a> or a <a href="#left-and-right-values">left value</a>.<br>
                The type of each value must be known at compile time, as there are no runtime type informations.
            </p>
            <p>
                There are no classes, strings, characters, matrices or vectors. The latter 2 are <a href="#symbol-aliases">aliases</a> of <a href="#arrays">array</a> types. See <a href="#standard-modules">Standard Modules</a>.
            </p>


            <!--------------------------------------------------------------------->
            <!-- Primitive types                                                 -->
            <!--------------------------------------------------------------------->
            <h1 id="primitive-types"></h1>
            <p>Lux features <b>7 primitive types</b>, which can be used to define more complex types such as structs, arrays, enums and tuples.</p>
            <p>
                These types are always defined and they act as if they were declared in the <a href="#core-module">core module</a>.<br>
                Primitive types are <b>not keywords</b> and can be shadowed like any other symbol.
            </p>
            <p>The primitive types are:</p>
            <div class="table-container"><table>
                <tr>
                    <th>Type name   </th>
                    <th>Size (bytes)</th>
                    <th>Value type  </th>
                </tr>
                <tr>
                    <td class="center"><code><t->uint</t-></code></td>
                    <td class="center">4</td>
                    <td rowspan="2">Unsigned integral number</td>
                </tr>
                <tr>
                    <td class="center"><code><t->ulong</t-></code></td>
                    <td class="center">8</td>
                </tr>
                <tr>
                    <td class="center"><code><t->int</t-></code></td>
                    <td class="center">4</td>
                    <td rowspan="2">Signed integral number</td>
                </tr>
                <tr>
                    <td class="center"><code><t->long</t-></code></td>
                    <td class="center">8</td>
                </tr>
                <tr>
                    <td class="center"><code><t->float</t-></code></td>
                    <td class="center">4</td>
                    <td rowspan="2">Floating point number</td>
                </tr>
                <tr>
                    <td class="center"><code><t->double</t-></code></td>
                    <td class="center">8</td>
                </tr>
                <tr>
                    <td class="center"><code><t->bool</t-></code></td>
                    <td class="center">4</td>
                    <td>Boolean value</td>
                </tr>
            </table></div>
            <p>
                All primitives types are convertible to each other. This is explained in detail in <a href="#implicit-conversions">Implicit conversions</a>.<br>
            </p>
            <p>
                See
                <a href="#literals">Literals</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Integral types                                                  -->
            <!--------------------------------------------------------------------->
            <h1 id="integral-types"></h1>
            <p>
                <code><t->int</t-></code>, <code><t->uint</t-></code>, <code><t->long</t-></code>, <code><t->ulong</t-></code>.<br>
                <b>Integral types</b> are used to <b>represent integers</b>.<br>
                Unsigned integers cannot represent negative numbers, but the maximum value is twice as high as their signed counterpart.
            </p>
            <p>
                All signed integral types use the Two's Complement to represent negative numbers.<br>
                Positive numbers and <code><k->0</k-></code> use the corresponding binary value in both signed and unsigned integral types.
            </p>
            <example->
                <fill->
                    <code- style="border-top-left-radius: var(--code-decoration-r);"><scroll->
                                                        <c->  1              31</c->
                                                        <c->sign           value</c->
                                                        <c-></c->  <t->int</t->
                                                        <sr-></sr-><s-></s->
                                                                         <c->32</c->
                                                                       <c->value</c->
                                                        <c-></c->  <t->uint</t->
                                                        <s-></s->
                        <c->  1                              63</c->
                        <c->sign                           value</c->
                        <c-></c->  <t->long</t->
                        <sr-></sr-><s-></s->
                                                         <c->64</c->
                                                       <c->value</c->
                        <c-></c->  <t->ulong</t->
                        <s-></s->
                    </scroll-></code->
                </fill->
            </example->
            <p>
                //TODO GL_EXT_shader_explicit_arithmetic_types_int64
            </p>


            <!--------------------------------------------------------------------->
            <!-- Floating point types                                            -->
            <!--------------------------------------------------------------------->
            <h1 id="floating-point-types"></h1>
            <p>
                <code><t->float</t-></code>, <code><t->double</t-></code>.<br>
                <b>Floating point types</b> are used to <b>approximate real numbers</b>.<br>
            </p>
            <p>
                Both floating point types are encoded according to the IEEE 754 Standard.<br>
                Positive and negative <code><k->inf</k-></code>, <code><k->nan</k-></code> and signed <code><k->0</k-></code> are all supported.<br>
                <code><k->+0</k-></code> and <code><k->-0</k-></code> are equal.
            </p>
            <example->
                <fill->
                    <code- style="border-top-left-radius: var(--code-decoration-r);"><scroll->
                                                        <c-> 1      8          23</c->
                                                        <c->sign exponent   mantissa</c->
                                                        <c-></c->  <t->float</t->
                                                        <sr-></sr-><sg-></sg-><s-></s->
                                                        <c->00000000000000000000000000000000</c->   <k->+0.0</k->
                                                        <c->10000000000000000000000000000000</c->   <k->-0.0</k->
                                                        <c->01111111100000000000000000000000</c->   <k->+inf</k->
                                                        <c->11111111100000000000000000000000</c->   <k->-inf</k->
                                                        <c->011111111&lt; not 0 &gt;</c->   <k->nan</k->
                                                        <c->111111111&lt; not 0 &gt;</c->   <k->nan</k->

                        <c-> 1      11                           52</c->
                        <c->sign  exponent                    mantissa</c->
                        <c-></c->  <t->double</t->
                        <sr-></sr-><sg-></sg-><s-></s->
                        <c->0000000000000000000000000000000000000000000000000000000000000000</c->   <k->+0.0</k->
                        <c->1000000000000000000000000000000000000000000000000000000000000000</c->   <k->-0.0</k->
                        <c->0111111110000000000000000000000000000000000000000000000000000000</c->   <k->+inf</k->
                        <c->1111111110000000000000000000000000000000000000000000000000000000</c->   <k->-inf</k->
                        <c->011111111&lt; not 0 &gt;</c->   <k->nan</k->
                        <c->111111111&lt; not 0 &gt;</c->   <k->nan</k->
                    </scroll-></code->
                </fill->
            </example->
            <p>
                <code><k->inf</k-></code> values are generated as required by the standard.<br>
                <code><k->nan</k-></code> values are not generated for consistency and performance reasons.
            </p>


            <!--------------------------------------------------------------------->
            <!-- Bool type                                                       -->
            <!--------------------------------------------------------------------->
            <h1 id="bool-type"></h1>
            <p>
                //TODO bools are used for conditions
            </p>


            <!--------------------------------------------------------------------->
            <!-- Enums                                                           -->
            <!--------------------------------------------------------------------->
            <h1 id="enums"></h1>
            <p>
                <b>Enums</b> are used to <b>name</b> and <b>group</b> literal <b>constants</b> of the same type.<br>
                The base type of the enum can be specified after its name and it must be one of the primitive types.<br>
                Elements are declared in the same way as variables, but neither the type nor the const qualifier are specified explicitly.<br>
                The initializer values are implicitly converted to the base type of the enum.
            </p>
            <syntax->
                <left->
                    <label-></label->
                    <code-><scroll->
                        enum<space-></space-><elm->name<sup>id</sup></elm-> : <elm-><t->T<sup>type</sup></t-> </elm-> { <elm2-><elm->element 0</elm->; <elm->...</elm->; <elm->element n</elm->;</elm2-> }
                        strict enum<space-></space-><elm->name<sup>id</sup></elm-> : <elm-><t->T<sup>type</sup></t-> </elm-> { <elm2-><elm->element 0</elm->; <elm->...</elm->; <elm->element n</elm->;</elm2-> }
                    </scroll-></code->
                </left->
                <right->
                    <label->Element syntax</label->
                    <code-><scroll->
                        <elm->name<sup>id</sup></elm-> = <elm-><t->T<sup>r</sup></t-></elm->
                    </scroll-></code->
                </right->
            </syntax->
            <p>
                Elements of integral enums which are not initizlied will have the value of the preceeding element + 1, or 0 if they are the first.<br>
                Elements of boolean and floating point enums must always be initialized.<br>
                Multiple elements can have the same value, but each element can only be declared once.<br>
                Enums with no elements are not allowed.
            </p>

            <example->
                <fill->
                    <label->1</label->
                    <code-><scroll->
                        <w->enum</w-> <t->e</t-> : <t->int</t-> {
                            a, b;              <c->// Ok, a = 0, b = 1</c->
                            c = <k->-266250</k->;       <c->// Ok, c = -266250</c->
                            d, e = 0;          <c->// Ok, d = -266249, e = 0</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <example->
                <fill->
                    <label->2</label->
                    <code-><scroll->
                        <w->enum</w-> <t->c</t-> : <t->double</t-> {
                            pi = <k->3.14159</k->;      <c->// Ok</c->
                            e  = <k->2.71828</k->;      <c->// Ok</c->
                            <c->//phi;             </c-><ce->// Error, uninitialized non-integral enum value</ce->
                        }

                        <t->void</t-> <f->main</f->(){
                            <t->c</t-> a = <k->c.pi</k->;       <c->// Ok</c->
                            <t->c</t-> b = <k->3.14159</k->;     <c->// Ok</c->
                            <t->int</t-> c = <k->a</k->;         <c->// Ok, implicit conversion from c (double) to int</c->
                        }
                    </scroll-></code->
                </fill->
            </example->

            <p>
                By default, all enums behave exactly as their base types, much like a <a href="#symbol-aliases">symbol alias</a>.<br>
                When implicit conversions from other types are undesirable, enums can be declared as <code><w->strict</w-></code>.<br>
                Strict enums only allow values of the same enum, but can still be implicitly converted to other types.
            </p>

            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <w->strict enum</w-> <t->c</t-> : <t->double</t-> {
                            pi  = <k->3.14159</k->;
                            e   = <k->2.71828</k->;
                            phi = <k->1.61803</k->;
                        }

                        <t->void</t-> <f->main</f->(){
                            <t->c</t-> a = <k->c.phi</k->;      <c->// Ok</c->
                            <c->//c b = 1.61803;   </c-><ce->// Error, cannot convert from double to strict enum</ce->
                            <t->int</t-> c = <k->a</k->;         <c->// Ok, implicit conversion from c (double) to int</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#primitive-types">Primitive types</a>,
                <a href="#implicit-conversions">Implicit conversions</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Aggregate types                                                 -->
            <!--------------------------------------------------------------------->
            <h1 id="aggregate-types"></h1>


            <!--------------------------------------------------------------------->
            <!-- Structs                                                         -->
            <!--------------------------------------------------------------------->
            <h1 id="structs"></h1>
            <p>
                <b>Structs</b> are used to <b>group values</b> of <b>different types</b>.<br>
                The members are declared in the same way as variables, and they can be of any type, including enums, arrays and other structures.<br>
                They cannot be <a href="#const-qualifier"><code><t->const</t-></code></a> and cannot have initializer values.<br>
                Like variables, uninitialized members cannot be used within expressions. Struct values must also be fully initialized before they can be used in expressions.
            </p>
            <p>
                Empty structs are allowed.<br>
                Member access is explained in <a href="#special-operators">Special operators</a>.<br>
                Struct initializer values are explained in <a href="#constructors">Constructors</a>.
            </p>
            <syntax->
                <left->
                    <label-></label->
                    <code-><scroll->
                        struct<space-></space-><elm->name<sup>id</sup></elm-> { <elm2-><elm->member 0</elm->; <elm->...</elm->; <elm->member n</elm->;</elm2-> }
                        struct<space-></space-><elm->name<sup>id</sup></elm-> { }
                    </scroll-></code->
                </left->
                <right->
                    <label->Member syntax</label->
                    <code-><scroll->
                        <elm-><t->U<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->;
                    </scroll-></code->
                </right->
            </syntax->

            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <w->struct</w-> <t->idk</t-> {
                            <t->uint</t-> a, b;        <c->// Ok</c->
                            <t->double</t->[<k->4</k->] c;      <c->// Ok</c->
                            <c->//double const d; </c-><ce->// Error, struct members cannot be const</ce->
                        }
                        <t->void</t-> <f->main</f->(){
                            <t->idk</t-> var;

                            var.a = <k->4</k->;              <c->// Ok, var = (4, ?, ?)</c->
                            var.b = <k->var.a</k-> * <k->4</k->;      <c->// Ok, var = (4, 8, ?)</c->
                            <c->//var.b = var.c[0];     </c-><ce->// Error, var.c is uninitialized</ce->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#primitive-types">Primitive types</a>,
                <a href="#arrays">Arrays</a>,
                <a href="#enums">Enums</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Arrays                                                          -->
            <!--------------------------------------------------------------------->
            <h1 id="arrays"></h1>
            <p>
                <b>Arrays</b> can <b>aggregate values</b> of the <b>same type</b>.<br>
                Functions, parameters, right values, variables and struct member can all have array type.<br>
                Arrays can use any base type, including structs, enums and other arrays.<br>
                An array of arrays is called a multidimensional array. There is no limit to the number of dimensions an array can have.<br>
            </p>
            <p>
                Array declarations are identical to normal types, but <code>[</code><code>]</code> tokens follow the type, optionally enclosing an expression to specify the number of elements.<br>
                Arrays can be initialized using any expression of a type that can be implicitly converted.<br>
                If the <code>[</code><code>]</code> are left empty, the number of elements is determined by the inizializer value, which becomes required and must be an array <a href="#constructors">constructor</a>.
            </p>
            <p>
                Arrays cannot have 0 elements.<br>
                Element access is explained in <a href="#special-operators">Special operators</a>.<br>
                Array initializer values are explained in <a href="#constructors">Constructors</a>.
            </p>

            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <elm-><t->T</t-><sup>type</sup></elm->[<elm-><t->uint<sup>r</sup></t-></elm->]<space-></space-><elm->name<sup>id</sup></elm->;
                        <elm-><t->T</t-><sup>type</sup></elm->[] <elm->name<sup>id</sup></elm-> = <elm-><t->T[]<sup>r</sup></t-></elm->;
                    </scroll-></code->
                </fill->
            </syntax->

            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <t->uint</t->[<k->4</k->] <f->func</f->(<t->float</t->[<k->4</k->] n){
                            <w->if</w->(n[<k->3</k->]) <w->return</w-> n * <k->4</k->;
                            <w->else</w-> <w->return</w-> n[<k->0</k->];
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                There are no dynamic arrays.
            </p>
            <p>
                See
                <a href="#primitive-types">Primitive types</a>,
                <a href="#enums">Enums</a>,
                <a href="#implicit-conversions">Implicit conversions</a>,
                <a href="#constructors">Constructors</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Tuples                                                          -->
            <!--------------------------------------------------------------------->
            <h1 id="tuples"></h1>
            <p>
                <b>Tuples</b> are used to <b>group values</b> of <b>different types</b>.<br>
                The type of a tuple is the list of all the types of its elements. Any sequence of types enclosed in <code>(</code><code>)</code> is interpreted as a tuple type.<br>
                Differently from <a href="#structs">structs</a>, tuples don't need to be declared before being used and their elements aren't named.<br>
            </p>
            <p>
                The type of two tuples can only differ by the type and the order of their elements. If those are identical, the tuples have the same type.<br>
                Element access is explained in <a href="#special-operators">Special operators</a>.<br>
                Tuple initializer values are explained in <a href="#constructors">Constructors</a>.
            </p>
            <p>
                Tuples cannot have 0 elements.
            </p>

            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        (<elm-><elm-><t->T0<sup>type</sup></t-></elm->, <elm-><t->...<sup>type</sup></t-></elm->, <elm-><t->Tn<sup>type</sup></t-></elm-></elm->) <elm->name<sup>id</sup></elm->;
                    </scroll-></code->
                </fill->
            </syntax->
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        (<t->int</t->, <t->int</t->) <f->func</f->((<t->uint</t->, <t->bool</t->, <t->float</t->) <a->a</a->, <t->uint</t-> <a->b</a->){
                            <w->return</w-> (<k->0</k->, a[<k->1</k->] ? a[<k->0</k->] : b * a[<k->2</k->]);
                        };

                        <t->void</t-> <f->main</f->(){
                            (<t->int</t->) n = (<f->func</f->((<k->9</k->, <k->true</k->, <k->0.5</k->), <k->5</k->)[<k->1</k->]);
                        }
                    </scroll-></code->
                </fill->
            </example->


            <!--------------------------------------------------------------------->
            <!-- Special types                                                   -->
            <!--------------------------------------------------------------------->
            <h1 id="special-types"></h1>


            <!--------------------------------------------------------------------->
            <!-- Void                                                            -->
            <!--------------------------------------------------------------------->
            <h1 id="void"></h1>
            <p>
                The <code><t->void</t-></code> type is a special type. It is exclusively used to define <a href="#functions">functions</a> that don't return any value.<br>
                It can't store values like other types, but it can be used as value of <a href="#typenames">typename</a> type symbols.
            </p>


            <!--------------------------------------------------------------------->
            <!-- Typename                                                         -->
            <!--------------------------------------------------------------------->
            <h1 id="typename"></h1>
            <p>
                <b>Typenames</b> are special types that can <b>store</b> other <b>types</b>.<br>
                Typename values can be used anywhere where a type is required.
            </p>
            <p>
                All typename values must be known at compile time.<br>
                <code><t->typename</t-></code> is a valid value for typename types.<br>
                Typename constructors are allowed, as well as typename struct elements, typename tuple elements and typename arrays.
            </p>
            <example->
                <fill->
                    <label->1</label->
                    <code-><scroll->
                        <t->typename</t-> t1 = <t->typename</t->;   <c->// Ok</c->
                        <t->t1</t-> t2 = <t->int</t->;              <c->// Ok</c->

                        <t->t2</t-> <f->main</f->(){
                            <w->return</w-> <t->t2</t->(<k->6</k->);         <c->// Ok</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <example->
                <fill->
                    <label->2</label->
                    <code-><scroll->
                        <w->struct</w-> s {
                            <t->typename</t-> t; <c->// Ok</c->
                            <t->uint</t-> n;
                        }

                        <t->void</t-> <f->main</f->(<t->bool</t-> <a->b</a->){
                            <t->s</t-> var;                                     <c->// Ok</c->
                            var.<t->t</t-> = <t->float</t->;                             <c->// Ok</c->
                            (<t->typename</t->, <t->int</t->) tuple = (var.<t->t</t->, var.<t->t</t->(<k->5</k->)); <c->// Ok</c->
                            tuple[<k->0</k->] n;                                <c->// Ok</c->
                            <c->//typename[2](int, float)[b] var;</c-><ce->          // Error, the type depends on a runtime value</ce->
                        }
                    </scroll-></code->
                </fill->
            </example->


            <!--------------------------------------------------------------------->
            <!-- Implicit conversions                                            -->
            <!--------------------------------------------------------------------->
            <h1 id="implicit-conversions"></h1>
            <p>
                <b>Implicit conversions</b> are performed when an <b>expression</b> of the <b>incorrect type</b> is used in place of the expected one.<br>
                This includes anything whose syntax requires an expression.<br>
                Conversions are not allowed in <a href="#function-templates">function template</a> calls and inizializer values of <a href="auto-specifier">auto</a> symbols.
            </p>
            <p>
                Primitive types are all implicitly convertible between them.<br>
                The result of conversions follow these rules:
                //TODO FIX NEGATIVE VALUE TO UNSIGNED
            </p>
            <div class="table-container"><table>
                <!-- integer -->
                    <tr>
                        <th colspan="2">From / To</th>
                        <th><t->uint</t-></th>
                        <th><t->int</t-></th>
                        <th><t->ulong</t-></th>
                        <th><t->long</t-></th>
                        <th><t->float</t-></th>
                        <th><t->double</t-></th>
                        <th><t->bool</t-></th>
                    </tr>

                    <tr class="even">
                        <th rowspan="13"><t->uint</t-><br><br><t->int</t-><br><br><t->ulong</t-><br><br><t->long</t-></th>
                        <th><range-val->== <k->-9223372036854775808</k-><br><range-var->limits.long.min</range-var-></range-val-></th>
                        <td class="center wrap conv-cell-m" rowspan="5">Overflows to n % limits.uint.<k->max</k-></td>
                        <td class="center wrap conv-cell-n" rowspan="3">Undefined</td>
                        <td class="center wrap conv-cell-m" rowspan="5">Overflows to n % limits.ulong.<k->max</k-></td>
                        <td class="center wrap conv-cell-y" rowspan="11">Correct result</td>
                        <td class="center wrap conv-cell-m" rowspan="4">Conversions are not symmetric</td>
                        <td class="center wrap conv-cell-m" rowspan="2">Conversions are not symmetric</td>
                        <td class="center wrap conv-cell-y" rowspan="5"><k->true</k-></td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&lt; <k->-9007199254740992</k-><br><range-var->limits.double.min_precise_int</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&lt; <k->-2147483648</k-><br><range-var->limits.int.min</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-y" rowspan="8">Correctly rounded</td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&lt; <k->-16777216</k-><br><range-var->limits.float.min_precise_int</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-y" rowspan="5">Correct result</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&lt; <k->0</k-><br><range-var-></range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->== <k->0</k-><br><range-var-></range-var-></range-val-></th>
                        <td class="center wrap conv-cell-y" rowspan="4">Correct result</td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-y" rowspan="8">Correct result</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-y"><k->false</k-></td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&gt; <k->0</k-><br><range-var-></range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-y" rowspan="7"><k->true</k-></td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&gt; <k->+16777216</k-><br><range-var->limits.float.max_precise_int</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-m" rowspan="6">Conversions are not symmetric</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&gt; <k->+2147483647</k-><br><range-var->limits.int.max</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&gt; <k->+4294967295</k-><br><range-var->limits.uint.max</range-var-></range-val-></th>
                        <td class="center wrap conv-cell-m" rowspan="4">Overflows to n % limits.uint.<k->max</k-></td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&gt; <k->+9007199254740992</k-><br><range-var->limits.double.max_precise_int</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-m" rowspan="3">Conversions are not symmetric</td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&gt; <k->+9223372036854775807</k-><br><range-var->limits.long.max</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->== <k->+18446744073709551615</k-><br><range-var->limits.ulong.max</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>


                <!-- floating point -->
                    <tr>
                        <th colspan="2">From / To</th>
                        <th><t->uint</t-></th>
                        <th><t->int</t-></th>
                        <th><t->ulong</t-></th>
                        <th><t->long</t-></th>
                        <th><t->float</t-></th>
                        <th><t->double</t-></th>
                        <th><t->bool</t-></th>
                    </tr>

                    <tr class="even">
                        <th rowspan="16"><t->float</t-><br><br><t->double</t-></th>
                        <th><range-val->== <k->-inf</k-><br><range-var-></range-var-></range-val-></th>
                        <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
                        <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
                        <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
                        <td class="center wrap conv-cell-n" rowspan="4">Undefined</td>
                        <td class="center wrap conv-cell-y" rowspan="1">Correct result</td>
                        <td class="center wrap conv-cell-y" rowspan="1">Correct result</td>
                        <td class="center wrap conv-cell-y" rowspan="6"><k->true</k-></td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->== <k->-1.7976931348623157081e+308</k-><br><range-var->limits.double.min</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
                        <td class="center wrap conv-cell-y" rowspan="13">Correctly rounded</td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&lt; <k->-3.4028234663852885981e+38</k-><br><range-var->limits.float.min</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&lt; <k->-9223372036854775808.0</k-><br><range-var->limits.long.min</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-y" rowspan="9">Correctly rounded</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&lt; <k->-2147483648.0</k-><br><range-var->limits.int.min</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-y" rowspan="6">Correctly rounded</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&lt; <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
                        <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->== <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
                        <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-y" rowspan="5">Correctly rounded</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-y" rowspan="1"><k->false</k-></td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&gt; <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-y" rowspan="8"><k->true</k-></td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&gt; <k->+2147483647.0</k-><br><range-var->limits.int.max</range-var-></range-val-></th>
                        <td class="center wrap conv-cell-n" rowspan="8">Undefined</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&gt; <k->+4294967297.0</k-><br><range-var->limits.uint.max</range-var-></range-val-></th>
                        <td class="center wrap conv-cell-n" rowspan="7">Undefined</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&gt; <k->+9223372036854775807.0</k-><br><range-var->limits.long.max</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&gt; <k->+18446744073709551615.0</k-><br><range-var->limits.ulong.max</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->&gt; <k->+3.4028234663852885981e+38</k-><br><range-var->limits.float.max</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->== <k->+1.7976931348623157081e+308</k-><br><range-var->limits.double.max</range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val->== <k->+inf</k-><br><range-var-></range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-y" rowspan="2">Correct result</td>
                        <td class="center wrap conv-cell-y" rowspan="2">Correct result</td>
                        <fake-td></fake-td>
                    </tr>
                    <tr class="even">
                        <fake-td></fake-td>
                        <th><range-val-><f->isnan</f->(n)<br><range-var-></range-var-></range-val-></th>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <fake-td></fake-td>
                        <td class="center wrap conv-cell-n" rowspan="1">undefined</td>
                    </tr>

                <!-- bool -->
                    <tr>
                        <th colspan="2">From / To</th>
                        <th><t->uint</t-></th>
                        <th><t->int</t-></th>
                        <th><t->ulong</t-></th>
                        <th><t->long</t-></th>
                        <th><t->float</t-></th>
                        <th><t->double</t-></th>
                        <th><t->bool</t-></th>
                    </tr>

                    <tr>
                        <th rowspan="2"><t->bool</t-></th>
                        <th class="nowrap small"><k->false</k-></th>
                        <td class="center wrap conv-cell-y"><k->0</k-></td>
                        <td class="center wrap conv-cell-y"><k->0</k-></td>
                        <td class="center wrap conv-cell-y"><k->0</k-></td>
                        <td class="center wrap conv-cell-y"><k->0</k-></td>
                        <td class="center wrap conv-cell-y"><k->0.0</k-></td>
                        <td class="center wrap conv-cell-y"><k->0.0</k-></td>
                        <td class="center wrap conv-cell-y"><k->false</k-></td>
                    </tr>
                    <tr>
                        <fake-td></fake-td>
                        <th class="nowrap small"><k->true</k-></th>
                        <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
                        <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
                        <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
                        <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
                        <td class="center wrap conv-cell-y"><k->1.0</k-></td>
                        <td class="center wrap conv-cell-y"><k->1.0</k-></td>
                        <td class="center wrap conv-cell-y"><k->true</k-></td>
                    </tr>
            </table></div>
            <p>
                Additional conversions for non-primitive types are described as follows:
            </p>
            <div class="table-container"><table>
                <tr>
                    <th>From      </th>
                    <th>To        </th>
                    <th>Behaviour </th>
                </tr>

                <!-- Element to array ---------------------------------------------------------->
                <tr>
                    <td class="center" rowspan="2"><code><t->T</t-></code></td>
                    <td class="center"><code><t->T[n]</t-></code></td>
                    <td rowspan="2">
                        Each element of the result is initialized with the value of the source expression.<br>
                        <code><t->T</t-></code> must be implicitly convertible to <code><t->U</t-></code>.
                    </td>
                </tr>
                <tr>
                    <td class="center"><code><t->U[n]</t-></code></td>
                </tr>

                <!-- Tuple to tuple, struct or array ------------------------------------------->
                <tr>
                    <td class="center" rowspan="3"><code><t->(T0, ..., Tn)</t-></code></td>
                    <td class="center"><code><t->(U0, ..., Un)</t-></code></td>
                    <td rowspan="3">
                        Each element of the result is initialized with the corresponding value of the source tuple.<br>
                        The type of each element of the source tuple must be implicitly convertible to the type of the destination element.
                    </td>
                </tr>
                <tr>
                    <td class="center">
                        <template->when(types.is_struct(U))</template-><br>
                        <code><t->U</t-></code>
                    </td>
                </tr>
                <tr>
                    <td class="center">
                        <code><t->U[n]</t-></code>
                    </td>
                </tr>

                <!-- Array to array and array to bool ------------------------------------------>
                <tr>
                    <td class="center" rowspan="2">
                        <template->when(!types.is_struct(T) && !types.is_tuple(T))</template-><br>
                        <code><t->T[n]</t-></code>
                    </td>
                    <td class="center"><code><t->U[n]</t-></code></td>
                    <td>
                        Each element of the result is initialized with the corresponding value of the source array.<br>
                        <code><t->T</t-></code> must be implicitly convertible to <code><t->U</t-></code>.
                    </td>
                </tr>
                <tr>
                    <td class="center"><code><t->bool</t-></code></td>
                    <td>Evaluated as <code><k->true</k-></code> if all the elements of the source array converted to <code><t->bool</t-></code> evaluate as <code><k->true</k-></code>, <code><k->false</k-></code> otherwise</td>
                </tr>
            </table></div>
            <p>
                When values of different primitive types are used with <a href="#operators">operators</a> which require values of the same type, implicit conversions are performed in orer to avoid data loss.<br>
                Which values are converted depends on the rank of their type.<br>
                All the types with low rank are converted to the type of highest rank.
            </p>
            <p>
                The only exceptions are the bitwise OR, XOR and AND, where no implicit conversions are performed and the result has the same type of the first operand.<br>
                In assignment operators, the result is converted back to the type of the first operand.
            </p>
            <div class="table-container"><table>
                <tr>
                    <th>Type</th>
                    <th>Rank</th>
                </tr>
                <tr>
                    <td class="center"><code><t->bool</t-></code></td>
                    <td class="center">1</td>
                </tr>
                <tr>
                    <td class="center"><code><t->int</t-></code></td>
                    <td class="center">2</td>
                </tr>
                <tr>
                    <td class="center"><code><t->uint</t-></code></td>
                    <td class="center">3</td>
                </tr>
                <tr>
                    <td class="center"><code><t->long</t-></code></td>
                    <td class="center">4</td>
                </tr>
                <tr>
                    <td class="center"><code><t->ulong</t-></code></td>
                    <td class="center">5</td>
                </tr>
                <tr>
                    <td class="center"><code><t->float</t-></code></td>
                    <td class="center">6</td>
                </tr>
                <tr>
                    <td class="center"><code><t->double</t-></code></td>
                    <td class="center">7</td>
                </tr>
            </table></div>
            //TODO add example

            <p>
                See
                <a href="#arrays">Arrays</a>,
                <a href="#constructors">Constructors</a>,
                <a href="#standard-modules">Standard modules</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Auto specifier                                                  -->
            <!--------------------------------------------------------------------->
            <h1 id="auto-specifier"></h1>
            <p>
                The <b><code><t->auto</t-></code></b> specifier can be <b>used as</b> a <b>type</b> when declaring a variable or function.<br>
                The actual type of the symbol will be the same as the expression used to initialize it.<br>
            </p>
            <p>
                <code><t->auto</t-></code> is not allowed in struct members declarations and function parameters.<br>
                The type of <code><t->auto</t-></code> functions is determined by their return value.<br>
                There is no <code><t->auto</t-></code> constructor.
            </p>
            <p>
                <code><t->const</t-></code> <code><t->auto</t-></code> symbols are allowed.//TODO auto functions that depend on an argument value
            </p>

            <example->
                <fill->
                    <label->1</label->
                    <code-><scroll->
                        <t->auto</t-> <f->func</f->(){
                            <w->return</w-> <k->true</k->;        <c->// func has type bool</c->
                        }

                        <t->auto</t-> <f->main</f->(){
                            <t->auto</t-> a = <k->2</k->;         <c->// a has type ulong</c->
                            <t->auto</t-> b = <k->5.4</k-> * <k->a</k->;   <c->// b has type double</c->
                            <t->auto</t-> c = <f->func</f->();    <c->// c has type bool</c->
                            <c->// No return statement, main has type void</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <example->
                <fill->
                    <label->2</label->
                    <code-><scroll->
                        <t->auto</t-> a = int[<k->4</k->](<k->1</k->, <k->1</k->, <k->0</k->, <k->1</k->);     <c->// Ok, a has type int[4] and value (1, 1, 0, 1)</c->
                        <t->auto</t-> <t->const</t-> b = !<k->a</k->;               <c->// Ok, b has type bool[4] and value (false, false, true, false)</c->
                    </scroll-></code->
                </fill->
            </example->
            <p>
                If the return type of an <code><t->auto</t-></code> function depends on parameters or variables, these must have compile time known value.
            </p>
            <p>
                See
                <a href="#functions">Functions</a>,
                <a href="#return-statement">Return statement</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Typeof and baseof specifiers                                    -->
            <!--------------------------------------------------------------------->
            <h1 id="typeof-and-baseof-specifiers"></h1>
            <p>
                The <b><code><t->typeof</t-></code></b> and <b><code><t->baseof</t-></code></b> specifiers are used in the same way as <code><t->auto</t-></code>, but the <b>type</b> is defined by the <b>expression</b> that is passed to them.<br>
                <code><t->typeof</t-></code> returns the type of the expression, <code><t->baseof</t-></code> returns its base type.<br>
                Using <code><t->typeof</t-></code> on a type returns <code><t->typename</t-></code>.
                //TODO make them typename functions
            </p>
            <p>
                <code><t->baseof</t-></code> can only be used on <a href="#arrays">arrays</a>, <a href="#enums">enums</a> and <a href="#primitive-types">primitive types</a>.<br>
                The base type of primitive types is the type itself.<br>
                The expressions passed to those specifiers are always evaluated at compile time.
            </p>
            <p>
                The <code><t->typeof</t-></code> and <code><t->baseof</t-></code> specifiers can be used as constructors.<br>
                Circular dependencies are a semantic error.
            </p>

            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        typeof(<elm-><t->T</t-><sup>r</sup></elm->)
                        baseof(<elm-><t->T</t-><sup>r</sup></elm->)
                    </scroll-></code->
                </fill->
            </syntax->
            <example->
                <fill->
                    <label->1</label->
                    <code-><scroll->
                        <t->auto</t-> <f->f</f->(){}                  <c->// f has type void</c->

                        <t->typeof</t->(<f->f</f->()) <f->main</f->(){         <c->// main has type void</c->
                            <t->int</t-> a[<k->2</k->] = (<k->1</k->, <k->2</k->);      <c->// a has type int[2]</c->
                            <t->typeof</t->(<k->a</k->) b = <k->a</k-> * <k->2</k->;    <c->// b has type int[2]</c->
                            <t->baseof</t->(<k->a</k->) c = <k->a</k->[<k->0</k->];     <c->// c has type int</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <example->
                <fill->
                    <label->2</label->
                    <code-><scroll->
                        <c->//typeof(b) a;</c->  <ce->//Error, circular dependency</ce->
                        <c->//typeof(a) b;</c->  <ce->//Error, circular dependency</ce->
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#functions">Functions</a>,
                <a href="#return-statement">Return statement</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Unnamed types                                                   -->
            <!--------------------------------------------------------------------->
            <h1 id="unnamed-types"></h1>
            <p>
                When a type doesn't have to be explicitly referenced more than once, <b>unnamed types</b> can be used to define both the type and the symbol in the same construct.<br>
                Similarly to the C syntax, the type name is not specified and the definition is used as type of the symbol.
            </p>
            <p>
                Any symbol defined inside those types can still be referenced through the <code><t->typeof</t-></code> and <code><t->auto</t-></code> specifiers.<br>
                Members of unnamed structs can be accessed using the member access operator, like normal structs.<br>
                Defining an unnamed type without also declaring the symbol is allowed, but it generates a warning as the type and anything declared in it would be unaccessible.
            </p>

            <syntax->
                <left->
                    <label-> - Struct</label->
                    <code-><scroll->
                        struct { <elm2-><elm->member 0</elm->; <elm->...</elm->; <elm->member n</elm->;</elm2-> } <elm->symbol definition</elm->;
                        struct { } <elm->symbol definition</elm->;
                    </scroll-></code->
                </left->
                <right->
                    <label->Member syntax</label->
                    <code-><scroll->
                        <elm-><t->U<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->;
                    </scroll-></code->
                </right->
            </syntax->
            <syntax->
                <left->
                    <label-> - Enum</label->
                    <code-><scroll->
                        enum : <elm-><t->T<sup>type</sup></t-></elm-> { <elm2-><elm->element 0</elm->; <elm->...</elm->; <elm->element n</elm->;</elm2-> } <elm->symbol definition</elm->;
                        strict enum : <elm-><t->T<sup>type</sup></t-></elm-> { <elm2-><elm->element 0</elm->; <elm->...</elm->; <elm->element n</elm->;</elm2-> } <elm->symbol definition</elm->;
                    </scroll-></code->
                </left->
                <right->
                    <label->Element syntax</label->
                    <code-><scroll->
                        <elm->name<sup>id</sup></elm-> = <elm-><t->T<sup>r</sup></t-></elm->
                    </scroll-></code->
                </right->
            </syntax->

            <example->
                <fill->
                    <label->1</label->
                    <code-><scroll->
                        <w->strict enum</w-> : <t->bool</t-> {
                            on = <k->true</k->;
                            off = <k->false</k->;
                        } grasses;

                        <t->void</t-> <f->main</f->(){
                            module.grasses = <t->typeof</t->(grasses).<k->on</k->;
                        }
                    </scroll-></code->
                </fill->
            </example->
            <example->
                <fill->
                    <label->2</label->
                    <code-><scroll->
                        <w->struct</w-> {
                            <t->uint</t-> a, b;
                            <w->enum</w-> : int {
                                idk1;
                                idk2;
                            } c;
                        } <f->fun</f->(){
                            <w->return</w-> (<k->1</k->, <k->1</k->, <k->0</k->); <c->// Ok, unnamed struct constructor</c->
                        }

                        <t->void</t-> <f->main</f->(){
                            <t->auto</t-> var = fun();

                            <c->// Both are allowed</c->
                            var.c = <t->typeof</t->(var.c).<k->idk1</k->;
                            var.c = <t->typeof</t->(<t->typeof</t->(<f->fun</f->).c).<k->idk2</k->;

                            <t->typeof</t->(var.a) a = <k->0</k->;
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#typeof-and-baseof-specifiers">Typeof and baseof specifiers</a>,
                <a href="#auto-specifier">Auto specifier</a>
            </p>





            <!--------------------------------------------------------------------->
            <!-- Values                                                          -->
            <!--------------------------------------------------------------------->
            <h1 id="values"></h1>


            <!--------------------------------------------------------------------->
            <!-- Inline values                                                   -->
            <!--------------------------------------------------------------------->
            <h1 id="inline-values"></h1>
            <p>
                Inline values are <a href="#right-and-left-values">r-values</a> that are explicitly created and used within a single <a href="#runtime-statements">runtime statement</a>.<br>
                They can be <a href="#literals">Literals</a> or <a href="#constructors">Constructors</a>.
            </p>


            <!--------------------------------------------------------------------->
            <!-- Literals                                                        -->
            <!--------------------------------------------------------------------->
            <h1 id="literals"></h1>
            <p>
                <b>Literals</b> are used to <b>create</b> compile time known <b><a href="#left-and-right-values">r-values</a></b>.<br>
                The type of the value is determined by the way it is represented in the source code, and it can only be of <code><t->ulong</t-></code>, <code><t->double</t-></code> or <code><t->bool</t-></code> type.<br>
                Literals can be used in place of any expression of compatible type. Their value is converted following the <a href="#implicit-conversions">implicit conversions</a> rules.
            </p>
            <p>
                Base prefixes can be used to specify the numerical base of the value.<br>
                The decimal prefix is optional.<br>
                Hexadecimal literals are case insensitive, leading zeroes and trailing decimal zeroes are ignored.<br>
                Unary <a href="#common-operators"><code>+</code></a> and <a href="#common-operators"><code>-</code></a> operators are not part of the literal.
            </p>
            <p>
                Literals are not sequences of tokens like other semantic elements, but a category of tokens.<br>
                Regex syntax is used to describe their pattern:
            </p>
            <div class="table-container"><table>
                <tr>
                    <th>Type/Base</th>
                    <th>Hexadecimal (hex)</th>
                    <th>Decimal (dec)</th>
                    <th>Octal (oct)</th>
                    <th>Binary (bin)</th>
                </tr>
                <tr>
                    <th rowspan="2"><t->ulong</t-></th>
                    <td class="center"><code>0x([0-9a-z_]+)</code></td>
                    <td class="center"><code>(0d)?([0-9][0-9_]+)</code></td>
                    <td class="center"><code>0o([0-7_]+)</code></td>
                    <td class="center"><code>0b([01_]+)</code></td>
                </tr>
                <tr>
                    <fake-td></fake-td>
                    <td class="center" colspan="4"><code>inf|nan</code></td>
                    <fake-td></fake-td>
                    <fake-td></fake-td>
                    <fake-td></fake-td>
                </tr>
                <tr>
                    <th rowspan="2"><t->double</t-></th>
                    <td class="center"><code>0x([0-9a-z_]+)\.([0-9a-z_]+)</code></td>
                    <td class="center"><code>(0d)?([0-9][0-9_]*)\.([0-9_]+)</code></td>
                    <td class="center"><code>0o([0-7_]+)\.([0-7_]+)</code></td>
                    <td class="center"><code>0b([01_]+)\.([01_]+)</code></td>
                </tr>
                <tr>
                    <fake-td></fake-td>
                    <td class="center" colspan="4"><code>inf|nan</code></td>
                    <fake-td></fake-td>
                    <fake-td></fake-td>
                    <fake-td></fake-td>
                </tr>
                <tr>
                    <th><t->bool</t-></th>
                    <td class="center" colspan="4"><code>true|false</code></td>
                </tr>
            </table></div>
            <p>
                The special double literals <code><k->inf</k-></code> and <code><k->nan</k-></code> are correctly converted between <code><k->float</k-></code> and <code><k->double</k-></code>.<br>
                Converting them to other types has <b>undefined</b> result. See <a href="#implicit-conversions">Implicit conversions</a>.<br>
                Operations with those literals are explained in <a href="#operators">Operators</a>.
            </p>
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <t->int</t-> n = <k->4</k->;             <c->// Ok</c->
                        <t->bool</t-> b =<k-> true</k->;         <c->// Ok</c->
                        <t->float</t-> f1 = <k->0x0d.aAb4</k->;  <c->// Ok</c->
                        <t->float</t-> f2 = <k->inf</k->;        <c->// Ok</c->
                        <t->float</t-> f3 = <k->nan</k->;        <c->// Ok</c->
                        <c->float f4 = AAAB4;      </c-><ce->// Error, invalid decimal literal</ce->
                        <c->float f4 = 0o97;       </c-><ce->// Error, invalid octal literal</ce->
                        <c->float f4 = 0xAEGF;     </c-><ce->// Error, invalid hexadecimal literal</ce->
                    </scroll-></code->
                </fill->
            </example->
            <p>
                The <code>_</code> character can be used anywhere after the base prefix of numerical literals to separate digits and improve readability.<br>
                Decimal literals without base prefix cannot start with <code>_</code>.
            </p>
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <t->int</t-> n = <k->395_935</k->;             <c->// Ok</c->
                        <t->int</t-> n = <k->654_3_21___</k->;         <c->// Ok, doesn't make sense but it is allowed</c->
                        <t->int</t-> n = <k->0x_32_A4_FF_E2</k->;      <c->// Ok</c->
                        <c->//int n = _123_456;</c->          <ce->// Error, undeclared identifier "_123_456".</ce->
                    </scroll-></code->
                </fill->
            </example->
            <p>
                There are no literal suffixes and no <code><t->float</t-></code>, <code><t->uint</t-></code> or <code><t->int</t-></code> literals.<br>
                To create inline values of specific types, <a href="#constructors">Constructors</a> are used.
            </p>


            <!--------------------------------------------------------------------->
            <!-- Constructors                                                    -->
            <!--------------------------------------------------------------------->
            <h1 id="constructors"></h1>
            <p>
                <b>Constructors</b> are used to <b>create <a href="#left-and-right-values">r-values</a></b> of the <b>specified type</b>.<br>
                Their syntax is the same as <a href="#functions">functions</a>, but the name is the type of the returned r-value and the parameters are the expressions used to initiaze it.<br>
                Constructors can be used in place of any expression of compatible type. Their return value is converted following the <a href="#implicit-conversions">implicit conversions</a> rules.
            </p>
            <p>
                The values used to create the r-value are also implicitly converted.<br>
                Flattening constructors is not allowed.<br>
                <a href="typeof-and-baseof-specifiers"><code><w->typeof</w-></code></a> and <a href="typeof-and-baseof-specifiers"><code><w->baseof</w-></code></a> can be used as types.
            </p>

            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <c->/* <a href="#primitive-types"><c->Primitive types</c-></a> and <a href="#enums"><c->enums</c-></a> */</c->  <elm-><t->T<sup>type</sup></t-></elm->(<elm-><t->T<sup>r</sup></t-></elm->)
                        <c->/* <a href="#structs"><c->Structs</c-></a> */</c->                    <elm-><t->T<sup>type</sup></t-></elm->(<elm-><elm-><t->member type 0<sup>r</sup></t-></elm->, <elm-><t->...<sup>r</sup></t-></elm->, <elm-><t->member type n<sup>r</sup></t-></elm-></elm->)
                        <c->/* <a href="#arrays"><c->Arrays</c-></a> */</c->                     <elm-><t->T<sup>type</sup></t-></elm->[<elm-><t->u32<sup>r</sup></t-></elm->](<elm-><elm-><t->T<sup>r</sup></t-></elm->, <elm-><t->...<sup>r</sup></t-></elm->, <elm-><t->T<sup>r</sup></t-></elm-></elm->)
                        <c->/* <a href="#tuples"><c->Tuples</c-></a> */</c->                     (<elm-><elm-><t->T0<sup>type</sup></t-></elm->, <elm-><t->...<sup>type</sup></t-></elm->, <elm-><t->Tn<sup>type</sup></t-></elm-></elm->)(<elm-><elm-><t->T0<sup>r</sup></t-></elm->, <elm-><t->...<sup>r</sup></t-></elm->, <elm-><t->Tn<sup>r</sup></t-></elm-></elm->)
                    </scroll-></code->
                </fill->
            </syntax->
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <w->struct</w-> s {
                            <t->int</t-> a;
                            <t->float</t-> b;
                        };
                        <t->void</t-> <f->f</f->(<t->s</t-> <a->a</a->, (<t->int</t->[<k->2</k->], <t->s</t->) <a->b</a->){}

                        <t->void</t-> <f->main</f->(){
                            <f->f</f->(<t->s</t->(<k->5</k->, <k->1</k->), (<t->int</t->[<k->2</k->], <t->s</t->)(<t->int</t->[<k->2</k->](<k->1</k->, <k->2</k->), <t->s</t->(<k->6</k->, <k->0.5</k->)));
                            <t->int</t-> n = <t->baseof</t->(<f->f</f->.b[<k->0</k->])(<k->8</k->);
                        }
                    </scroll-></code->
                </fill->
            </example->





            <!--------------------------------------------------------------------->
            <!-- Stored values                                                   -->
            <!--------------------------------------------------------------------->
            <h1 id="stored-values"></h1>
            <p>
                <b>Stored values</b> are <b>named memory locations</b> that can contain values of the specified type.<br>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Variables                                                       -->
            <!--------------------------------------------------------------------->
            <h1 id="variables"></h1>
            <p>
                A <b>variable declaration</b> consists of the <b>type</b>, the <b>name</b> and an optional <code>=</code> followed by an <b>expression</b> of a compatible type that is used to inizialize it.<br>
                If an initializer expression is not specified, the value of the variable is undefined.<br>
                Evaluating an expression that can result in an undefined value is considered a logical error and will stop the compilation process.<br>
                Variables with undefined value can still be passed to reference arguments of functions or be assigned a value.
            </b>
            <p>
                Differently from other symbols, each stored value <b>must be declared</b> before being used. Variables <b>cannot be redeclared</b> and their <b>type cannot be changed</b> after the declaration.<br>
                Multiple variables of the same type can be declared in one instruction.
            </p>

            <syntax->
                <left->
                    <label- class="nobefore">Declaration syntax</label->
                    <code-><scroll->
                        <elm-><t->T<sup>type</sup></t-></elm-><space-></space-><elm2-><elm->varaible 0</elm->, <elm->...</elm->, <elm->varaible n</elm-></elm2->;
                    </scroll-></code->
                </left->
                <right->
                    <label->Variable syntax</label->
                    <code-><scroll->
                        <c->/* Undefined value   */</c->  <elm->name<sup>id</sup></elm->
                        <c->/* Inizializer value */</c->  <elm->name<sup>id</sup></elm-> = <elm-><t->T<sup>r</sup></t-></elm->
                        <c->/* <a href="#const-qualifier"><c->Const qualifier</c-></a>   */</c->  const <space></space><elm->name<sup>id</sup></elm-> = <elm-><t->T<sup>r</sup></t-></elm->
                    </scroll-></code->
                </right->
            </syntax->
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <t->uint</t-> variable = <k->0</k->;         <c->// Ok, variable has value 0</c->
                        <t->float</t-> nya = <k->5</k-> + <k->variable</k->;  <c->// Ok, nya ha value 5.0</c->
                        <t->bool</t-> var$, var3 = nya;     <c->// Ok, var$ has undefined value, var2 has value true</c->
                        <c->//b var_2 = var$;          </c-><ce->// Error. The syntax is correct, but undefined values (var$) cannot be used inside expressions</ce->
                    </scroll-></code->
                </fill->
            </example->
            <p>
                There are no pointers or reference variables.
            </p>
            <p>
                See
                <a href="#types">Types</a>,
                <a href="#expressions">Expressions</a>,
                <a href="#functions">Functions</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Temporary variables                                             -->
            <!--------------------------------------------------------------------->
            <h1 id="temporary-variables"></h1>
            <p>
                <b>Temporary variables</b> are a special set of identifiers that have <b>dynamic type</b> and don't need to be declared.<br>
                These identifiers are meant to replace local variables whose only purpose is holding values that don't need to be used more than a few times.<br>
                A temporary variable is identified by the <code>$</code> character followed by an arbitrary number of decimal digits, which denote its name.<br>
            </p>
            <p>
                They are always <b>function-level scoped</b> and cannot be used outside of function definitions.<br>
                There is no limit to the number of temporary variables a function can use.<br>
            </p>
            <p>
                The type of a temporary variable can only be changed through direct assignments (<a href="#assignments"><code>=</code></a>) and it must be unambiguously determinable in order for the variable to be evaulated.
                This means that reading the value of a temporary variable after one or more branches that may have assigned it different types is not allowed and will result in a semantic error.<br>
                Using temporary variables whose type is undefined will also result in a semantic error.
            </p>
            <p>They act as normal variables for anything else.</p>

            <example->
                <fill->
                    <label->1</label->
                    <code-><scroll->
                        <t->uint3</t-> <f->fun1</f->(<t->bool</t-> <a->arg</a->) {
                            $0 = <k->1</k->;             <c->// Ok, $0 has type uint and value 1</c->
                            <c->//$2 = $1;          </c-><ce->// Error, $1 has undefined type</ce->

                            <t->uint3</t-> vec = { <k->0</k->, <k->1</k->, <k->2</k-> };
                            $2 = <k->true</k->;          <c->// Ok, $2 has type b and value true</c->
                            $2 = <k->vec</k->;           <c->// Ok, $2 has type uint3 and value { 0, 1, 2 }</c->
                        }

                        <t->void</t-> <f->fun2</f->(<t->uint3</t-> <a->vec</a->) {
                            <c->//uint var = $2;    </c-><ce->// Error, $2 has undefined type. fun2.$2 has nothing to do with fun1.$2</ce->
                        }

                        <c->//uint var = $9;        </c-><ce->// Error, temporary variables cannot be used outside of functions</ce->
                    </scroll-></code->
                </fill->
            </example->
            <example->
                <fill->
                    <label->2</label->
                    <code-><scroll->
                        <t->void</t-> <f->fun3</f->(<t->bool</t-> <a->arg</a->, <t->uint2</t-> &<a->ref</a->) {
                            <w->if</w->(arg) $0 = <k->1</k->;             <c->// $0 has type uint</c->
                            <w->else</w->    $0 = { <k->0</k->, <k->1</k-> };      <c->// $0 has type uint2</c->
                            <c->//ref = $0;                 </c-><ce->// Error, cannot determine the type of $0</ce->
                            $0 = ref;                   <c->// Ok, $0 has type uint2 and the same value as ref</c->

                            <w->if</w->(arg) $0 = { <k->0</k->, <k->1</k-> };      <c->// $0 has type uint2</c->
                            <w->else</w->    $0 = { <k->2</k->, <k->3</k-> };      <c->// $0 has type uint2</c->
                            ref = <k->$0</k->;                   <c->// Ok, $0 has type uint2</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#types">Types</a>,
                <a href="#selection">Selection</a>,
                <a href="#functions">Functions</a>,
                <a href="#expressions">Expressions</a>
            </p>




            <!--------------------------------------------------------------------->
            <!-- Left and right values                                           -->
            <!--------------------------------------------------------------------->
            <h1 id="left-and-right-values"></h1>
            <p>
                Values can either be left values or right values.<br>
                <b>Memory locations</b> which allow <b>changes</b> to their <b>value</b> after being declared are considered <b>left values</b>.<br>
                Any other value is a <b>right value</b>.
            </p>
            <div class="table-container"><table>
                <tr>
                    <th>Left values</th>
                    <th>Right values</th>
                </tr>
                <tr>
                    <td>Non-const <a href="#functions">parameters</a> and <a href="#reference-parameters">referece (<code>&</code>) parameters</a></td>
                    <td><a href="#const-qualifier">Const</a> parameters</td>
                </tr>
                <tr>
                    <td>Result of the <a href="#special-operators">field (<code>[</code><code>]</code>)</a> and <a href="#special-operators">subscription (<code>.</code>)</a> operators</td>
                    <td>Result of <a href="#common-operators">common</a>, <a href="#assignment-operators">assignment</a>, <a href="#special-operators">grouping</a>, <a href="#special-operators">ternary</a> and <a href="#common-operators">relational</a> operators</td>
                </tr>
                <tr>
                    <td>Non-const <a href="#variables">varibales</a></td>
                    <td><a href="#const-qualifier">Const</a> variables</td>
                </tr>
                <tr>
                    <td><a href="#temporary-variables">Temporary variables</a></td>
                    <td><a href="#enums">Enum</a> elements</td>
                </tr>
                <tr>
                    <td></td>
                    <td>Result of <a href="#function-calls">function calls</a></td>
                </tr>
                <tr>
                    <td></td>
                    <td>Result of <a href="#constructors">constructors</a></td>
                </tr>
                <tr>
                    <td></td>
                    <td><a href="#literals">Literals</a></td>
                </tr>
            </table></div>
            <p>
                Left values can be used anywhere right values can.<br>
                Left and right values are also called l-values and r-values.
            </p>




            <!--------------------------------------------------------------------->
            <!-- Functions                                                       -->
            <!--------------------------------------------------------------------->
            <h1 id="functions"></h1>
            <p>
                <b>Functions</b> are the <b>main component</b> of the language.<br>
                They contain the statements that will be executed during run time and manage inputs and outputs of the shader.
            </p>


            <!--------------------------------------------------------------------->
            <!-- Function definitions                                            -->
            <!--------------------------------------------------------------------->
            <h1 id="function-definitions"></h1>
            <p>
                A <b>function definition</b> consists of its <b>type</b> and <b>name</b> followed by a <b>list of arguments</b> and its statements enclosed in <code>{</code><code>}</code> delimiters.
            </p>
            <p>
                A function can take an arbitrary number of parameters of any type. Paramters are declared like variables and behave in the same exact way.<br>
                The expressions used to call the function are called arguments.<br>
                Each argument must be implicitly convertible to the type of the parameter.<br>
                Functions are allowed to take no arguments.
            </p>
            <p>
                There is no function overloading.
            </p>

            <syntax->
                <left->
                    <label-></label->
                    <code-><scroll->
                        <elm-><t->T<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->(<elm2-><elm->parameter 0</elm->, <elm->...</elm->, <elm->parameter n</elm-></elm2->) { <elm->...</elm-> }
                        <elm-><t->T<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->() { <elm->...</elm-> }
                    </scroll-></code->
                </left->
                <right->
                    <label->Parameter syntax</label->
                    <code-><scroll->
                        <c->/* Normal parameters */</c->    <elm-><t->U<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->
                        <c->/* <a href="#reference-parameters"><c->Reference parameters</c-></a> */</c-> <elm-><t->U<sup>type</sup></t-></elm-> &<elm->name<sup>id</sup></elm->
                        <c->/* <a href="#const-qualifier"><c->Const qualifier</c-></a> */</c->      <elm-><t->U<sup>type</sup></t-></elm-><space-></space->const<space-></space-><elm->name<sup>id</sup></elm->
                    </scroll-></code->
                </right->
            </syntax->
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <t->void</t-> <f->fun</f->(<t->uint</t-> <a->n</a->) {}

                        <t->void</t-> <f->main</f->(){
                            <t->int</t-> var = <k->0</k->;
                            <f->fun</f->(<k->var</k->);
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#runtime-statements">Runtime statements</a>,
                <a href="#types">Types</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Reference parameters                                            -->
            <!--------------------------------------------------------------------->
            <h1 id="reference-parameters"></h1>
            <p>
                By <b>default</b>, the arguments are passed <b>by value</b>, which means that when the function is called, the value of each argument is <b>copied</b> in the corresponding parameter and the function <b>cannot access</b> the original variable.<br>
                If a parameter name is preceeded by a <b><code>&</code></b> token, instead, the argument is passed <b>by reference</b>, allowing the function to <b>access and modify</b> its value
            </p>
            <p>
                Declaring a reference parameter as const is a syntax error and passing an <a href="#left-and-right-values">r-value</a> as argument of a reference parameter is a semantic error.<br>
                Notice that in this case, the <code>&</code> token is not part of the type nor part of the name, but a language feature that is used exclusively within parameter declarations.
            </p>

            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <t->void</t-> <f->fun1</f->(<t->uint</t-> <a->arg1</a->, <t->uint</t-> &<a->arg2</a->) {
                            arg1 = <k->0</k->;     <c->// c_doesn't modify main.a, but the local argument in which its value was copied</c->
                            arg2 = <k->0</k->;     <c->// c_modifies main.b</c->
                        }

                        <t->void</t-> <f->main</f->(){
                            <t->uint</t-> a, b;
                            <f->fun1</f->(a, b);   <c->// a keeps an undefined value, b is set to 0</c->
                            <c->//fun1(a, 5); </c-><ce->// Error, cannot pass literals to reference parameters</ce->
                        }

                        <c->//void fun2(const int &arg1){} </c-><ce->// Error, references cannot be const</ce->
                    </scroll-></code->
                </fill->
            </example->

            <p>
                See
                <a href="#const-qualifier">Const qualifier</a>,
                <a href="#literals">Literals</a>
            </p>


            <!--------------------------------------------------------------------->
            <!-- Function calls                                                  -->
            <!--------------------------------------------------------------------->
            <h1 id="function-calls"></h1>
            <p>
                <b>Functions</b> are <b>called</b> using their <b>name</b> and a list of <b>arguments</b>.<br>
                A function call must provide an argument for each parameter of the function.<br>
                Reference parameters (<a href="#reference-parameters"><code>&</code></a>) only allow <a href="#left-and-right-values">l-values</a> as arguments.
            </p>
            <p>
                The result is returned by the function through the return statement, which is detailedly explained in <a href="#return-statement">Return statement</a>
                //TODO templates
                //TODO functions are called with *function reference* and a list of parameters. not just their name
            </p>

            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <elm->name<sup>id</sup></elm->(<elm-><elm-><t->T0<sup>r</sup></t-></elm->, <elm->...</elm->, <elm-><t->Tn<sup>r</sup></t-></elm-></elm->)
                        <elm->name<sup>id</sup></elm->()
                    </scroll-></code->
                </fill->
            </syntax->

            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <t->void</t-> <f->empty_function_1</f->() { <w->return</w->; }    <c->// Ok</c->
                        <t->void</t-> <f->empty_function_2</f->() {}             <c->// Ok</c->

                        <t->uint</t-> <f->empty_function_3</f->() { <w->return</w-> <k->0</k->; }  <c->// Ok</c->
                        <c->//uint empty_function_4() {}           </c-><ce->// Error, non-void functions must return a value</ce->

                        <t->uint</t-> <f->f</f->(<t->uint</t-> <a->n</a->) { <w->return</w-> n * <k->2</k->; }       <c->// Ok</c->
                        <c->//void f() { }                         </c-><ce->// Error, f is already defined</ce->

                        <t->void</t-> <f->main</f->(){
                            <t->uint</t-> n = <f->empty_function_3</f->();       <c->// Ok</c->
                            n = <f->f</f->(<f->f</f->(<k->n</k->));                       <c->// Ok</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            //TODO update example


            <!--------------------------------------------------------------------->
            <!-- Unnamed scopes                                                  -->
            <!--------------------------------------------------------------------->
            <h1 id="unnamed-scopes"></h1>
            <p>
                //TODO
            </p>


            <!--------------------------------------------------------------------->
            <!-- The main function                                               -->
            <!--------------------------------------------------------------------->
            <h1 id="the-main-function"></h1>
            <p>
                The <b><code><f->main</f-></code> function</b> is where the <b>code execution starts and ends</b>.<br>
                Every shader <b>must define</b> the <b><code><f->main</f-></code></b> function.<br>
            </p>
            <p>
                The parameters of the <code><f->main</f-></code> are passed from the <a href="./Umbra.html">Umbra Language</a> and contain all the inputs and outputs the shader needs to run and interact with other shaders.<br>
                The <code><f->main</f-></code> function can return any type and take const or reference parameters.<br>
                It can also be called by other functions or itself, but it cannot be a template.<br>
            </p>




            <!--------------------------------------------------------------------->
            <!-- Templates                                                       -->
            <!--------------------------------------------------------------------->
            <h1 id="templates"></h1>


            <!--------------------------------------------------------------------->
            <!-- Function templates                                              -->
            <!--------------------------------------------------------------------->
            <h1 id="function-templates"></h1>
            <p>
                <b>Function templates</b> are the basis of generic programming.<br>
                They are used to <b>generate functions</b> based on the types passed to function calls.<br>
                //TODO UPDATE SYNTAX
                //TODO MOVE TO TEMPLATES
                //TODO ADD STRUCT TEMPLATES
            </p>

            <syntax->
                <left->
                    <label-></label->
                    <code-><scroll->
                        <elm-><t->T<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->(<elm2-><elm->parameter 0</elm->, <elm->...</elm->, <elm->parameter n</elm-></elm2->) { <elm->...</elm-> }
                        <elm-><t->T<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->(<elm2-><elm->parameter 0</elm->, <elm->...</elm->, <elm->parameter n</elm-></elm2->) when(<elm-><t->bool<sup>r</sup></t-></elm->) { <elm->...</elm-> }
                        ?<elm->type<sup>id</sup></elm-><space-></space-><elm->name<sup>id</sup></elm->(<elm2-><elm->parameter 0</elm->, <elm->...</elm->, <elm->parameter n</elm-></elm2->) { <elm->...</elm-> }
                        ?<elm->type<sup>id</sup></elm-><space-></space-><elm->name<sup>id</sup></elm->(<elm2-><elm->parameter 0</elm->, <elm->...</elm->, <elm->parameter n</elm-></elm2->) when(<elm-><t->bool<sup>r</sup></t-></elm->) { <elm->...</elm-> }
                    </scroll-></code->
                </left->
                <right->
                    <label->Parameter syntax</label->
                    <code-><scroll->
                        <c->/* Normal parameters */</c->    <elm-><t->U<sup>type</sup></t-></elm-><space-></space-><elm->name<sup>id</sup></elm->
                        <c->/* <a href="#reference-parameters"><c->Reference parameters</c-></a> */</c-> <elm-><t->U<sup>type</sup></t-></elm-> &<elm->name<sup>id</sup></elm->
                        <c->/* <a href="#const-qualifier"><c->Const qualifier</c-></a> */</c->      <elm-><t->U<sup>type</sup></t-></elm-><space-></space->const<space></space><elm->name<sup>id</sup></elm->
                        <c->/* Normal parameters */</c->    ?<elm->type<sup>id</sup></elm-><space-></space-><elm->name<sup>id</sup></elm->
                        <c->/* <a href="#reference-parameters"><c->Reference parameters</c-></a> */</c-> ?<elm->type<sup>id</sup></elm-> &<elm->name<sup>id</sup></elm->
                        <c->/* <a href="#const-qualifier"><c->Const qualifier</c-></a> */</c->      ?<elm->type<sup>id</sup></elm-><space-></space->const<space></space><elm->name<sup>id</sup></elm->
                    </scroll-></code->
                </right->
            </syntax->

            <p>
                Any function with one or more generic type parameters is considered a function template.<br>
                Generic type parameters are declared in the same way as normal parameters, but the type is replaced by a new identifier preceded by a <code>?</code> token.<br>
                Parameters declared using the same type identifier will always have the same type in any generated function.
            </p>
            <p>
                Generic type parameters can be references or const.
            </p>
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <t->?t</t-> <f->add</f->(<t->?t</t-> <a->a</a->, <t->?t</t-> <a->b</a->, <t->int</t-> <a->c</a->){
                            return a + b + c;
                        }
                        <t->auto</t-> <f->add2</f->(<t->?t</t-> <a->a</a->, <t->?u</t-> <a->b</a->){
                            <w->return</w-> a + b;
                        }

                        <t->void</t-> <f->main</f->(){
                            <f->add</f->(<k->0</k->, <k->1</k->, <k->0</k->);        <c->// Generates uint add(uint a, uint b, int c)</c->
                            <f->add</f->(<k->1.0</k->, <k->0.4</k->, <k->0.2</k->);  <c->// Generates float add(float a, float b, int c)</c->
                            <c->//add(1, 0.4, 1);    </c-><ce->// Error, no match for function "add(int a, float b, int c)"</ce->

                            <f->add2</f->(<k->0</k->, <k->1</k->);          <c->// Generates uint add2(uint a, uint b)</c->
                            <f->add2</f->(<k->1</k->, <k->0.4</k->);        <c->// Generates float add2(uint a, float b) </c-> // TODO
                        }
                    </scroll-></code->
                </fill->
            </example->

            <p>
                Templates allow multiple definitions.<br>
                The <code><w->when</w-></code> and <code><w->default</w-></code> keywords are used to assign the correct one to the generated function, depending on the types used in it.
            </p>
            <p>
                The expression used in the <code><w->when</w-></code> specifier must be known in compile time and cannot depend on the value of variables declared inside one of the function definitions.<br>
                Calling the function with types that don't match any definition is a semantic error.<br>
            </p>
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <w->strict</w-> <w->enum</w-> type_id : <t->uint</t-> {
                            floating_point, integral, other;
                        }

                        <t->type_id</t-> <f->get_id</f->(<t->?t</t-> <a->n</a->)
                        <w->when</w->(<t->t</t-> == <t->int</t-> || <t->t</t-> == <t->uint</t->) {
                            <w->return</w-> type_id.<k->integral</k->;
                        }
                        <w->when</w->(<t->t</t-> == <t->float</t-> || <t->t</t-> == <t->double</t->) {
                            <w->return</w-> type_id.<k->floating_point</k->;
                        }
                        <w->default</w-> {
                            <w->return</w-> type_id.<k->other</k->;
                        }


                        <t->void</t-> <f->main</f->(){
                            <f->get_id</f->(<k->-1</k->);      <c->// Returns type_id.integral</c->
                            <f->get_id</f->(<k->0.4</k->);     <c->// Returns type_id.floating_point</c->
                            <f->get_id</f->((<k->0.4</k->));   <c->// Returns type_id.other</c->
                        }
                    </scroll-></code->
                </fill->
            </example->

            <p>
                Generated functions can be referenced and called using the name of the template and the types of the parameters enclosed in <code>&lt;</code><code>&gt;</code> characters.
            </p>
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <elm->name<sup>id</sup></elm->&lt;<elm-><elm-><t->T0<sup>type</sup></t-></elm->, <elm-><t->...<sup>type</sup></t-></elm->, <elm-><t->Tn<sup>type</sup></t-></elm-></elm->&gt;(<elm-><elm-><t->T0<sup>r</sup></t-></elm->, <elm-><t->...<sup>r</sup></t-></elm->, <elm-><t->Tn<sup>r</sup></t-></elm-></elm->);
                    </scroll-></code->
                </fill->
            </syntax->
            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <w->strict</w-> <w->enum</w-> type_id : <t->uint</t-> {
                            floating_point, integral, other;
                        }

                        <t->type_id</t-> <f->get_id</f->(<t->?t</t-> <a->n</a->)
                        <w->when</w->(<t->t</t-> == <t->int</t-> || <t->t</t-> == <t->uint</t->) {
                            <w->return</w-> type_id.<k->integral</k->;
                        }
                        <w->when</w->(<t->t</t-> == <t->float</t-> || <t->t</t-> == <t->double</t->) {
                            <w->return</w-> type_id.<k->floating_point</k->;
                        }
                        <w->default</w-> {
                            <w->return</w-> type_id.<k->other</k->;
                        }


                        <t->void</t-> <f->main</f->(){
                            <f->get_id</f->&lt;<t->int</t->&gt;(<k->0.4</k->); <c->// Returns type_id.integral</c->
                            <f->get_id</f->&lt;<t->double</t->&gt;(<k->1</k->); <c->// Returns type_id.floating_point</c->
                            <f->get_id</f->&lt;(<t->double</t->)&gt;((<k->0.4</k->)); <c->// Returns type_id.other</c->
                            <c->//get_id&lt;double&gt;((0.4)); </c-><ce->// Error, cannot convert "(double)" tuple to "double"</ce->
                        }
                    </scroll-></code->
                </fill->
            </example->


            <!--------------------------------------------------------------------->
            <!-- Struct templates                                                -->
            <!--------------------------------------------------------------------->
            <h1 id="struct-templates"></h1>


            <!--------------------------------------------------------------------->
            <!-- Abbreviated template syntax                                     -->
            <!--------------------------------------------------------------------->
            <h1 id="abbreviated-template-syntax"></h1>


            <!--------------------------------------------------------------------->
            <!-- Template constraints                                            -->
            <!--------------------------------------------------------------------->
            <h1 id="template-constraints"></h1>




            <!--------------------------------------------------------------------->
            <!-- Const qualifier                                                 -->
            <!--------------------------------------------------------------------->
            <h1 id="const-qualifier"></h1>
            <p>
                The <code><t->const</t-></code> qualifier can be used to <b>prevent</b> named values to be <b>modified</b> after their declaration.<br>
                Reference const parameters are not allowed, as well as const functions, const struct members and const tuple elements.<br>
            </p>
            <p>
                As opposed to GLSL, const symbols can be initialized using non-const expressions.<br>
                The qualifier doesn't affect compiler optimizations or the GLSL output in any way.
            </p>
            <p>
                Passing a const identifier as argument of reference parameters is not allowed and will result in a semantic error.<br>
                Const variables cannot have undefined value.
            </p>

            <example->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        <w->struct</w-> <t->s</t-> {
                            <t->uint</t-> a;            <c->// Ok, non-const member</c->
                            <c->//uint const b;    </c-><ce->// Error, struct members cannot be const</ce->
                        }
                        <t->s const</t-> var;           <c->// Ok, const global variable</c->

                        <c->//double const fun(){}              </c-><ce->// Error, functions cannot be const</ce->
                        <c->//double fun(double const &arg){}   </c-><ce->// Error, references cannot be const</ce->

                        <t->double</t-> <f->fun</f->(<t->double</t-> <a->arg</a->) {            <c->// Ok, const parameter</c->
                            <c->//uint const a;                 </c-><ce->// Error, uninitialized const</ce->
                            <t->uint const</t-> a = <k->4</k->;               <c->// Ok</c->
                            <t->uint const</t-> b = arg, c;          <c->// Ok</c->
                            <c->//a = 2;                        </c-><ce->// Error, cannot assign values to const variables</ce->
                            c = <k->a</k-> + b;                      <c->// Ok</c->
                        }
                    </scroll-></code->
                </fill->
            </example->
            <p>
                See
                <a href="#compiler-optimizations">Compiler optimizations</a>
            </p>




            <!--------------------------------------------------------------------->
            <!-- Symbol aliases                                                  -->
            <!--------------------------------------------------------------------->
            <h1 id="symbol-aliases"></h1>
            <p>
                <b>Symbol aliases</b> are <b>alternative names</b> for symbols.
                Symbols can be aliased using the <code><w->alias</w-></code> keyword.<br>
                Any declared symbol can be aliased, including modules, generated functions and other aliases.
            </p>
            <p>
                An alias is not simply replaced like a <a href="#macros">macro</a> but it identifies the symbol itself in a unique way.<br>
                Once an alias is declared, the alias and the symbol it aliases can be used interchangeably.
            </p>
            <p>
                Variables can be aliased before their declaration, but the alias can only be used after the declaration of the variable.
            </p>

            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        alias <elm->name<sup>id</sup></elm-> = <elm->symbol<sup>id</sup></elm->;
                    </scroll-></code->
                </fill->
            </syntax->
            <example->
                <fill->
                    <label->1</label->
                    <code-><scroll->
                        <w->namespace</w-> n {
                            <t->void</t-> <f->f</f->(){}
                        }
                        <w->alias</w-> n2 = n;        <c->// Ok, n2 = module.n</c->
                        <w->alias</w-> f2 = n2.<f->f</f->;    <c->// Ok, f2 = (module.n2).f = module.n.f</c->
                        <w->alias</w-> f3 = n2.<f->f2</f->;   <c->// Ok, f2 = (module.n2).(module.f2) = module.n.f</c->

                        <t->void</t-> <f->main</f->(){
                            <f->f2</f->();            <c->// Ok, calls n.f()</c->
                            <f->f3</f->();            <c->// Ok, calls n.f()</c->
                        }
                    </scroll-></code->
                </fill->
            </example->








            <!--------------------------------------------------------------------->
            <!-- Statements                                                      -->
            <!--------------------------------------------------------------------->
            <h1 id="statements"></h1>
            <p>
                <b>Statements</b> are the <b>instructions</b> that are <b>executed during runtime</b>.<br>
                They determine the behaviour of the shader, its execution time and <a href="#compiler-optimizations">compiler optimizations</a>.<br>
                The <code>;</code> token defines the end of a statement.
            </p>
            <p>
                A statement can be an expression or a flow control <a href="#keywords">keyword</a>.<br>
                Any sequence of tokens entirely composed of <a href="#left-and-right-values">values</a> and <a href="#function-calls">function calls</a> is considered an expression.
            </p>
            <p>
                Statements can only be used within <a href="#functions">functions</a> and <a href="#unnamed-scopes">unnames scopes</a>.
            </p>




            <!--------------------------------------------------------------------->
            <!-- Selection                                                       -->
            <!--------------------------------------------------------------------->
            <h1 id="selection"></h1>


            <!--------------------------------------------------------------------->
            <!-- If statement                                                    -->
            <!--------------------------------------------------------------------->
            <h1 id="if-statement"></h1>


            <!--------------------------------------------------------------------->
            <!-- Match statement                                                 -->
            <!--------------------------------------------------------------------->
            <h1 id="match-statement"></h1>




            <!--------------------------------------------------------------------->
            <!-- Iteration                                                       -->
            <!--------------------------------------------------------------------->
            <h1 id="iteration"></h1>


            <!--------------------------------------------------------------------->
            <!-- For loops                                                       -->
            <!--------------------------------------------------------------------->
            <h1 id="for-loops"></h1>


            <!--------------------------------------------------------------------->
            <!-- While loops                                                     -->
            <!--------------------------------------------------------------------->
            <h1 id="while-loops"></h1>


            <!--------------------------------------------------------------------->
            <!-- Continue and break statements                                   -->
            <!--------------------------------------------------------------------->
            <h1 id="continue-and-break-statements"></h1>
            <p>
                //TODO break 2; continue 40;
            </p>


            <!--------------------------------------------------------------------->
            <!-- Once statement                                                  -->
            <!--------------------------------------------------------------------->
            <h1 id="once-statement"></h1>


            <!--------------------------------------------------------------------->
            <!-- Then statement                                                  -->
            <!--------------------------------------------------------------------->
            <h1 id="then-statement"></h1>




            <!--------------------------------------------------------------------->
            <!-- Non local flow control                                          -->
            <!--------------------------------------------------------------------->
            <h1 id="non-local-flow-control"></h1>


            <!--------------------------------------------------------------------->
            <!-- Return statement                                                -->
            <!--------------------------------------------------------------------->
            <h1 id="return-statement"></h1>
            <p>
                The <b><code><w->return</w-></code></b> statement skips all remaining statements in the function and <b>returns</b> the <b>code execution</b> to the <b>caller function</b>.<br>
                Multiple return statements are allowed, but their value must be implicitly convertible to the type of the function.
            </p>
            <p>
                All execution paths of non-<code><t->void</t-></code> functions must return a value.<br>
                The return value can then be used by the caller function or be ignored.<br>
                Calls to <code><t->void</t-></code> functions cannot be used in expressions.
            </p>
            <p>
                There is no default return value.
            </p>
            <syntax->
                <fill->
                    <label-></label->
                    <code-><scroll->
                        return<space-></space-><elm-><t->T<sup>r</sup></t-></elm->;     <c->// Non-void functions</c->
                        return;           <c->// Void functions</c->
                    </scroll-></code->
                </fill->
            </syntax->
            <p>
                //TODO EXAMPLE
            </p>


            <!--------------------------------------------------------------------->
            <!-- Defer statement                                                 -->
            <!--------------------------------------------------------------------->
            <h1 id="defer-statement"></h1>




            <!--------------------------------------------------------------------->
            <!-- Else statement                                                  -->
            <!--------------------------------------------------------------------->
            <h1 id="else-statement"></h1>








            <!--------------------------------------------------------------------->
            <!-- Reflection                                                      -->
            <!--------------------------------------------------------------------->
            <h1 id="reflection"></h1>








            <!--------------------------------------------------------------------->
            <!-- Inline GLSL                                                     -->
            <!--------------------------------------------------------------------->
            <h1 id="inline-glsl"></h1>








            <!--------------------------------------------------------------------->
            <!-- Compilation                                                     -->
            <!--------------------------------------------------------------------->
            <h1 id="compilation"></h1>




            <!--------------------------------------------------------------------->
            <!-- Modules                                                         -->
            <!--------------------------------------------------------------------->
            <h1 id="modules"></h1>




            <!--------------------------------------------------------------------->
            <!-- Compilation phases and error types                              -->
            <!--------------------------------------------------------------------->
            <h1 id="compilation-phases-and-error-types"></h1>




            <!--------------------------------------------------------------------->
            <!-- Global initialization order                                     -->
            <!--------------------------------------------------------------------->
            <h1 id="global-initialization-order"></h1>




            <!--------------------------------------------------------------------->
            <!-- Runtime performance                                              -->
            <!--------------------------------------------------------------------->
            <h1 id="runtime-performance"></h1>


            <!--------------------------------------------------------------------->
            <!-- Branching performance                                           -->
            <!--------------------------------------------------------------------->
            <h1 id="branching-performance"></h1>


            <!--------------------------------------------------------------------->
            <!-- Value precomputation                                            -->
            <!--------------------------------------------------------------------->
            <h1 id="value-precomputation"></h1>








            <!--------------------------------------------------------------------->
            <!-- Core module                                                     -->
            <!--------------------------------------------------------------------->
            <h1 id="core-module"></h1>
            <p>
                //TODO
            </p>




            <!--------------------------------------------------------------------->
            <!-- Operators                                                       -->
            <!--------------------------------------------------------------------->
            <h1 id="operators"></h1>
            <p style="margin-bottom: 20px;">
                The language defines a total of 44 operators.<br>
            </p>
            <ul>
                <li>Common operators<ul>
                    <li>Arithmetic operators</li>
                    <li>Bitwise operators</li>
                    <li>Logical operators</li>
                    <li>Relational operators</li>
                </ul></li>
                <li>Assignment operators</li>
                <li>Special operators</li>
            </ul>


            <!--------------------------------------------------------------------->
            <!-- Common operators                                                -->
            <!--------------------------------------------------------------------->
            <h1 id="common-operators"></h1>
            <p>
                //TODO
                //TODO
                //TODO
                //TODO
                //TODO
                //TODO


                <!-- #include <stdio.h> -->
                <!-- #include <math.h> -->
                <!-- int sign2_(int a, int b) { -->
                    <!-- static int s[2] = { 1, -1 }; -->
                    <!-- printf("i = %-8d",((unsigned)a ^ (unsigned)b) >> 31); -->
                    <!-- return s[((unsigned)a ^ (unsigned)b) >> 31]; -->
                <!-- } -->

                <!-- int div_(int a, int b) { --> //TODO this is mod
                    <!-- return abs(a-a/b*b) * sign2_(a, b); -->
                <!-- } -->

                <!-- int main() { -->
                    <!-- printf("n = %d\n", div_(59, -3)); -->
                    <!-- printf("n = %d\n", div_(-59, -3)); -->
                    <!-- printf("n = %d\n", div_(-59, 3)); -->
                    <!-- printf("n = %d\n", div_(59, 3)); -->
                <!-- } -->

                //TODO the mod function returns the same sign of /
                //TODO add other types

                //TODO
                //TODO
                //TODO
                //TODO
                //TODO
                //TODO
                //TODO
                //TODO
                //TODO
            </p>
            <p>
                <b>Common operators</b> include operators to perform <b>comparisons</b>, <b>arithmetic operations</b>, <b>bit manipulation</b> and <b>logical operations</b>.<br>
            </p>
            <div class="table-container"><table>
                <thead><tr>
                    <th class="center">Precedence</th>
                    <th class="center">Operator</th>
                    <th class="center">Function signature</th>
                    <th class="left">Name</th>
                    <th class="left">Category</th>
                </tr></thead>
                <tbody>
                        <tr>
                            <td class="center" rowspan="2">2</td>
                            <td class="center"><code>++</code></td>
                            <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> &<a->n</a->) <f->++</f-></code></td>
                            <td class="left">Postfix increment</td>
                            <td class="left" rowspan="6">Arithmetic</td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>--</code></td>
                            <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> &<a->n</a->) <f->--</f-></code></td>
                            <td class="left">Postfix decrement</td>
                            <fake-td></fake-td>
                        </tr>
                    <!-- 3 -->
                        <tr>
                            <td class="center" rowspan="6">3</td>
                            <td class="center"><code>++</code></td>
                            <td class="center nowrap"><code><t->T</t-> <f->++</f-> (?<t->T</t-> &<a->n</a->)</code></td>
                            <td class="left">Prefix increment</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>--</code></td>
                            <td class="center nowrap"><code><t->T</t-> <f->--</f-> (?<t->T</t-> &<a->n</a->)</code></td>
                            <td class="left">Prefix decrement</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>+</code></td>
                            <td class="center nowrap"><code><t->T</t-> <f->+</f-> (?<t->T</t-> <a->n</a->)</code></td>
                            <td class="left">Promotion</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>-</code></td>
                            <td class="center nowrap"><code><t->T</t-> <f->-</f-> (?<t->T</t-> <a->n</a->)</code></td>
                            <td class="left">Inversion</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>~</code></td>
                            <td class="center nowrap"><code><t->T</t-> <f->~</f-> (?<t->T</t-> <a->n</a->)</code></td>
                            <td class="left">Bitwise NOT</td>
                            <td class="left">Bitwise</td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>!</code></td>
                            <td class="center nowrap"><code><t->bool</t-> <f->!</f-> (<t->bool</t-> <a->n</a->)</code></td>
                            <td class="left">Logical NOT</td>
                            <td class="left">Logical</td>
                        </tr>
                    <!-- 4 -->
                        <tr>
                            <td class="center" rowspan="3">4</td>
                            <td class="center"><code>*</code></td>
                            <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <a->a</a->) <f->*</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Multiplication</td>
                            <td class="left" rowspan="5">Arithmetic</td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>/</code></td>
                            <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <a->a</a->) <f->/</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Division</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>%</code></td>
                            <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <a->a</a->) <f->%</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Modulus</td>
                            <fake-td></fake-td>
                        </tr>
                    <!-- 5 -->
                        <tr>
                            <td class="center" rowspan="2">5</td>
                            <td class="center"><code>+</code></td>
                            <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <a->a</a->) <f->+</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Addition</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>-</code></td>
                            <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <a->a</a->) <f->-</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Subtraction</td>
                            <fake-td></fake-td>
                        </tr>
                    <!-- 6 -->
                        <tr>
                            <td class="center" rowspan="2">6</td>
                            <td class="center"><code>&lt;&lt;</code></td>
                            <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <a->a</a->) <f->&lt;&lt;</f-> (<t->uint</t-> <a->b</a->)</code></td>
                            <td class="left">Left bit shift</td>
                            <td class="left" rowspan="2">Bitwise</td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>&gt;&gt;</code></td>
                            <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <a->a</a->) <f->&gt;&gt;</f-> (<t->uint</t-> <a->b</a->)</code></td>
                            <td class="left">Right bit shift</td>
                            <fake-td></fake-td>
                        </tr>
                    <!-- 7 -->
                        <tr>
                            <td class="center" rowspan="4">7</td>
                            <td class="center"><code>&lt;</code></td>
                            <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <a->a</a->) <f->&lt;</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Less than</td>
                            <td class="left" rowspan="8">Relational</td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>&lt;=</code></td>
                            <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <a->a</a->) <f->&lt;=</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Less or equal than</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>&gt;</code></td>
                            <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <a->a</a->) <f->&gt;</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Greater than</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>&gt;=</code></td>
                            <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <a->a</a->) <f->&gt;=</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Greater or equal than</td>
                            <fake-td></fake-td>
                        </tr>
                    <!-- 8 -->
                        <tr>
                            <td class="center" rowspan="4">8</td>
                            <td class="center"><code>==</code></td>
                            <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <a->a</a->) <f->==</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Equality</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>!=</code></td>
                            <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <a->a</a->) <f->!=</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Inequality</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>=:</code></td>
                            <td class="center nowrap"><code><t->bool</t-> (<t->baseof</t->(<t->T</t->) <a->a</a->) <f->=:</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Existence</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>!:</code></td>
                            <td class="center nowrap"><code><t->bool</t-> (<t->baseof</t->(<t->T</t->) <a->a</a->) <f->!:</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Inexistence</td>
                            <fake-td></fake-td>
                        </tr>
                    <!-- 9 -->
                        <tr>
                            <td class="center">9</td>
                            <td class="center"><code>&</code></td>
                            <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <a->a</a->) <f->&</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Bitwise AND</td>
                            <td class="left" rowspan="3">Bitwise</td>
                        </tr>
                    <!-- 10 -->
                        <tr>
                            <td class="center">10</td>
                            <td class="center"><code>^</code></td>
                            <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <a->a</a->) <f->^</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Bitwise XOR</td>
                            <fake-td></fake-td>
                        </tr>
                    <!-- 11 -->
                        <tr>
                            <td class="center">11</td>
                            <td class="center"><code>|</code></td>
                            <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <a->a</a->) <f->|</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Bitwise OR</td>
                            <fake-td></fake-td>
                        </tr>
                    <!-- 12 -->
                        <tr>
                            <td class="center">12</td>
                            <td class="center"><code>&&</code></td>
                            <td class="center nowrap"><code><t->bool</t-> (<t->bool</t-> <a->a</a->) <f->&&</f-> (<t->bool</t-> <a->b</a->)</code></td>
                            <td class="left">Logical AND</td>
                            <td class="left" rowspan="3">Logical</td>
                        </tr>
                    <!-- 13 -->
                        <tr>
                            <td class="center">13</td>
                            <td class="center"><code>^^</code></td>
                            <td class="center nowrap"><code><t->bool</t-> (<t->bool</t-> <a->a</a->) <f->^^</f-> (<t->bool</t-> <a->b</a->)</code></td>
                            <td class="left">Logical XOR</td>
                            <fake-td></fake-td>
                        </tr>
                    <!-- 14 -->
                        <tr>
                            <td class="center">14</td>
                            <td class="center"><code>||</code></td>
                            <td class="center nowrap"><code><t->bool</t-> (<t->bool</t-> <a->a</a->) <f->||</f-> (<t->bool</t-> <a->b</a->)</code></td>
                            <td class="left">Logical OR</td>
                            <fake-td></fake-td>
                        </tr>
                </tbody>
            </table></div>

            <sep-3-><sep-3->
            <h1 id="arithmetic"></h1>
            <p>
                Arithmetic operators can be used on any <a href="#primitive-types">primitive type</a> or <a href="#enums">enum</a>.
            </p>
            <p>
                <code>++</code>, <code>--</code>.<br>
                Increment and decrement operators add and subtract <code><k->1</k-></code> to the value of the operand.<br>
                Prefix operators return the value of the operand after the operation, postfix operators return the value of the operand before the operation.<br>
                Incrementing or decrementing a <code><t->bool</t-></code> has the same effect of converting its value to <code><t->int</t-></code>, performing the operation and converting it back to <code><t->bool</t-></code>.<br>
                Increment and decrement are the only common operators which modify the original value.
            </p>
            <p>
                <code>-</code>, <code>+</code>.<br>
                The promotion operator has no effect and only exists for completeness.<br>
                The inversion operator inverts the sign of the operand.<br>
                Inverting a <code><t->bool</t-></code> has no effect.
            </p>
            <p>
                <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>.<br>
                Addition, subtraction, multiplication, division and modulus operators perform their corresponding operations between two operators.<br>
                Using these operators with <code><t->bool</t-></code> values has the same effect of converting their value to <code><t->int</t-></code>, performing the operation and converting them back to <code><t->bool</t-></code>.<br>
                <br>
                Differently from GLSL and C++, the result of the modulus operator has the same sign of the result of the division.<br>
                Using <code><k->0</k-></code> as second operand of in division or modulus operator with <a href="#primitive-types">integral types</a> has <b>undefined</b> result.
            </p>

            <h1 id="logical"></h1>
            <p>
                Logical operators can only be used on <code><t->bool</t-></code> types.
            </p>
            <p>
                <code>!</code>, <code>&&</code>, <code>||</code>, <code>^^</code>.<br>
                NOT returns the inverse of the value.<br>
                AND, OR and XOR perform their corresponding operations between two values.<br>
                <div style="min-width: 100%; display: flex;">
                    <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-right: calc(var(--def-margin) / 2); display: inline-block;">
                        <div class="table-container"><table>
                            <tr>
                                <th>A</th>
                                <th>B</th>
                                <th>A || B</th>
                            </tr>
                            <tr>
                                <td class="center"><code><k->1</k-></code></td>
                                <td class="center"><code><k->1</k-></code></td>
                                <td class="center"><code><k->1</k-></code></td>
                            </tr>
                            <tr>
                                <td class="center"><code><k->0</k-></code></td>
                                <td class="center"><code><k->0</k-></code></td>
                                <td class="center"><code><k->0</k-></code></td>
                            </tr>
                            <tr>
                                <td class="center"><code><k->1</k-></code></td>
                                <td class="center"><code><k->0</k-></code></td>
                                <td class="center"><code><k->1</k-></code></td>
                            </tr>
                            <tr>
                                <td class="center"><code><k->0</k-></code></td>
                                <td class="center"><code><k->1</k-></code></td>
                                <td class="center"><code><k->1</k-></code></td>
                            </tr>
                        </table></div>
                        <div class="table-container"><table>
                            <tr>
                                <th>A</th>
                                <th>B</th>
                                <th>A && B</th>
                            </tr>
                            <tr>
                                <td class="center"><code><k->1</k-></code></td>
                                <td class="center"><code><k->1</k-></code></td>
                                <td class="center"><code><k->1</k-></code></td>
                            </tr>
                            <tr>
                                <td class="center"><code><k->0</k-></code></td>
                                <td class="center"><code><k->0</k-></code></td>
                                <td class="center"><code><k->0</k-></code></td>
                            </tr>
                            <tr>
                                <td class="center"><code><k->1</k-></code></td>
                                <td class="center"><code><k->0</k-></code></td>
                                <td class="center"><code><k->0</k-></code></td>
                            </tr>
                            <tr>
                                <td class="center"><code><k->0</k-></code></td>
                                <td class="center"><code><k->1</k-></code></td>
                                <td class="center"><code><k->0</k-></code></td>
                            </tr>
                        </table></div>
                    </div>
                    <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-left: calc(var(--def-margin) / 2); display: inline-block;">
                        <div class="table-container"><table>
                            <tr>
                                <th>A</th>
                                <th>B</th>
                                <th>A ^^ B</th>
                            </tr>
                            <tr>
                                <td class="center"><code><k->1</k-></code></td>
                                <td class="center"><code><k->1</k-></code></td>
                                <td class="center"><code><k->0</k-></code></td>
                            </tr>
                            <tr>
                                <td class="center"><code><k->0</k-></code></td>
                                <td class="center"><code><k->0</k-></code></td>
                                <td class="center"><code><k->0</k-></code></td>
                            </tr>
                            <tr>
                                <td class="center"><code><k->1</k-></code></td>
                                <td class="center"><code><k->0</k-></code></td>
                                <td class="center"><code><k->1</k-></code></td>
                            </tr>
                            <tr>
                                <td class="center"><code><k->0</k-></code></td>
                                <td class="center"><code><k->1</k-></code></td>
                                <td class="center"><code><k->1</k-></code></td>
                            </tr>
                        </table></div>
                        <div class="table-container"><table>
                            <tr>
                                <th colspan="2">A</th>
                                <fake-td></fake-td>
                                <th>!A</th>
                            </tr>
                            <tr>
                                <td class="center" colspan="2"><code><k->1</k-></code></td>
                                <fake-td></fake-td>
                                <td class="center"><code><k->0</k-></code></td>
                            </tr>
                            <tr>
                                <td class="center" colspan="2"><code><k->0</k-></code></td>
                                <fake-td></fake-td>
                                <td class="center"><code><k->1</k-></code></td>
                            </tr>
                        </table></div>
                    </div>
                </div>
            </p>

            <h1 id="bitwise"></h1>
            <p>
                Bitwise operators can be used on any <a href="#primitive-types">primitive type</a> or <a href="#enums">enum</a>.
                //TODO convert floats to int without changing the bit value
                //TODO floatBitsToInt intBitsToFloat
            </p>
            <p>
                <code>&lt;&lt;</code>, <code>&gt;&gt;</code>.<br>
                Bit shift operators shift the bits of the value of the left operand by the value of the right operand.<br>
                The right operand is converted to <code><t->uint</t-></code>. Discarded bits are set to <code><k->0</k-></code>.<br>
                Shifting non-<code><t->bool</t-></code> types by <code><f->sizeof</f->(<t->type</t->) * <k->8</k-></code> or more causes <b>undefined behaviour</b>.<br>
                Shifting <code><t->bool</t-></code> values is equivalent to setting them to <code><k->false</k-></code>.<br>
            </p>
            <p>
                <code>~</code>, <code>&</code>, <code>|</code>, <code>^</code>.<br>
                The bitwise NOT performs the logical NOT operation on every bit of the operand.<br>
                Bitwise AND, OR and XOR operators are equivalent to their corresponding logical operators, but the operation is performed between each bit of the two operands.<br>
                The types of the operand must have the same size.<br>
                <b><a href="#implicit-conversions">Implicit conversions</a> don't apply</b> on these operators. The return type has the same type of the first opeand.
                //TODO this is different than c++ and  glsl
            </p>

            <h1 id="relational"></h1>
            <p>
                Relational operators can be used on any <a href="#primitive-types">primitive type</a> or <a href="#enums">enum</a>,
                with the exception of <code>==</code>, <code>!=</code>, <code>=:</code> and <code>!:</code> which can be used with any type, including <a href="#structs">structs</a> and <a href="#typenames">typenames</a>.
            </p>
            <p>
                <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.<br>
                The equality operator returns <code><k->true</k-></code> if the operands have the same value.<br>
                The inequality operator returns <code><k->true</k-></code> if the operands have different values.<br>
                The other operators return <code><k->true</k-></code> if the first operand is less than, greater than, less or equal than or greater or equal than the second operand, respectively.
            </p>
            <p>
                <code>=:</code>, <code>!:</code>.<br>
                The existence operator returns <code><k->true</k-></code> if the first operand has the value of one of the elements of the second operand.<br>
                The inexistence operator returns <code><k->true</k-></code> if all the elements of the second operand are different than the value of the first operand.<br>
                The second operand must be an array with a base type that is the same as the type of the first operand or can be implicitly converted to it.
            </p>
            <p>
                Their return value is the same as if they were declared in the following way:
            </p>
            <div style="min-width: 100%; display: flex;">
                <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-right: calc(var(--def-margin) / 2); display: inline-block;">
                    <example- style="margin: 0;">
                        <fill->
                            <label- class="nobefore">Existence</label->
                            <code-><scroll->
                                <t->bool</t-> (<t->baseof</t->(<t->t</t->) <a->a</a->) <f->=:</f-> (?<t->t</t-> <a->b</a->) {
                                    <w->for</w->(<t->uint</t-> i = <k->0</k->; i &lt; b.<f->len</f->(); ++i) {
                                        <w->if</w->(a == b[i]) <w->return</w-> <k->true</k->;
                                    }
                                    <w->return</w-> <k->false</k->;
                                }
                            </scroll-></code->
                        </fill->
                    </example->
                </div>
                <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-left: calc(var(--def-margin) / 2); display: inline-block;">
                    <example- style="margin: 0;">
                        <fill->
                            <label- class="nobefore">Inexistence</label->
                            <code-><scroll->
                                <t->bool</t-> (<t->baseof</t->(<t->t</t->) <a->a</a->) <f->!:</f-> (?<t->t</t-> <a->b</a->) {
                                    <w->for</w->(<t->uint</t-> i = <k->0</k->; i &lt; b.<f->len</f->(); ++i) {
                                        <w->if</w->(a == b[i]) <w->return</w-> <k->false</k->;
                                    }
                                    <w->return</w-> <k->true</k->;
                                }
                            </scroll-></code->
                        </fill->
                    </example->
                </div>
            </div>




            <!--------------------------------------------------------------------->
            <!-- Assinment opeatos                                               -->
            <!--------------------------------------------------------------------->
            <h1 id="assignment-operators"></h1>
            <p>
                <b>Assignment operators</b> are used to <b>change the value</b> of <a href="#left-and-right-values">l-value</a> symbols.<br>
                The original value is set to the result of the operation.
            </p>
            <p>
                The direct assignment (<code>=</code>) changes the value of the first operand to the one of the second operand.<br>
                It can be used with type, including typenames and composite types. <a href="#structs">Structs</a> must be of the same exact type to be assigned.
            </p>
            <p>
                The result of the other assignment operators and the types they can be used with are the same as their corresponding <a href="#common-operators">common operators</a>.<br>
            </p>
            <div class="table-container"><table>
                <thead><tr>
                    <th class="center">Precedence</th>
                    <th class="center">Operator</th>
                    <th class="center">Function signature</th>
                    <th class="left">Name</th>
                    <th class="left">Category</th>
                </tr></thead>
                <tbody>
                    <!-- 16 -->
                        <tr>
                            <td class="center" rowspan="11">16</td>
                            <td class="center"><code>=</code></td>
                            <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<a->a</a->) <f->=</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Direct assignment</td>
                            <td class="left" rowspan="11">Assignment</td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>+=</code></td>
                            <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<a->a</a->) <f->+=</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Addition assignment</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>-=</code></td>
                            <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<a->a</a->) <f->-=</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Subtraction assignment</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>*=</code></td>
                            <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<a->a</a->) <f->*=</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Multiplication assignment</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>/=</code></td>
                            <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<a->a</a->) <f->/=</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Division assignment</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>%=</code></td>
                            <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<a->a</a->) <f->%=</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Modulus assignment</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>&=</code></td>
                            <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<a->a</a->) <f->&=</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Bitwise AND assignment</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>^=</code></td>
                            <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<a->a</a->) <f->^=</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Bitwise XOR assignment</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>|=</code></td>
                            <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<a->a</a->) <f->|=</f-> (?<t->T</t-> <a->b</a->)</code></td>
                            <td class="left">Bitwise OR assignment</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>&lt;&lt;=</code></td>
                            <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<a->a</a->) <f->&lt;&lt;=</f-> (<t->uint</t-> <a->b</a->)</code></td>
                            <td class="left">Left bit shift assignment</td>
                            <fake-td></fake-td>
                        </tr>
                        <tr>
                            <fake-td></fake-td>
                            <td class="center"><code>&gt;&gt;=</code></td>
                            <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<a->a</a->) <f->&gt;&gt;=</f-> (<t->uint</t-> <a->b</a->)</code></td>
                            <td class="left">Right bit shift assignment</td>
                            <fake-td></fake-td>
                        </tr>
                </tbody>
            </table></div>


            <!--------------------------------------------------------------------->
            <!-- Special operators                                               -->
            <!--------------------------------------------------------------------->
            <h1 id="special-operators"></h1>
            <div class="table-container"><table>
                <thead><tr>
                    <th class="center">Precedence</th>
                    <th class="center">Operator</th>
                    <th class="center">Function signature</th>
                    <th class="left">Name</th>
                    <th class="left">Category</th>
                </tr></thead>
                <tbody>
                    <!-- 1 -->
                        <tr>
                            <td class="center" >1</td>
                            <td class="center"><elm-><code>(</code><code>)</code></elm-></td>
                            <td class="center nowrap"><code><t->T</t-> <f->(</f-> (?<t->T</t-> <a->n</a->) <f->)</f-></code></td>
                            <td class="left">Grouping</td>
                            <td class="left" rowspan="10">Other</td>
                        </tr>
                    <!-- 15 -->
                        <tr>
                            <td class="center">15</td>
                            <td class="center"><elm-><code>?</code><code>:</code></elm-></td>
                            <td class="center nowrap"><code><t->T</t-> (<t->bool</t-> <a->a</a->) <f->?</f-> (?<t->T</t-> <a->b</a->) <f->:</f-> (?<t->T</t-> <a->c</a->)</code></td>
                            <td class="left">Selection operator</td>
                        </tr>
                </tbody>
            </table></div>
            <p>
                <elm-><code>(</code><code>)</code></elm->.<br>
                The grouping operator is used to change the precedence of other functions.<br>
                The expression between the <code>(</code> and <code>)</code> characters is evaluated before the rest and used as a single value.
            </p>
            <p>
                <elm-><code>?</code><code>:</code></elm->.<br>
                The selection operator works like an <a href="#if-statement"><code><w->if</w-></code> statement</a>.<br>
                If the first operand is <code><k->true</k-></code>, it returns the value of the second operand.<br>
                If it is <code><k->false</k-></code>, the value of the third operand is returned.
            </p>


            <!--------------------------------------------------------------------->
            <!-- Arithmetic exceptions                                           -->
            <!--------------------------------------------------------------------->
            <h1 id="arithmetic-exceptions"></h1>
            <p>
                Only <b>certain</b> <a href="#primitive-types">floating point</a> <b>operations</b> that generate or use <b>special double literals</b> have <b>defined</b> result.<br>
                Their result is the same as in real arithmetic operations:
            </p>
            <div class="table-container"><table>
                <tr>
                    <th>Operation</th>
                    <th>Result</th>
                </tr>
                <!-- +*-, +*-/ -->
                <tr>
                    <td class="center"><code>n</code> + <code><k->inf</k-></code></td>
                    <td class="center" rowspan="3"><code><k->inf</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code>n</code> - <code><k->inf</k-></code></td>
                    <fake-td></fake-td>
                </tr>
                <tr>
                    <td class="center"><code>n</code> * <code><k->inf</k-></code></td>
                    <fake-td></fake-td>
                </tr>
                <tr>
                    <td class="center"><code>n</code> / <code><k->inf</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->inf</k-></code> + <code>n</code></td>
                    <td class="center" rowspan="4"><code><k->inf</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->inf</k-></code> - <code>n</code></td>
                    <fake-td></fake-td>
                </tr>
                <tr>
                    <td class="center"><code><k->inf</k-></code> * <code>n</code></td>
                    <fake-td></fake-td>
                </tr>
                <tr>
                    <td class="center"><code><k->inf</k-></code> / <code>n</code></td>
                    <fake-td></fake-td>
                </tr>

                <!-- 2 infs -->
                <tr>
                    <td class="center"><code><k->+inf</k-></code> + <code><k->+inf</k-></code></td>
                    <td class="center"><code><k->+inf</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->-inf</k-></code> - <code><k->-inf</k-></code></td>
                    <td class="center"><code><k->-inf</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->inf</k-></code> * <code><k->inf</k-></code></td>
                    <td class="center"><code><k->inf</k-></code></td>
                </tr>
                <tr>
                    <th>Operation (special cases)</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code> * <code><k->inf</k-></code></td>
                    <td class="center"><code><b>undefined</b></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->inf</k-></code> * <code><k->0</k-></code></td>
                    <td class="center"><code><b>undefined</b></code></td>
                </tr>
            </table></div>
            <p>
                Where <code>n</code> is any non-<code><k->nan</k-></code>, non-<code><k->inf</k-></code> <a href="#primitive-types">floating point</a> value.
            </p>
            <p>
                All the above operations behave in the same way when performed through their corresponding <a href="#assignment-operators">assignment operators</a> (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>).<br>
                Direct assignments, relational operators and binary operators
                    (<code>=</code>, <code>==</code>, <code>!=</code>, <code>=:</code>, <code>!:</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&</code>, <code>|</code>, <code>^</code>)
                    are fully supported and can be used with <code><k->inf</k-></code> and any other non-<code><k->nan</k-></code> floating point value, according to the required types of each operator.<br>
                Any remaining operation with special floating point values has <b>undefined</b> result.
            </p>
            <p>
                The <code><f->isnan</f-></code> function can be used to check for <code><k->nan</k-></code> values.<br>
                Any operation with <code><k->nan</k-></code> values has <b>undefined</b> result.<br>
                Converting special values to non-floating point types also has <b>undefined</b> result.
            </p>
            <p>
                Some <b>special cases</b> of <b>integral operations</b> have <b>undefined</b> result:
            </p>
            </table></div>
            <div class="table-container"><table>
                <tr>
                    <th>Operation (special cases)</th>
                    <th>Result</th>
                </tr>
                <tr>
                    <td class="center"><code>n</code> / <code><k->0</k-></code></td>
                    <td class="center"><code><b>undefined</b></code></td>
                </tr>
                <tr>
                    <td class="center"><code>n</code> % <code><k->0</k-></code></td>
                    <td class="center"><code><b>undefined</b></code></td>
                </tr>
            </table></div>
            <p>
                Where <code>n</code> is any non-<code><k->0</k-></code> <a href="#primitive-types">integral</a> value.
            </p>
            <p>
                Undefined results don't stop the program execution and are not detected in any way.
            </p>


            <!--------------------------------------------------------------------->
            <!-- Array operations                                                -->
            <!--------------------------------------------------------------------->
            <h1 id="array-operations"></h1>
            <p>
                All <a href="#common-operators">common</a> and <a href="#assignment-operators">assignment</a> operators in the core module, excluding <a href="#common-operators"><code>=:</code></a> and <a href="#common-operators"><code>!:</code></a>, can be used to operate on whole <a href="#arrays">arrays</a>.
            </p>
            <p>
                When arrays are used with unary operators, the operation is performed on all the elements of the array and the return value is an array of the same length,
                containing the results of the operations.
            </p>
            <div style="min-width: 100%; display: flex;">
                <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-right: calc(var(--def-margin) / 2); display: inline-block;">
                    <example- style="margin: 0;">
                        <fill->
                            <label-></label->
                            <code-><scroll->
                                <t->auto</t-> <f->main</f->(){
                                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                                    <w->return</w-> <f->~</f->a;
                                }




                            </scroll-></code->
                        </fill->
                    </example->
                </div>
                <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-left: calc(var(--def-margin) / 2); display: inline-block;">
                    <example- style="margin: 0;">
                        <fill->
                            <label- class="nobefore">Equivalent code</label->
                            <code-><scroll->
                                <t->auto</t-> <f->main</f->(){
                                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                                    <t->uint</t->[<k->4</k->] ret;
                                    <w->for</w->(<t->int</t-> i <f->=</f-> <k->0</k->; i <f->&lt;</f-> a.<f->len</f->(); <f->++</f->){
                                        ret[i] <f->=</f-> <f->~</f->a[i];
                                    }
                                    <w->return</w-> ret;
                                }
                            </scroll-></code->
                        </fill->
                    </example->
                </div>
            </div>

            <p>
                When arrays are used as both the first and second operand of binary operators, the arrays must have identical length.
                The operation is performed between each element of the first operand and the respective element of the second operand,
                and the return value is an array of the same length containing the results of the operations.
            </p>
            <div style="min-width: 100%; display: flex;">
                <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-right: calc(var(--def-margin) / 2); display: inline-block;">
                    <example- style="margin: 0;">
                        <fill->
                            <label-></label->
                            <code-><scroll->
                                <t->void</t-> <f->main</f->(){
                                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                                    <t->int</t->[<k->4</k->] b;
                                    b = a;
                                }


                            </scroll-></code->
                        </fill->
                    </example->
                </div>
                <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-left: calc(var(--def-margin) / 2); display: inline-block;">
                    <example- style="margin: 0;">
                        <fill->
                            <label- class="nobefore">Equivalent code</label->
                            <code-><scroll->
                                <t->void</t-> <f->main</f->(){
                                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                                    <t->int</t->[<k->4</k->] b;
                                    <w->for</w->(<t->int</t-> i <f->=</f-> <k->0</k->; i <f->&lt;</f-> a.<f->len</f->(); <f->++</f->){
                                        a[i] <f->=</f-> a[i];
                                    }
                                }
                            </scroll-></code->
                        </fill->
                    </example->
                </div>
            </div>

            <p>
                When an array is used as the first operand of binary operators and a value of its base type is used as the second operand,
                the operation is performed between each element of the first operand and the value of second operand.
                The return value is an array of the same length of the first operand containing the results of the operations.
            </p>
            <div style="min-width: 100%; display: flex;">
                <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-right: calc(var(--def-margin) / 2); display: inline-block;">
                    <example- style="margin: 0;">
                        <fill->
                            <label-></label->
                            <code-><scroll->
                                <t->void</t-> <f->main</f->(){
                                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                                    <t->int</t-> b <f->=</f-> <k->8</k->;
                                    a <f->*=</f-> b;
                                }


                            </scroll-></code->
                        </fill->
                    </example->
                </div>
                <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-left: calc(var(--def-margin) / 2); display: inline-block;">
                    <example- style="margin: 0;">
                        <fill->
                            <label- class="nobefore">Equivalent code</label->
                            <code-><scroll->
                                <t->void</t-> <f->main</f->(){
                                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                                    <t->int</t-> b <f->=</f-> <k->8</k->;
                                    <w->for</w->(<t->int</t-> i <f->=</f-> <k->0</k->; i <f->&lt;</f-> a.<f->len</f->(); <f->++</f->){
                                        a[i] <f->*=</f-> b;
                                    }
                                }
                            </scroll-></code->
                        </fill->
                    </example->
                </div>
            </div>











            <!--------------------------------------------------------------------->
            <!-- Standard modules                                                -->
            <!--------------------------------------------------------------------->
            <h1 id="standard-modules"></h1>


            <!--------------------------------------------------------------------->
            <!-- Limits                                                          -->
            <!--------------------------------------------------------------------->
            <h1 id="limits-module"></h1>


            <!--------------------------------------------------------------------->
            <!-- Math                                                            -->
            <!--------------------------------------------------------------------->
            <h1 id="math-module"></h1>


            <!--------------------------------------------------------------------->
            <!-- Bits                                                            -->
            <!--------------------------------------------------------------------->
            <h1 id="bits-module"></h1>


            <!--------------------------------------------------------------------->
            <!-- Types                                                           -->
            <!--------------------------------------------------------------------->
            <h1 id="types-module"></h1>








            <!--------------------------------------------------------------------->
            <!-- Quick reference tabs                                            -->
            <!--------------------------------------------------------------------->
            <h1 id="quick-reference-tabs"></h1>




            <!--------------------------------------------------------------------->
            <!-- Character set                                                   -->
            <!--------------------------------------------------------------------->
            <h1 id="character-set"></h1>
            <p>

            </p>






            <!--
            //TODO
            //module.x module.y module.z
            module.pos.x
            module.pos.y
            module.pos.z
            ^ coordinates in current workspace




            sequence function //TODO
            sequence(start, end, step)




            //TODO add typographical conventions
            //TODO <sup>r</sup> = rvalue
            //TODO <sup>l</sup> = lvalue
            //TODO <sup>id</sup> = identifier

            -->





            <!--------------------------------------------------------------------->
            <!-- Complete examples                                               -->
            <!--------------------------------------------------------------------->
            <h1 id="complete-examples"></h1>

        </main-scroll->
    </right->


    <!-- Page format -->
    <script src="Slider.js"></script>
    <script src="Fix.js"></script>

    <!-- Functionalities -->
    <script src="CopyCode.js"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            initSlider();
            initFix();
            initCopyCode();
        });
    </script>
</body>
</html>







<!--
    //TODO COMPLETE EXAMPLES CONTAINING ANYTHING ANY POSSIBLE SYNTAX AND USAGE
    //TODO COMPLETE EXAMPLES CONTAINING ANYTHING ANY POSSIBLE SYNTAX AND USAGE
-->

<!--
-->