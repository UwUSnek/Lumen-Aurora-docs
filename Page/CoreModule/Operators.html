
<!--------------------------------------------------------------------->
<!-- Operators                                                       -->
<!--------------------------------------------------------------------->
<h1 id="core.operators"></h1>
<p style="margin-bottom: 20px;">
    The language defines a total of 44 operators.<br>
</p>
<ul>
    <li>Common operators<ul>
        <li>Arithmetic operators</li>
        <li>Bitwise operators</li>
        <li>Logical operators</li>
        <li>Relational operators</li>
    </ul></li>
    <li>Assignment operators</li>
    <li>Special operators</li>
</ul>


<!--------------------------------------------------------------------->
<!-- Common operators                                                -->
<!--------------------------------------------------------------------->
<h1 id="common-operators"></h1>
<p>
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO


    <!-- #include <stdio.h> -->
    <!-- #include <math.h> -->
    <!-- int sign2_(int a, int b) { -->
        <!-- static int s[2] = { 1, -1 }; -->
        <!-- printf("i = %-8d",((unsigned)a ^ (unsigned)b) >> 31); -->
        <!-- return s[((unsigned)a ^ (unsigned)b) >> 31]; -->
    <!-- } -->

    <!-- int div_(int a, int b) { --> //TODO this is mod
        <!-- return abs(a-a/b*b) * sign2_(a, b); -->
    <!-- } -->

    <!-- int main() { -->
        <!-- printf("n = %d\n", div_(59, -3)); -->
        <!-- printf("n = %d\n", div_(-59, -3)); -->
        <!-- printf("n = %d\n", div_(-59, 3)); -->
        <!-- printf("n = %d\n", div_(59, 3)); -->
    <!-- } -->

    //TODO the mod function returns the same sign of /
    //TODO add other types

    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
    //TODO
</p>
<p>
    <b>Common operators</b> include operators to perform <b>comparisons</b>, <b>arithmetic operations</b>, <b>bit manipulation</b> and <b>logical operations</b>.<br>
</p>
<div class="table-container"><table>
    <thead><tr>
        <th class="center">Priority</th>
        <th class="center">Operator</th>
        <th class="center">Function signature</th>
        <th class="left">Name</th>
        <th class="left">Category</th>
    </tr></thead>
    <tbody>
            <tr>
                <td class="center" rowspan="2">2</td>
                <td class="center"><code>++</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> &<p->n</p->) <f->++</f-></code></td>
                <td class="left">Postfix increment</td>
                <td class="left" rowspan="6">Arithmetic</td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>--</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> &<p->n</p->) <f->--</f-></code></td>
                <td class="left">Postfix decrement</td>
                <fake-td></fake-td>
            </tr>
        <!-- 3 -->
            <tr>
                <td class="center" rowspan="6">3</td>
                <td class="center"><code>++</code></td>
                <td class="center nowrap"><code><t->T</t-> <f->++</f-> (?<t->T</t-> &<p->n</p->)</code></td>
                <td class="left">Prefix increment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>--</code></td>
                <td class="center nowrap"><code><t->T</t-> <f->--</f-> (?<t->T</t-> &<p->n</p->)</code></td>
                <td class="left">Prefix decrement</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>+</code></td>
                <td class="center nowrap"><code><t->T</t-> <f->+</f-> (?<t->T</t-> <p->n</p->)</code></td>
                <td class="left">Promotion</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>-</code></td>
                <td class="center nowrap"><code><t->T</t-> <f->-</f-> (?<t->T</t-> <p->n</p->)</code></td>
                <td class="left">Inversion</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>~</code></td>
                <td class="center nowrap"><code><t->T</t-> <f->~</f-> (?<t->T</t-> <p->n</p->)</code></td>
                <td class="left">Bitwise NOT</td>
                <td class="left">Bitwise</td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>!</code></td>
                <td class="center nowrap"><code><t->bool</t-> <f->!</f-> (<t->bool</t-> <p->n</p->)</code></td>
                <td class="left">Logical NOT</td>
                <td class="left">Logical</td>
            </tr>
        <!-- 4 -->
            <tr>
                <td class="center" rowspan="3">4</td>
                <td class="center"><code>*</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->*</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Multiplication</td>
                <td class="left" rowspan="5">Arithmetic</td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>/</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->/</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Division</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>%</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->%</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Modulus</td>
                <fake-td></fake-td>
            </tr>
        <!-- 5 -->
            <tr>
                <td class="center" rowspan="2">5</td>
                <td class="center"><code>+</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->+</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Addition</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>-</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->-</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Subtraction</td>
                <fake-td></fake-td>
            </tr>
        <!-- 6 -->
            <tr>
                <td class="center" rowspan="2">6</td>
                <td class="center"><code>&lt;&lt;</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->&lt;&lt;</f-> (<t->uint</t-> <p->b</p->)</code></td>
                <td class="left">Left bit shift</td>
                <td class="left" rowspan="2">Bitwise</td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&gt;&gt;</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->&gt;&gt;</f-> (<t->uint</t-> <p->b</p->)</code></td>
                <td class="left">Right bit shift</td>
                <fake-td></fake-td>
            </tr>
        <!-- 7 -->
            <tr>
                <td class="center" rowspan="4">7</td>
                <td class="center"><code>&lt;</code></td>
                <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <p->a</p->) <f->&lt;</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Less than</td>
                <td class="left" rowspan="8">Relational</td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&lt;=</code></td>
                <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <p->a</p->) <f->&lt;=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Less or equal than</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&gt;</code></td>
                <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <p->a</p->) <f->&gt;</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Greater than</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&gt;=</code></td>
                <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <p->a</p->) <f->&gt;=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Greater or equal than</td>
                <fake-td></fake-td>
            </tr>
        <!-- 8 -->
            <tr>
                <td class="center" rowspan="4">8</td>
                <td class="center"><code>==</code></td>
                <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <p->a</p->) <f->==</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Equality</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>!=</code></td>
                <td class="center nowrap"><code><t->bool</t-> (?<t->T</t-> <p->a</p->) <f->!=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Inequality</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>=:</code></td>
                <td class="center nowrap"><code><t->bool</t-> (<t->baseof<!-- TODO REMOVE BASEOF --></t->(<t->T</t->) <p->a</p->) <f->=:</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Existence</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>!:</code></td>
                <td class="center nowrap"><code><t->bool</t-> (<t->baseof<!-- TODO REMOVE BASEOF --></t->(<t->T</t->) <p->a</p->) <f->!:</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Inexistence</td>
                <fake-td></fake-td>
            </tr>
        <!-- 9 -->
            <tr>
                <td class="center">9</td>
                <td class="center"><code>&</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->&</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Bitwise AND</td>
                <td class="left" rowspan="3">Bitwise</td>
            </tr>
        <!-- 10 -->
            <tr>
                <td class="center">10</td>
                <td class="center"><code>^</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->^</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Bitwise XOR</td>
                <fake-td></fake-td>
            </tr>
        <!-- 11 -->
            <tr>
                <td class="center">11</td>
                <td class="center"><code>|</code></td>
                <td class="center nowrap"><code><t->T</t-> (?<t->T</t-> <p->a</p->) <f->|</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Bitwise OR</td>
                <fake-td></fake-td>
            </tr>
        <!-- 12 -->
            <tr>
                <td class="center">12</td>
                <td class="center"><code>&&</code></td>
                <td class="center nowrap"><code><t->bool</t-> (<t->bool</t-> <p->a</p->) <f->&&</f-> (<t->bool</t-> <p->b</p->)</code></td>
                <td class="left">Logical AND</td>
                <td class="left" rowspan="3">Logical</td>
            </tr>
        <!-- 13 -->
            <tr>
                <td class="center">13</td>
                <td class="center"><code>^^</code></td>
                <td class="center nowrap"><code><t->bool</t-> (<t->bool</t-> <p->a</p->) <f->^^</f-> (<t->bool</t-> <p->b</p->)</code></td>
                <td class="left">Logical XOR</td>
                <fake-td></fake-td>
            </tr>
        <!-- 14 -->
            <tr>
                <td class="center">14</td>
                <td class="center"><code>||</code></td>
                <td class="center nowrap"><code><t->bool</t-> (<t->bool</t-> <p->a</p->) <f->||</f-> (<t->bool</t-> <p->b</p->)</code></td>
                <td class="left">Logical OR</td>
                <fake-td></fake-td>
            </tr>
    </tbody>
</table></div>

<h1 id="arithmetic-operators"></h1>
<p>
    Arithmetic operators can be used on any <a href="#primitive-types">primitive type</a> or <a href="#enums">enum</a>.
</p>
<p>
    <code>++</code>, <code>--</code>.<br>
    Increment and decrement operators add and subtract <code><k->1</k-></code> to the value of the operand.<br>
    Prefix operators return the value of the operand after the operation, postfix operators return the value of the operand before the operation.<br>
    Incrementing or decrementing a <code><t->bool</t-></code> has the same effect of converting its value to <code><t->int</t-></code>, performing the operation and converting it back to <code><t->bool</t-></code>.<br>
    Increment and decrement are the only common operators which modify the original value.
</p>
<p>
    <code>-</code>, <code>+</code>.<br>
    The promotion operator has no effect and only exists for completeness.<br>
    The inversion operator inverts the sign of the operand.<br>
    Inverting a <code><t->bool</t-></code> has no effect.
</p>
<p>
    <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>.<br>
    Addition, subtraction, multiplication, division and modulus operators perform their corresponding operations between two operators.<br>
    Using these operators with <code><t->bool</t-></code> values has the same effect of converting their value to <code><t->int</t-></code>, performing the operation and converting them back to <code><t->bool</t-></code>.<br>
    <br>
    Differently from GLSL and C++, the result of the modulus operator has the same sign of the result of the division.<br>
    Using <code><k->0</k-></code> as second operand of in division or modulus operator with <a href="#primitive-types">integral types</a> has <b>undefined</b> result.
</p>

<h1 id="logical-operators"></h1>
<p>
    Logical operators can only be used on <code><t->bool</t-></code> types.
</p>
<p>
    <code>!</code>, <code>&&</code>, <code>||</code>, <code>^^</code>.<br>
    NOT returns the inverse of the value.<br>
    AND, OR and XOR perform their corresponding operations between two values.<br>
    <div style="min-width: 100%; display: flex;">
        <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-right: calc(var(--def-margin) / 2); display: inline-block;">
            <div class="table-container"><table>
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>A || B</th>
                </tr>
                <tr>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
            </table></div>
            <div class="table-container"><table>
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>A && B</th>
                </tr>
                <tr>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
            </table></div>
        </div>
        <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-left: calc(var(--def-margin) / 2); display: inline-block;">
            <div class="table-container"><table>
                <tr>
                    <th>A</th>
                    <th>B</th>
                    <th>A ^^ B</th>
                </tr>
                <tr>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
                <tr>
                    <td class="center"><code><k->0</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
            </table></div>
            <div class="table-container"><table>
                <tr>
                    <th colspan="2">A</th>
                    <fake-td></fake-td>
                    <th>!A</th>
                </tr>
                <tr>
                    <td class="center" colspan="2"><code><k->1</k-></code></td>
                    <fake-td></fake-td>
                    <td class="center"><code><k->0</k-></code></td>
                </tr>
                <tr>
                    <td class="center" colspan="2"><code><k->0</k-></code></td>
                    <fake-td></fake-td>
                    <td class="center"><code><k->1</k-></code></td>
                </tr>
            </table></div>
        </div>
    </div>
</p>

<h1 id="bitwise-operators"></h1>
<p>
    Bitwise operators can be used on any <a href="#primitive-types">primitive type</a> or <a href="#enums">enum</a>.
    //TODO convert floats to int without changing the bit value
    //TODO floatBitsToInt intBitsToFloat
</p>
<p>
    <code>&lt;&lt;</code>, <code>&gt;&gt;</code>.<br>
    Bit shift operators shift the bits of the value of the left operand by the value of the right operand.<br>
    The right operand is converted to <code><t->uint</t-></code>. Discarded bits are set to <code><k->0</k-></code>.<br>
    Shifting non-<code><t->bool</t-></code> types by <code><f->sizeof</f->(<t->type</t->) * <k->8</k-></code> or more causes <b>undefined behaviour</b>.<br>
    Shifting <code><t->bool</t-></code> values is equivalent to setting them to <code><k->false</k-></code>.<br>
</p>
<p>
    <code>~</code>, <code>&</code>, <code>|</code>, <code>^</code>.<br>
    The bitwise NOT performs the logical NOT operation on every bit of the operand.<br>
    Bitwise AND, OR and XOR operators are equivalent to their corresponding logical operators, but the operation is performed between each bit of the two operands.<br>
    The types of the operand must have the same size.<br>
    <b><a href="#implicit-conversions">Implicit conversions</a> don't apply</b> on these operators. The return type has the same type of the first opeand.
    //TODO this is different than c++ and  glsl
</p>

<h1 id="relational-operators"></h1>
<p>
    Relational operators can be used on any <a href="#primitive-types">primitive type</a> or <a href="#enums">enum</a>,
    with the exception of <code>==</code>, <code>!=</code>, <code>=:</code> and <code>!:</code> which can be used with any type, including <a href="#structs">structs</a> and <a href="#typename">typenames</a>.
</p>
<p>
    <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.<br>
    The equality operator returns <code><k->true</k-></code> if the operands have the same value.<br>
    The inequality operator returns <code><k->true</k-></code> if the operands have different values.<br>
    The other operators return <code><k->true</k-></code> if the first operand is less than, greater than, less or equal than or greater or equal than the second operand, respectively.
</p>
<p>
    <code>=:</code>, <code>!:</code>.<br>
    The existence operator returns <code><k->true</k-></code> if the first operand has the value of one of the elements of the second operand.<br>
    The inexistence operator returns <code><k->true</k-></code> if all the elements of the second operand are different than the value of the first operand.<br>
    The second operand must be an array with a base type that is the same as the type of the first operand or can be implicitly converted to it.
</p>
<p>
    Their return value is the same as if they were declared in the following way:
</p>
<div style="min-width: 100%; display: flex;">
    <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-right: calc(var(--def-margin) / 2); display: inline-block;">
        <example- style="margin: 0;">
            <label->Existence</label->
            <div>
                <t->bool</t-> (<t->baseof</t->(<t->t</t->) <p->a</p->) <f->=:</f-> (?<t->t</t-> <p->b</p->) { <!-- TODO REMOVE BASEOF -->
                    <w->for</w->(<t->uint</t-> i = <k->0</k->; i &lt; b.<f->len</f->(); ++i) {
                        <w->if</w->(a == b[i]) <w->return</w-> <k->true</k->;
                    }
                    <w->return</w-> <k->false</k->;
                }
            </div>
        </example->
    </div>
    <div style="max-width: calc(50% - var(--def-margin) / 2); width: 50%; margin-left: calc(var(--def-margin) / 2); display: inline-block;">
        <example- style="margin: 0;">
            <label->Inexistence</label->
            <div>
                <t->bool</t-> (<t->baseof</t->(<t->t</t->) <p->a</p->) <f->!:</f-> (?<t->t</t-> <p->b</p->) { <!-- TODO REMOVE BASEOF -->
                    <w->for</w->(<t->uint</t-> i = <k->0</k->; i &lt; b.<f->len</f->(); ++i) {
                        <w->if</w->(a == b[i]) <w->return</w-> <k->false</k->;
                    }
                    <w->return</w-> <k->true</k->;
                }
            </div>
        </example->
    </div>
</div>




<!--------------------------------------------------------------------->
<!-- Assignment opeatos                                              -->
<!--------------------------------------------------------------------->
<h1 id="assignment-operators"></h1>
<p>
    <b>Assignment operators</b> are used to <b>change the value</b> of <a href="#left-and-right-values">l-value</a> symbols.<br>
    The original value is set to the result of the operation.
</p>
<p>
    The direct assignment (<code>=</code>) changes the value of the first operand to the one of the second operand.<br>
    It can be used with type, including typenames and composite types. <a href="#structs">Structs</a> must be of the same exact type to be assigned.
</p>
<p>
    The result of the other assignment operators and the types they can be used with are the same as their corresponding <a href="#common-operators">common operators</a>.<br>
</p>
<div class="table-container"><table>
    <thead><tr>
        <th class="center">Priority</th>
        <th class="center">Operator</th>
        <th class="center">Function signature</th>
        <th class="left">Name</th>
        <th class="left">Category</th>
    </tr></thead>
    <tbody>
        <!-- 16 -->
            <tr>
                <td class="center" rowspan="11">16</td>
                <td class="center"><code>=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Direct assignment</td>
                <td class="left" rowspan="11">Assignment</td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>+=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->+=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Addition assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>-=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->-=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Subtraction assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>*=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->*=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Multiplication assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>/=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->/=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Division assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>%=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->%=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Modulus assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->&=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Bitwise AND assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>^=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->^=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Bitwise XOR assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>|=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->|=</f-> (?<t->T</t-> <p->b</p->)</code></td>
                <td class="left">Bitwise OR assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&lt;&lt;=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->&lt;&lt;=</f-> (<t->uint</t-> <p->b</p->)</code></td>
                <td class="left">Left bit shift assignment</td>
                <fake-td></fake-td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <td class="center"><code>&gt;&gt;=</code></td>
                <td class="center nowrap"><code><t->T</t-> (<t->?T</t-> &<p->a</p->) <f->&gt;&gt;=</f-> (<t->uint</t-> <p->b</p->)</code></td>
                <td class="left">Right bit shift assignment</td>
                <fake-td></fake-td>
            </tr>
    </tbody>
</table></div>


<!--------------------------------------------------------------------->
<!-- Special operators                                               -->
<!--------------------------------------------------------------------->
<h1 id="special-operators"></h1>
<div class="table-container"><table>
    <thead><tr>
        <th class="center">Priority</th>
        <th class="center">Operator</th>
        <th class="center">Function signature</th>
        <th class="left">Name</th>
        <th class="left">Category</th>
    </tr></thead>
    <tbody>
        <!-- 1 -->
            <tr>
                <td class="center" >1</td>
                <td class="center"><elm-><code>(</code><code>)</code></elm-></td>
                <td class="center nowrap"><code><t->T</t-> <f->(</f-> (?<t->T</t-> <p->n</p->) <f->)</f-></code></td>
                <td class="left">Grouping</td>
                <td class="left" rowspan="10">Misc</td>
            </tr>
        <!-- 15 -->
            <tr>
                <td class="center">15</td>
                <td class="center"><elm-><code>?</code><code>:</code></elm-></td>
                <td class="center nowrap"><code><t->T</t-> (<t->bool</t-> <p->a</p->) <f->?</f-> (?<t->T</t-> <p->b</p->) <f->:</f-> (?<t->T</t-> <p->c</p->)</code></td>
                <td class="left">Selection operator</td>
            </tr>
    </tbody>
</table></div>
<p>
    <elm-><code>(</code><code>)</code></elm->.<br>
    The grouping operator is used to change the precedence of other functions.<br>
    The expression between the <code>(</code> and <code>)</code> characters is evaluated before the rest and used as a single value.
</p>
<p>
    <elm-><code>?</code><code>:</code></elm->.<br>
    The selection operator works like an <a href="#if-statement"><code><w->if</w-></code> statement</a>.<br>
    If the first operand is <code><k->true</k-></code>, it returns the value of the second operand.<br>
    If it is <code><k->false</k-></code>, the value of the third operand is returned.
</p>


<!--------------------------------------------------------------------->
<!-- Arithmetic exceptions                                           -->
<!--------------------------------------------------------------------->
<h1 id="arithmetic-exceptions"></h1>
<p>
    Only <b>certain</b> <a href="#primitive-types">floating point</a> <b>operations</b> that generate or use <b>special double literals</b> have <b>defined</b> result.<br>
    Their result is the same as in real arithmetic operations:
</p>
<div class="table-container"><table>
    <tr>
        <th>Operation</th>
        <th>Result</th>
    </tr>
    <!-- +*-, +*-/ -->
    <tr>
        <td class="center"><code>±n</code> + <code><k->±inf</k-></code></td>
        <td class="center" rowspan="3"><code><k->±inf</k-></code></td>
    </tr>
    <tr>
        <td class="center"><code>±n</code> - <code><k->±inf</k-></code></td>
        <fake-td></fake-td>
    </tr>
    <tr>
        <td class="center"><code>±n</code> * <code><k->±inf</k-></code></td>
        <fake-td></fake-td>
    </tr>
    <tr>
        <td class="center"><code>±n</code> / <code><k->±inf</k-></code></td>
        <td class="center"><code><k->0</k-></code></td>
    </tr>
    <tr>
        <td class="center"><code><k->±inf</k-></code> + <code>±n</code></td>
        <td class="center" rowspan="4"><code><k->±inf</k-></code></td>
    </tr>
    <tr>
        <td class="center"><code><k->±inf</k-></code> - <code>±n</code></td>
        <fake-td></fake-td>
    </tr>
    <tr>
        <td class="center"><code><k->±inf</k-></code> * <code>±n</code></td>
        <fake-td></fake-td>
    </tr>
    <tr>
        <td class="center"><code><k->±inf</k-></code> / <code>±n</code></td>
        <fake-td></fake-td>
    </tr>

    <!-- 2 infs -->
    <tr>
        <td class="center"><code><k->+inf</k-></code> + <code><k->+inf</k-></code></td>
        <td class="center"><code><k->+inf</k-></code></td>
    </tr>
    <tr>
        <td class="center"><code><k->-inf</k-></code> - <code><k->-inf</k-></code></td>
        <td class="center"><code><k->-inf</k-></code></td>
    </tr>
    <tr>
        <td class="center"><code><k->±inf</k-></code> * <code><k->±inf</k-></code></td>
        <td class="center"><code><k->±inf</k-></code></td>
    </tr>
    <tr>
        <th>Operation (special cases)</th>
        <th>Result</th>
    </tr>
    <tr>
        <td class="center"><code><k->0</k-></code> * <code><k->±inf</k-></code></td>
        <td class="center"><code><b>undefined</b></code></td>
    </tr>
    <tr>
        <td class="center"><code><k->±inf</k-></code> * <code><k->0</k-></code></td>
        <td class="center"><code><b>undefined</b></code></td>
    </tr>
</table></div>
<p>
    Where <code>n</code> is any non-<code><k->nan</k-></code>, non-<code><k->inf</k-></code> <a href="#primitive-types">floating point</a> value.
</p>
<p>
    All the above operations behave in the same way when performed through their corresponding <a href="#assignment-operators">assignment operators</a> (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>).<br>
    Direct assignments, relational operators and binary operators
        (<code>=</code>, <code>==</code>, <code>!=</code>, <code>=:</code>, <code>!:</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&</code>, <code>|</code>, <code>^</code>)
        are fully supported and can be used with <code><k->inf</k-></code> and any other non-<code><k->nan</k-></code> floating point value, according to the required types of each operator.<br>
    Any remaining operation with special floating point values has <b>undefined</b> result.
</p>
<p>
    The <code><f->isnan</f-></code> function can be used to check for <code><k->nan</k-></code> values.<br>
    Any operation with <code><k->nan</k-></code> values has <b>undefined</b> result.<br>
    Converting special values to non-floating point types also has <b>undefined</b> result.
</p>
<p>
    Some <b>special cases</b> of <b>integral operations</b> have <b>undefined</b> result:
</p>
<div class="table-container"><table>
    <tr>
        <th>Operation (special cases)</th>
        <th>Result</th>
    </tr>
    <tr>
        <td class="center"><code>n</code> / <code><k->0</k-></code></td>
        <td class="center"><code><b>undefined</b></code></td>
    </tr>
    <tr>
        <td class="center"><code>n</code> % <code><k->0</k-></code></td>
        <td class="center"><code><b>undefined</b></code></td>
    </tr>
</table></div>
<p>
    Where <code>n</code> is any non-<code><k->0</k-></code> <a href="#primitive-types">integral</a> value.
</p>
<p>
    Undefined results don't stop the program execution and are not detected in any way.
</p>


<!--------------------------------------------------------------------->
<!-- Array operations                                                -->
<!--------------------------------------------------------------------->
<h1 id="array-operations"></h1>
<p>
    All <a href="#common-operators">common</a> and <a href="#assignment-operators">assignment</a> operators in the core module, excluding <a href="#common-operators"><code>=:</code></a> and <a href="#common-operators"><code>!:</code></a>, can be used to operate on whole <a href="#arrays">arrays</a>.
</p>
<p>
    When arrays are used with unary operators, the operation is performed on all the elements of the array and the return value is an array of the same length,
    containing the results of the operations.
</p>
<split-example-container->
    <split-example-container-left->
        <example- style="margin: 0;">
            <label->Example</label->
            <div>
                <t->auto</t-> <f->main</f->(){
                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                    <w->return</w-> <f->~</f->a;
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- style="margin: 0;">
            <label->Equivalent code</label->
            <div>
                <t->auto</t-> <f->main</f->(){
                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                    <t->uint</t->[<k->4</k->] ret;
                    <w->for</w->(<t->int</t-> i <f->=</f-> <k->0</k->; i <f->&lt;</f-> a.<f->len</f->(); <f->++</f->){
                        ret[i] <f->=</f-> <f->~</f->a[i];
                    }
                    <w->return</w-> ret;
                }
            </div>
        </example->
    </split-example-container-right->
</split-example-container->

<p>
    When arrays are used as both the first and second operand of binary operators, the arrays must have identical length.
    The operation is performed between each element of the first operand and the respective element of the second operand,
    and the return value is an array of the same length containing the results of the operations.
</p>
<split-example-container->
    <split-example-container-left->
        <example- style="margin: 0;">
            <label->Example</label->
            <div>
                <t->void</t-> <f->main</f->(){
                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                    <t->int</t->[<k->4</k->] b;
                    b = a;
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- style="margin: 0;">
            <label->Equivalent code</label->
            <div>
                <t->void</t-> <f->main</f->(){
                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                    <t->int</t->[<k->4</k->] b;
                    <w->for</w->(<t->int</t-> i <f->=</f-> <k->0</k->; i <f->&lt;</f-> a.<f->len</f->(); <f->++</f->){
                        a[i] <f->=</f-> a[i];
                    }
                }
            </div>
        </example->
    </split-example-container-right->
</split-example-container->

<p>
    When an array is used as the first operand of binary operators and a value of its base type is used as the second operand,
    the operation is performed between each element of the first operand and the value of second operand.
    The return value is an array of the same length of the first operand containing the results of the operations.
</p>
<split-example-container->
    <split-example-container-left->
        <example- style="margin: 0;">
            <label->Example</label->
            <div>
                <t->void</t-> <f->main</f->(){
                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                    <t->int</t-> b <f->=</f-> <k->8</k->;
                    a <f->*=</f-> b;
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example- style="margin: 0;">
            <label->Equivalent code</label->
            <div>
                <t->void</t-> <f->main</f->(){
                    <t->int</t->[] a <f->=</f-> { <k->0</k->, <k->1</k->, <k->2</k->, <k->3</k-> };
                    <t->int</t-> b <f->=</f-> <k->8</k->;
                    <w->for</w->(<t->int</t-> i <f->=</f-> <k->0</k->; i <f->&lt;</f-> a.<f->len</f->(); <f->++</f->){
                        a[i] <f->*=</f-> b;
                    }
                }
            </div>
        </example->
    </split-example-container-right->
</split-example-container->