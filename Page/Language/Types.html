

<!--------------------------------------------------------------------->
<!-- Types                                                           -->
<!--------------------------------------------------------------------->
<h1 id="types"></h1>
<moveto-doc->
    <p>
        <b>Data types</b> define how <b><a href="#values">values</a></b> are <b>interpreted</b> during runtime and how they can be used within <a href="#expressions">expressions</a>.<br>
    </p>
    <p>
        Both languages are statically types.<br>
        Every <a href="#values">value</a> has an associated type, regardless of it being a <a href="#left-and-right-values">right</a> or a <a href="#left-and-right-values">left value</a>.<br>
        The type of each <a href="#values">value</a> must be known at compile time, as there are no runtime type informations.
    </p>
    <p>
        There are no classes, characters, matrices or vectors. The latter 2 are <a href="#symbol-aliases">aliases</a> of <a href="#arrays">array</a> types. See <a href="#standard-modules">Standard Modules</a>.
        //FIXME ^

        //TODO specify that types are a subset of symbol paths that contains any path to structs, enums, primitive types or special types, which are all considered symbols
    </p>
</moveto-doc->



<!--------------------------------------------------------------------->
<!-- Primitive types                                                 -->
<!--------------------------------------------------------------------->
<h1 id="primitive-types"></h1>
<moveto-doc->
    <p>Lumina and Aurora feature <b>7 primitive types</b>, which can be used to define more complex types such as <a href="#structs">structs</a>, <a href="#arrays">arrays</a> and <a href="#tuples">tuples</a>.</p>
    <p>
        These types are always defined and they act as if they were declared in the <a href="#core-module">core module</a>.<br>
        Primitive types are <b>not <a href="#keywords">keywords</a></b> and can be <a href="#name-shadowing">shadowed</a> like any other <a href="#semantic-elements">symbol</a>.
    </p>
    <p>The primitive types are:</p>
    <div class="table-container"><table>
        <tr>
            <th>Type name   </th>
            <th>Size (bytes)</th>
            <th>Value type  </th>
        </tr>
        <tr>
            <td class="center"><code><t->uint</t-></code></td>
            <td class="center">4</td>
            <td rowspan="2">Unsigned integral number</td>
        </tr>
        <tr>
            <td class="center"><code><t->ulong</t-></code></td>
            <td class="center">8</td>
        </tr>
        <tr>
            <td class="center"><code><t->int</t-></code></td>
            <td class="center">4</td>
            <td rowspan="2">Signed integral number</td>
        </tr>
        <tr>
            <td class="center"><code><t->long</t-></code></td>
            <td class="center">8</td>
        </tr>
        <tr>
            <td class="center"><code><t->float</t-></code></td>
            <td class="center">4</td>
            <td rowspan="2">Floating point number</td>
        </tr>
        <tr>
            <td class="center"><code><t->double</t-></code></td>
            <td class="center">8</td>
        </tr>
        <tr>
            <td class="center"><code><t->bool</t-></code></td>
            <td class="center">4</td>
            <td>Boolean value</td>
        </tr>
    </table></div>
    <p>
        All primitives types are convertible to each other. This is explained in detail in <a href="#implicit-conversions">Implicit conversions</a>.<br>
    </p>
</moveto-doc->


<!--------------------------------------------------------------------->
<!-- Integral types                                                  -->
<!--------------------------------------------------------------------->
<h1 id="integral-types"></h1>
<moveto-doc->
    <p>
        <code><t->int</t-></code>, <code><t->uint</t-></code>, <code><t->long</t-></code>, <code><t->ulong</t-></code>.<br>
        <b>Integral types</b> are used to <b>represent integers</b>.<br>
        Unsigned integers cannot represent negative numbers, but the maximum value is twice as high as their signed counterpart.
    </p>
    <p>
        All signed integral types use the Two's Complement to represent negative numbers.<br>
        Positive numbers and <code><k->0</k-></code> use the corresponding binary value in both signed and unsigned integral types.
    </p>
    <example->
            <div style="border-top-left-radius: var(--code-decoration-r);">
                                                <c->  1              31</c->
                                                <c->sign           value</c->
                                                <c->│┌───────────────┴─────────────┐</c->  <t->int</t->
                                                <sr->┕</sr-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                                                                <c->32</c->
                                                                <c->value</c->
                                                <c->┌────────────────┴─────────────┐</c->  <t->uint</t->
                                                <s->┕┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                <c->  1                              63</c->
                <c->sign                           value</c->
                <c->│┌───────────────────────────────┴─────────────────────────────┐</c->  <t->long</t->
                <sr->┕</sr-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                                                <c->64</c->
                                                <c->value</c->
                <c->┌────────────────────────────────┴─────────────────────────────┐</c->  <t->ulong</t->
                <s->┕┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
            </div>
    </example->
    <p>
        //TODO GL_EXT_shader_explicit_arithmetic_types_int64
    </p>
</moveto-doc->


<!--------------------------------------------------------------------->
<!-- Floating point types                                            -->
<!--------------------------------------------------------------------->
<h1 id="floating-point-types"></h1>
<moveto-doc->
    <p>
        <code><t->float</t-></code>, <code><t->double</t-></code>.<br>
        <b>Floating point types</b> are used to <b>approximately represent real numbers</b>.<br>
    </p>
    <p>
        Both floating point types are encoded according to the IEEE 754 Standard.<br>
        Positive and negative inf, nan and signed <code><k->0</k-></code> are all supported.<br>
        <code><k->+0</k-></code> and <code><k->-0</k-></code> are equal.
    </p>
    <example->
            <div style="border-top-left-radius: var(--code-decoration-r);">
                                                <c-> 1      8          23</c->
                                                <c->sign exponent   mantissa</c->
                                                <c->│┌───┴──┐┌──────────┴──────────┐</c->  <t->float</t->
                                                <sr->┕</sr-><sg->┷┷┷┷┷┷┷┷</sg-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                                                <c->00000000000000000000000000000000</c->  <k->+0.0</k->
                                                <c->10000000000000000000000000000000</c->  <k->-0.0</k->
                                                <c->01111111100000000000000000000000</c->  <k->+inf</k->
                                                <c->11111111100000000000000000000000</c->  <k->-inf</k->
                                                <c->011111111&lt;─────── not 0 ───────&gt;</c->  <k->nan</k->
                                                <c->111111111&lt;─────── not 0 ───────&gt;</c->  <k->nan</k->

                <c-> 1      11                           52</c->
                <c->sign  exponent                    mantissa</c->
                <c->│┌────┴────┐┌─────────────────────────┴────────────────────────┐</c->  <t->double</t->
                <sr->┕</sr-><sg->┷┷┷┷┷┷┷┷┷┷┷</sg-><s->┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                <c->0000000000000000000000000000000000000000000000000000000000000000</c->  <k->+0.0</k->
                <c->1000000000000000000000000000000000000000000000000000000000000000</c->  <k->-0.0</k->
                <c->0111111110000000000000000000000000000000000000000000000000000000</c->  <k->+inf</k->
                <c->1111111110000000000000000000000000000000000000000000000000000000</c->  <k->-inf</k->
                <c->011111111&lt;─────────────────────── not 0 ───────────────────────&gt;</c->  <k->nan</k->
                <c->111111111&lt;─────────────────────── not 0 ───────────────────────&gt;</c->  <k->nan</k->
            </div>
    </example->
    <p>
        inf values are generated as required by the standard.<br>
        nan values are not generated for consistency and performance reasons.
    </p>
</moveto-doc->


<!--------------------------------------------------------------------->
<!-- Boolean type                                                    -->
<!--------------------------------------------------------------------->
<h1 id="boolean-type"></h1>
<moveto-doc->
    <p>
        <code><t->bool</t-></code>.<br>
        The <b>Boolean type</b> is used to <b>represent boolean values</b>.<br>
        <code><k->true</k-></code> and <code><k->false</k-></code> are the only values that can be stored in a <code><t->bool</t-></code>.
    </p>
    <example->
            <div style="border-top-left-radius: var(--code-decoration-r);">
                                <c->32</c->
                            <c->value</c->
                <c->┌───────────────┴──────────────┐</c->  <t->bool</t->
                <s->┕┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┷┙</s->
                <c->00000000000000000000000000000001</c->  <k->true</k->
                <c->00000000000000000000000000000000</c->  <k->false</k->
            </div>
    </example->
    <p>
        Booleans purposely waste 31 bits for performance reasons.<br>
        Smaller types require additional bitwise operations and expensive conversions between the CPU and GPU data.
    </p>
</moveto-doc->













<!--------------------------------------------------------------------->
<!-- Enums                                                           -->
<!--------------------------------------------------------------------->
<h1 id="enums"></h1>
<moveto-doc->
    <p>
        <b>Enums</b> are used to create <b>new types</b> whose allowed values are a <b>subset</b> of the possible values of their <b>base <a href="#types">type</a></b> and can only be used throught their names.<br>
        The base <a href="#types">type</a> of an enum is specified after its name and, differently from most languages, it can be any type, including <a href="#structs">structs</a> or other enums.<br>
        Enum elements are declared in the same way as <a href="#variables">variables</a>, but the type is not specified explicitly and their initializer values must be <a href="#compile-time-values">known at compile time</a>.<br>
        These elements identify the allowed values.
    </p>
    <p>
        Elements of <a href="#integral-types">integral</a> enums which are not initialized are given the value of the preceding element + <code><k->1</k-></code>, or <code><k->0</k-></code> if first.<br>
        Elements of enums with any other base <a href="#types">type</a> must always be initialized.<br>
        Multiple elements can have identical <a href="#values">values</a>, but each <a href="#identifiers">identifier</a> can only be declared once.<br>
        Empty enums are allowed.
    </p>

    <syntax->
        <label- id="copy.syntax--declaration-enum">Declaration syntax</label->
        <label- id="copy.syntax--declaration-enum-element">Element declaration syntax</label->
    </syntax->

    <p>
        Enum elements are <a href="#constant-values">constant values</a>.<br>
        <a href="#expressions">Expressions</a> of enum <a href="#types">type</a> are <a href="#implicit-conversions">implicitly convertible</a> to any type their base type is implicitly convertible to and the base type itself.<br>
        This is detailedly explained in <a href="#implicit-conversions">Implicit conversions</a>.
    </p>
</moveto-doc->
<moveto-examples->
    <example->
        <label->Example</label->
        <div>
            <w->enum</w-> <t->e</t-> : <t->int</t-> {
                a, b;              <c->// a = 0, b = 1</c->
                c = <k->-266250</k->;       <c->// c = -266250</c->
                d, e = <k->0</k->;          <c->// d = -266249, e = 0</c->
            }

            <t->float</t-> <f->main</f->(){
                <w->return</w-> e.<k->c</k->; <c->// Implicitly convert e to float</c->
            }
        </div>
    </example->
</moveto-examples->














<!--------------------------------------------------------------------->
<!-- Struct enums                                                    -->
<!--------------------------------------------------------------------->
<h1 id="struct-enums"></h1>
<moveto-doc->
    <p style="margin-bottom: 0;">
        Enums with a <b>struct</b> as <b>base type</b> behave <b>slightly differently</b> than standard enums:<br>
    </p>
    <ul><ul>
        <li>Elements are initialized through one of the constructors of the base type and destroyed before the process ends as if they were global variables.</li>
        <li>The size of the type is always 8 bytes, regardless of the size of the base struct.</li>
        <li>Struct methods declared in the base struct are not inherited.</li>
        <li>Creating or destroying enum values doesn't call constructors or destructors declared in the base struct.</li>
    </ul></ul>
</moveto-doc->
<moveto-examples->
    <example->
        <label->Example</label->
        <div>
            <w->struct</w-> <t->s</t-> {
                <t->uint</t-> n1, n2;
            }

            <w->enum</w-> <t->e</t-> : <t->s</t-> {
                a = (<k->10</k->, <k->90</k->),
                b = (<k->8</k->, <k->140</k->),
                c = (<k->50</k->, <k->60</k->)
            }
        </div>
    </example->
</moveto-examples->













//TODO improve wording
<!--------------------------------------------------------------------->
<!-- Automatic enum scoping                                          -->
<!--------------------------------------------------------------------->
<h1 id="automatic-enum-scoping"></h1>
<moveto-doc->
    <p>
        <b>Automatic enum scoping</b> can be used to <b>skip</b> the idenfiers of <b>parent scopes</b> in a symbol path and reference an enum element through its name alone.<br>
        This is done by replacing the path to the element with a single <code>.</code> keyword.<br>
        Automatic scoping can only be used where the only accepted values are of a specific enum type.
    </p>
</moveto-doc->
<moveto-exmaples->
    <split-example-container->
        <split-example-container-left->
            <example->
                <label->Example</label->
                <div>
                    <w->import</w-> <s->&lt;io&gt;</s->;

                    <w->enum</w-> <t->day</t-> : <t->uint</t-> {
                        <k->mon</k->, <k->two</k->, <k->wed</k->, <k->thu</k->, <k->fri</k->, <k->sat</k->, <k->sun</k->;
                    }

                    <t->void</t-> <f->check_day</f->(<t->day</t-> <p->d</p->) {
                        <w->match</w-> d {
                            .<k->mon</k-> to .<k->fri</k-> { io.<f->print</f->(<s->"TwT"</s->); }
                            .<k->sat</k-> or .<k->sun</k-> { io.<f->print</f->(<s->"OwO"</s->); }
                        }
                    }

                    <t->void</t-> <f->main</f->(){
                        <f->check_day</f->(.<k->sun</k->);
                        io.print("\n");
                        <f->check_day</f->(.<k->mon</k->);
                    }
                </div>
            </example->
        </split-example-container-left->
        <split-example-container-right->
            <example->
                <label->Output</label->
                <div>
                    OwO
                    TwT<cursor-></cursor->
                </div>
            </example->
        </split-example-container-right->
    </split-example-container->
</moveto-exmaples->







<!--------------------------------------------------------------------->
<!-- Structs                                                         -->
<!--------------------------------------------------------------------->
<h1 id="structs"></h1>
<moveto-doc->
    <p>
        <b>Structs</b> are used to <b>create</b> new <b>types</b> composed by 0 or more separate members that can have differing type.<br>
        The members are declared in the same way as <a href="#variables">variables</a> but cannot have initializer values.
    </p>
    <p>
        Empty structs are allowed.<br>
        Struct members can be of any <a href="#types">type</a>, including other structs.
    </p>
    <syntax->
        <label- id="copy.syntax--declaration-struct">Declaration syntax</label->
        <label- id="copy.syntax--declaration-struct-signature">Struct signature</label->
        <label- id="copy.syntax--declaration-struct-body">Struct body</label->
        <label- id="copy.syntax--declaration-specialization-constraint">Specialization constraint</label->
        <label- id="copy.syntax--declaration-struct-member">Member declaration syntax</label->
    </syntax->
</moveto-doc->
<moveto-examples->
    <example->
        <label->Example</label->
        <div>
            <w->struct</w-> <t->idk</t-> {
                <t->uint</t-> a, b;        <c->// Ok</c->
                <t->double</t->[<k->4</k->] c;      <c->// Ok</c->
            }

            <t->void</t-> <f->main</f->(){
                <t->idk</t-> var;
                var.a = <k->4</k->;              <c->// Ok, var = (4, ?, ?)</c->
                var.b = <k->var.a</k-> * <k->4</k->;      <c->// Ok, var = (4, 8, ?)</c->
            }
        </div>
    </example->
</moveto-examples->









<!--------------------------------------------------------------------->
<!-- Struct methods                                                  -->
<!--------------------------------------------------------------------->
<h1 id="struct-methods"></h1>
<moveto-doc->
    <p>
        <b>Structs</b> can contain <b>functions</b>. These functions are called <b>methods</b>.<br>
        They are part of the struct scope and are called in the same way as standard functions.
    </p>
    <p>
        Struct methods can access the members of the value they are called on, and the special identifier <code>this</code> can be used to reference the value itself.<br>
        If the value they are called on is a constant, <code>this</code> and all the members are also constants. Attempting to change their value generates a semantic error.<br>
        Template methods are allowed.
    </p>
</moveto-doc->
<moveto-examples->
    <split-example-container->
        <split-example-container-left->
            <example->
                <label->Example</label->
                <div>
                    <c->// 2D uint vector</c->
                    <w->struct</w-> <t->uint2</t-> {
                        <t->uint</t-> x, y;

                        <t->void</t-> <f->print</f->(){
                            io.<f->print</f->(<s->"x:"</s-> <f->+</f-> <t->str</t->(x));
                            io.<f->print</f->(<s->"\ny: "</s-> <f->+</f-> <t->str</t->(this.y));
                            <c->// Notice that this. is not required when accessing members</c->
                        }

                    }

                    <t->void</t-> <f->main</f->(){
                        <t->uint2</t-> v = { <k->15</k->, <k->9</k-> };
                        <k->v</k->.<f->print</f->();
                    }
                </div>
            </example->
        </split-example-container-left->
        <split-example-container-right->
            <example->
                <label->Output</label->
                <div>
                    x: 15
                    y: 9<cursor-></cursor->
                </div>
            </example->
        </split-example-container-right->
    </split-example-container->
</moveto-examples->













<!--------------------------------------------------------------------->
<!-- Constructor function                                            -->
<!--------------------------------------------------------------------->
<h1 id="constructor-function"></h1>
<moveto-doc->
    <p>
        The <b>constructor</b> function is a <b>special</b> struct <b>method</b> that is called each time a value of its parent struct type is created.<br>
        It has <b>no name</b> and <b>no explicit return type</b> and it's declared using the <code><w->constructor</w-></code> meta keyword. Constructor calls always return an l-value of type their parent struct.<br>
        Differently from other struct methods, the constructor can modify members when called on constant values.
    </p>
    <p>
        Each struct can only have one constructor, but it can be specialized.<br>
        Template constructors are allowed, although it is not possible to reference a specific template through the <elm-><code>&lt;</code><code>&gt;</code></elm->
        meta keyword while creating a new value, meaning that the declaration is chosen solely based on the passed arguments.<br>
        Constructors cannot be called after the value has been created, but each constructor declaration can call other declarations in the same struct.
    </p>
    <p>
        By default, each struct contains one implicit constructor that takes a reference parameter for each member in the same order in which they were declared and initializes them by copying the value from their respective parameter.<br>
        This constructor is not present in structs declared using the <code><w->nodefault</w-></code> meta keyword.<br>
        Constructors are allowed to take no arguments.
    </p>
</moveto-doc->
<moveto-examples->
    <example->
        <label->Example</label->
        <div>
            <w->struct</w-> <t->uint2</t-> {
                <t->uint</t-> x, y;
            }


            <w->struct</w-> <t->uint3</t-> <w->nodefault</w-> {
                <t->uint</t-> x, y, z;

                <w->constructor</w->(<t->uint2</t-> <p->a</p->, <t->uint</t-> <p->b</p->) {
                    x <f->=</f-> a.x;
                    y <f->=</f-> a.y;
                    z <f->=</f-> b;
                }

                <w->constructor</w->(<t->uint</t-> <p->a</p->, <t->uint2</t-> <p->b</p->) {
                    x <f->=</f-> a;
                    y <f->=</f-> b.x;
                    z <f->=</f-> b.y;
                }
            }


            <t->void</t-> <f->main</f->(){
                <t->uint2</t-> a = { <k->1</k->, <k->2</k-> };     <c->// Default constructor</c->
                <t->uint3</t-> b = { <k->a</k->, <k->5</k-> };     <c->// User-defined constructor</c->
                <t->uint3</t-> c = { <k->5</k->, <k->a</k-> };     <c->// User-defined constructor</c->
                <c->//uint3 d = (1, 2, 3);</c->  <ce->// Error, no suitable constructor declaration</ce->
            }
        </div>
    </example->
</moveto-examples->










<!--------------------------------------------------------------------->
<!-- Destructor function                                             -->
<!--------------------------------------------------------------------->
<h1 id="destructor-function"></h1>
<moveto-doc->
    <p>
        The <b>destructor</b> function is a <b>special</b> struct <b>method</b> that is called each time a value of its parent struct type is destroyed.<br>
        It has <b>no name</b> and <b>no return value</b> and it's declared using the <code><w->destructor</w-></code> meta keyword.<br>
    </p>
    <p>
        Each struct can only have one destructor. It cannot be specialized and cannot take any argument, nor can it be called explicitly.<br>
        Template destructors are not allowed.<br>
        There is no default destructor.
    </p>
</moveto-doc->
<moveto-examples->
    <split-example-container->
        <split-example-container-left->
            <example->
                <label->Example</label->
                <div>
                    <w->import</w-> <s->&lt;io&gt;</s->;
                    <t->int</t-> last = <k->0</k->;

                    <w->struct</w-> <t->s</t-> {
                        <t->float</t-> n;
                        <t->int</t-> i;

                        <w->constructor</w->(<t->float</t-> <p->n</p->){
                            i <f->=</f-> last<f->++</f->;
                            this.n <f->=</f-> n;
                        }

                        <w->destructor</w->(){
                            io.<f->print</f->(<s->"Destroyed instance n."</s-> <f->+</f-> <t->str</t->(i) <f->+</f-> <s->"\n"</s->);
                        }
                    }


                    <t->void</t-> <f->main</f->(){
                        <t->s</t-> var = { <k->0.5</k-> };
                    }
                </div>
            </example->
        </split-example-container-left->
        <split-example-container-right->
            <example->
                <label->Output</label->
                <div>
                    Destroyed instance n.0
                    Destroyed instance n.1
                    <cursor-></cursor->
                </div>
            </example->
        </split-example-container-right->
    </split-example-container->
</moveto-examples->












<!--------------------------------------------------------------------->
<!-- Struct specialization                                           -->
<!--------------------------------------------------------------------->
<h1 id="struct-specialization"></h1>
<moveto-doc->
    <p>
        Struct specialization allows structs to contain different methods and data based on user-defined constraints.<br>
        This is achieved by declaring the same struct multiple times. Each declaration must be <b>unique</b>.
        Arguments passed to the constructor don't affect the chosen struct declaration.
    </p>
    <p>
        Struct declarations whose specialization constraint is not satisfied are discarded.<br>
        As with routine specialization, if zero or more than one declaration is suitable, a semantic error is generated.
    </p>
</moveto-doc->
<moveto-examples->
    <split-example-container->
        <split-example-container-left->
            <example->
                <label->Example</label->
                <div>
                    <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <w->struct</w-> <t->s</t-> <w->when</w->(<t->t</t->::id <f->!=</f-> <t->void</t->::id) {
                        <t->t</t-> n;
                        <w->constructor</w->() {
                            io.<f->print</f->(<s->"Not void\n"</s->);
                        }
                    }
                    <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <w->struct</w-> <t->s</t-> <w->when</w->(<t->t</t->::id <f->==</f-> <t->void</t->::id) {
                        <w->constructor</w->() {
                            io.<f->print</f->(<s->"Void\n"</s->);
                        }
                    }

                    <t->void</t-> <f->main</f->(){
                        <t->t</t->&lt;<t->int</t->&gt;  <k->a</k->;
                        <t->t</t->&lt;<t->void</t->&gt; <k->b</k->;
                    }
                </div>
            </example->
        </split-example-container-left->
        <split-example-container-right->
            <example->
                <label->Output</label->
                <div>
                    Not void
                    Void
                    <cursor-></cursor->
                </div>
            </example->
        </split-example-container-right->
    </split-example-container->
</moveto-examples->















<!--------------------------------------------------------------------->
<!-- Special types                                                   -->
<!--------------------------------------------------------------------->
<h1 id="special-types"></h1>
<moveto-doc->
    //TODO
</moveto-doc->






<!--------------------------------------------------------------------->
<!-- Void type                                                       -->
<!--------------------------------------------------------------------->
<h1 id="void-type"></h1>
<moveto-doc->
    <p>
        The <code><t->void</t-></code> type is used to declare routines that don't return any value.<br>
        It has no other purpose but it can be passed to type template parameters to generate different declarations.
    </p>
</moveto-doc->
<moveto-examples->
    <example->
        <label->Example 1</label->
        <div>
            <f->uint</f-> counter = <k->0</k->;
            <t->void</t-> <f->inc_counter</f->(){ counter<f->++</f->; }

            <t->void</t-> <f->main</f->(){
                <f->inc_counter</f->();
            }
        </div>
    </example->
    <split-example-container->
        <split-example-container-left->
            <example->
                <label->Example 2</label->
                <div>
                    <w->import</w-> <s->&lt;io&gt;</s->;
                    <w->template</w->&lt;<w->type</w-> <t->t</t->&gt; <t->void</t-> <f->print_template_info</f->()
                    <w->when</w->(<t->t</t->::<k->id</k-> <f->!=</f-> <t->void</t->::<k->id</k->) { io.<f->print</f->(<s->"not void"</s->); }
                    <w->when</w->(<t->t</t->::<k->id</k-> <f->==</f-> <t->void</t->::<k->id</k->) { io.<f->print</f->(<s->"void"</s->); }

                    <t->void</t-> <f->main</f->(){
                        <f->print_template_info</f->&lt;<t->void</t->&gt;();
                        <f->print_template_info</f->&lt;<t->int</t->&gt;();
                    }
                </div>
            </example->
        </split-example-container-left->
        <split-example-container-right->
            <example->
                <label->Output</label->
                <div>
                    void
                    not void
                    <cursor-></cursor->
                </div>
            </example->
        </split-example-container-right->
    </split-example-container->
</moveto-examples->







<!--------------------------------------------------------------------->
<!-- Pointer types                                                   -->
<!--------------------------------------------------------------------->
<h1 id="pointer-types"></h1>
<moveto-doc->
    <p>
        Pointer types are implicit types that can store a memory address of a specific type. Their size is always 8 byes.<br>
        They are referenced through the symbol path of the pointed type, also known as base type, followed by the <code>@</code> keyword.<br>
        The <code><t->const</t-></code> meta keyword can be placed between the base type and the <code>@</code> keyword to reference the corresponding const pointer. Const pointers are detailedly explained in <a href="#const-qualifier">Const qualifier</a>.
    </p>
    <p>
        The <code>@</code> keyword is also used to access the value pointed by a pointer expression.<br>
        The address of any l-value can be retrieved through the <code>$</code> keyword.
    </p>
    <p>
        Pointer types don't have to be declared. Each existing type but <code><t->void</t-></code> has its own corresponding pointer type and <code><t->const</t-></code> pointer type ready to use, including the pointer types themselves.
        <code><t->void</t-></code> pointers are not allowed.<br>
        There is no limit to the amount of nested pointer types one can use as base type.
    </p>
</moveto-doc->
<moveto-examples->
    //TODO add memory allocation examples
    <split-example-container->
        <split-example-container-left->
            <example->
                <label->Example 1</label->
                <div>
                    <w->import</w-> <s->&lt;io&gt;</s->;

                    <t->void</t-> <f->main</f->(){
                        <t->int</t-> n = <k->5</k->;
                        <t->int@</t-> p = $<k->n</k->;

                        @p = <k->6</k->;
                        io.<f->print</f->(<t->str</t->(<k->n</k->));
                    }
                </div>
            </example->
        </split-example-container-left->
        <split-example-container-right->
            <example->
                <label->Output</label->
                <div>
                    6<cursor-></cursor->
                </div>
            </example->
        </split-example-container-right->
    </split-example-container->
    <split-example-container->
        <split-example-container-left->
            <example->
                <label->Example 2 - Nested pointer types</label->
                <div>
                    <w->import</w-> <s->&lt;io&gt;</s->;

                    <t->void</t-> <f->main</f->(){
                        <t->int</t-> a = <k->5</k->;
                        <t->int@</t-> p;
                        <t->int@@</t-> p2 = $p;
                        @p2 = $<k->n</k->;

                        @@p2 = <k->6</k->;
                        io.<f->print</f->(<t->str</t->(<k->a</k->));
                    }
                </div>
            </example->
        </split-example-container-left->
        <split-example-container-right->
            <example->
                <label->Output</label->
                <div>
                    6<cursor-></cursor->
                </div>
            </example->
        </split-example-container-right->
    </split-example-container->
</moveto-examples->








<!--------------------------------------------------------------------->
<!-- Function types                                                  -->
<!--------------------------------------------------------------------->
<h1 id="function-types"></h1>
<moveto-doc->
    <p>
        Function types are implicit types that can store functions.<br> //TODO add size info
        These are used for callbacks and higher level functions.<br>
        They are referenced by specifying the return type, followed by <elm-><code>(</code><code>)</code></elm-> keywords containing the types of each parameter.
    </p>
    <p>
        Referencing a function or using a function inline declaration without calling them generate function r-values which can be stored in function types.<br>
        This is only allowed for non-specialized routines, as specialization is not compatible with function values. The only exception are <a href="#default-values">default values</a> which get disabled when retrieving the function value.<br>
        Operators cannot be stored as values, but it's still possible to create a wrapper function and save that instead.
    </p>
    <p>
        Function type expressions can be called like standard functions.<br>
        As with pointers, function types don't require a declaration in order to be used.<br>
        Function values can only be implicitly converted based on the constness of their parameters. This is explained in <a href="#implicit-conversions">Implicit conversions</a>.
    </p>
</moveto-doc->
<moveto-examples->
    <split-example-container->
        <split-example-container-left->
            <example->
                <label->Example 1 - Callback</label->
                <div>
                    <w->import</w-> <s->&lt;io&gt;</s->;

                    <w->struct</w-> <t->t</t-> {
                        <w->constructor</w->(<t->void</t->() <p->callback</p->) {
                            <f->callback</f->();
                        }
                    }

                    <t->void</t-> <f->print_owo</f->(){
                        io.<f->print</f->(<s->"OwO"</s->);
                    }

                    <t->void</t-> <f->main</f->(){
                        <t->t</t-> a = { <t->void</t->(){ io.<f->print</f->(<s->"Variable \"a\" created\n"</s->); } };
                        <t->t</t-> b = { <f->print_owo</f-> };
                    }
                </div>
            </example->
        </split-example-container-left->
        <split-example-container-right->
            <example->
                <label->Output</label->
                <div>
                    Variable "a" created
                    OwO<cursor-></cursor->
                </div>
            </example->
        </split-example-container-right->
    </split-example-container->
    <split-example-container->
        <split-example-container-left->
            <example->
                <label->Example 2 - Higher level function</label->
                <div>
                    <w->import</w-> <s->&lt;io&gt;</s->;

                    <t->void</t-> <f->map</f->(<t->arr</t->&lt;?<t->t</t->&gt;<t->*</t-> <p->a</p->, ?<t->r</t->(<t->t*</t->) <p->f</p->) {
                        <w->for</w->(e <w->in</w-> a) <f->f</f->(e);
                    }

                    <t->void</t-> <f->main</f->(){
                        <t->arr</t->&lt;<f->int</f->&gt; a = { <k->1</k->, <k->2</k-> };
                        io.<f->print</f->(<s->"Before map: "</s-> <f->+</f-> <t->str</t->(<k->a</k->) <f->+</f-> <s->"\n"</s->);

                        <f->map</f->($<k->a</k->, <t->void</t->(<t->int@</t-> <p->n</p->){ @n <f->*=</f-> <k->5</k->; });
                        io.<f->print</f->(<s->"After  map: "</s-> <f->+</f-> <t->str</t->(<k->a</k->));
                    }
                </div>
            </example->
        </split-example-container-left->
        <split-example-container-right->
            <example->
                <label->Output</label->
                <div>
                    Before map: [1, 2]
                    After  map: [5, 10]<cursor-></cursor->
                </div>
            </example->
        </split-example-container-right->
    </split-example-container->
</moveto-examples->











<!--------------------------------------------------------------------->
<!-- Const qualifier                                                 -->
<!--------------------------------------------------------------------->
<h1 id="const-qualifier"></h1>
<moveto-doc->
    <p>
        When used between the base type and the <code>@</code> keyword of a pointer type, the <b><code><t->const</t-></code> qualifier</b> indicates that the type is a <b>const pointer</b>.<br>
        Data accessed by dereferencing a <code><t->const</t-></code> pointer value cannot be modified.<br>
        Non-<code><t->const</t-></code> pointers are implicitly convertible to their respective <code><t->const</t-></code> pointer type. This is explained in <a href="implicit-conversions">Implicit coversions</a>.
    </p>
    <p>
        <b><code><w->const</w-></code></b> can also be used before the name of a <b>variable</b> or <b>routine parameter</b> to <b>prevent them from being modified</b> after their declaration, although this doesn't turn the type of the symbol into a const type.<br>
        The address of <code><w->const</w-></code> variables or <code><w->const</w-></code> routine parameters is always returned as a <code><t->const</t-></code> pointer.
    </p>
</moveto-doc->
<moveto-examples->
    <example->
        <label->Example 1 - Const pointer</label->
        <div>
            <t->void</t-> <f->main</f->(){
                <t->int</t-> var = <k->8</k->;
                <t->int const@</t-> ptr = @<k->var</k->;

                <k->var</k-> <f->=</f-> <k->9</k->;     <c->// Ok</c->
                <c->//@ptr = 9;</c->  <ce->// Error, cannot modify data pointed by const pointers</ce->
            }
        </div>
        <label->Example 2 - Const variable</label->
        <div>
            <t->void</t-> <f->main</f->(){
                <t->int</t-> var <w->const</w-> = <k->8</k->;

                <c->var = 9;</c->  <ce->// Error, cannot modify const variables</ce->
            }
        </div>
    </example->
</moveto-examples->














<!--------------------------------------------------------------------->
<!-- Auto specifier                                                  -->
<!--------------------------------------------------------------------->
<h1 id="auto-specifier"></h1>
<moveto-doc->
    <p>
        The <b><code><t->auto</t-></code></b> specifier can be <b>used as</b> a <b><a href="#types">type</a></b> when declaring a <a href="#semantic-elements">symbol</a>.<br>
        The actual <a href="#types">type</a> of the <a href="#semantic-elements">symbol</a> is determined by the initializer value if a <a href="#variables">variable</a>, or by the <a href="#return-statement">return value</a> if a <a href="#routines">routine</a>.<br>
    </p>
    <p>
        <code><t->auto</t-></code> is not allowed in <a href="#structs">struct</a> member declarations or <a href="#routine-parameters">routine parameters</a>.<br>
        The <a href="#types">types</a> of the <a href="#expressions">expressions</a> returned from an <code><t->auto</t-></code> <a href="#routines">routine</a> must match.
    </p>
</moveto-doc->
<moveto-examples->
    <example->
        <label->Example 1</label->
        <div>
            <t->auto</t-> <f->func</f->(){
                <w->return</w-> <k->true</k->;        <c->// func has type bool</c->
            }

            <t->auto</t-> <f->main</f->(){
                <t->auto</t-> a = <k->2</k->;         <c->// a has type ulong</c->
                <t->auto</t-> b = <k->5.4</k-> * <k->a</k->;   <c->// b has type double</c->
                <t->auto</t-> c = <f->func</f->();    <c->// c has type bool</c->
                <c->// No return statement, main has type void</c->
            }
        </div>
    </example->
</moveto-examples->




<!--------------------------------------------------------------------->
<!-- Typeof specifier                                                -->
<!--------------------------------------------------------------------->
<h1 id="typeof-specifier"></h1>
<moveto-doc->
    <p>
        The <b><code><t->typeof</t-></code></b> specifier is used in the same way as <code><t->auto</t-></code>, but the <b>type</b> is defined by the <b><a href="#expressions">expression</a></b> that is passed to it.<br>
        The <a href="#expressions">expression</a> is exclusively used to determine the type and never evaluated.<br>
        Circular dependencies generate a semantic error. //TODO LINK
    </p>
</moveto-doc->
<moveto-examples->
    <example->
        <label->Example 1</label->
        <div>
            <t->auto</t-> <f->f</f->(){}                  <c->// f has type void</c->

            <t->typeof</t->(<f->f</f->()) <f->main</f->(){         <c->// main has type void</c->
                <t->int</t-> a = <k->1</k->;              <c->// a has type int</c->
                <t->typeof</t->(<k->a</k->) b = <k->a</k-> * <k->2</k->;    <c->// b has type int</c->
            }
        </div>
    </example->
    <example->
        <label->Example 2</label->
        <div>
            <c->//typeof(b) a(){};</c->  <ce->//Error, circular dependency with b</ce->
            <c->//typeof(a) b(){};</c->  <ce->//Error, circular dependency with a</ce->
        </div>
    </example->
</moveto-examples->









































<!--------------------------------------------------------------------->
<!-- Implicit conversions                                            -->
<!--------------------------------------------------------------------->
<h1 id="implicit-conversions"></h1>
<moveto-doc->
    <p>
        <b>Implicit conversions</b> are performed when an <b><a href="#expressions">expression</a></b> of the <b>incorrect <a href="#types">type</a></b> is used in place of the expected one.<br>
        This includes anything whose syntax requires an <a href="#expressions">expression</a>.<br>
    </p>
</moveto-doc->






<!--------------------------------------------------------------------->
<!-- Implicit conversions - primitive types                          -->
<!--------------------------------------------------------------------->
<h1 id="implicit-conversions.primitive-types"></h1>
<moveto-doc->
    <p>
        <a href="#primitive-types">Primitive types</a> are all implicitly convertible to each other.<br>
        In Lumina, some conversions have <a href="#undefined-values">undefined result</a>.<br>
        In Aurora, the same conversions cause <a href="#undefined-behaviour">undefined behaviour</a>.<br>
        The result of the conversions follow these rules:
        //TODO use fedisableexcept(FE_ALL_EXCEPT);
        //TODO it only works on  floating points. integers throw exceptions anyway
    </p>

    <div class="table-container"><table>
        <!-- integer -->
            <tr>
                <th colspan="2">From / To</th>
                <th><t->uint</t-></th>
                <th><t->int</t-></th>
                <th><t->ulong</t-></th>
                <th><t->long</t-></th>
                <th><t->float</t-></th>
                <th><t->double</t-></th>
                <th><t->bool</t-></th>
            </tr>

            <tr class="even">
                <th rowspan="13"><t->uint</t-><br><br><t->int</t-><br><br><t->ulong</t-><br><br><t->long</t-></th>
                <th><range-val->== <k->-9223372036854775808</k-><br><range-var->long::min</range-var-></range-val-></th>
                <td class="center wrap conv-cell-m" rowspan="5">Overflows to (-n - <k->1</k->) % (uint::<k->max</k-> - <k->1</k->)</td>
                <td class="center wrap conv-cell-n" rowspan="3">Undefined</td>
                <td class="center wrap conv-cell-m" rowspan="5">Overflows to (-n - <k->1</k->) % (ulong::<k->max</k-> - <k->1</k->)</td>
                <td class="center wrap conv-cell-y" rowspan="11">Correct result</td>
                <td class="center wrap conv-cell-m" rowspan="4">Conversions are not symmetric</td>
                <td class="center wrap conv-cell-m" rowspan="2">Conversions are not symmetric</td>
                <td class="center wrap conv-cell-y" rowspan="5"><k->true</k-></td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&lt; <k->-9007199254740992</k-><br><range-var->double::min_precise_int</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&lt; <k->-2147483648</k-><br><range-var->int::min</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-y" rowspan="8">Correctly rounded</td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&lt; <k->-16777216</k-><br><range-var->float::min_precise_int</range-var-></range-val-></th>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-y" rowspan="5">Correct result</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&lt; <k->0</k-><br><range-var-></range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->== <k->0</k-><br><range-var-></range-var-></range-val-></th>
                <td class="center wrap conv-cell-y" rowspan="4">Correct result</td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-y" rowspan="8">Correct result</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-y"><k->false</k-></td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&gt; <k->0</k-><br><range-var-></range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-y" rowspan="7"><k->true</k-></td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&gt; <k->+16777216</k-><br><range-var->float::max_precise_int</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-m" rowspan="6">Conversions are not symmetric</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&gt; <k->+2147483647</k-><br><range-var->int::max</range-var-></range-val-></th>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&gt; <k->+4294967295</k-><br><range-var->uint::max</range-var-></range-val-></th>
                <td class="center wrap conv-cell-m" rowspan="4">Overflows to n % (uint::<k->max</k-> + <k->1</k->)</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&gt; <k->+9007199254740992</k-><br><range-var->double::max_precise_int</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-m" rowspan="3">Conversions are not symmetric</td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&gt; <k->+9223372036854775807</k-><br><range-var->long::max</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->== <k->+18446744073709551615</k-><br><range-var->ulong::max</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>


        <!-- floating point -->
            <tr>
                <th colspan="2">From / To</th>
                <th><t->uint</t-></th>
                <th><t->int</t-></th>
                <th><t->ulong</t-></th>
                <th><t->long</t-></th>
                <th><t->float</t-></th>
                <th><t->double</t-></th>
                <th><t->bool</t-></th>
            </tr>

            <tr class="even">
                <th rowspan="16"><t->float</t-><br><br><t->double</t-></th>
                <th><range-val->== <k->-inf</k-><br><range-var->-double::inf</range-var-><br><range-var->-float::inf</range-var-></range-val-></th>
                <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
                <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
                <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
                <td class="center wrap conv-cell-n" rowspan="4">Undefined</td>
                <td class="center wrap conv-cell-y" rowspan="1">Correct result</td>
                <td class="center wrap conv-cell-y" rowspan="1">Correct result</td>
                <td class="center wrap conv-cell-y" rowspan="6"><k->true</k-></td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->== <k->-1.7976931348623157081e+308</k-><br><range-var->double::min</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
                <td class="center wrap conv-cell-y" rowspan="13">Correctly rounded</td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&lt; <k->-3.4028234663852885981e+38</k-><br><range-var->float::min</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&lt; <k->-9223372036854775808.0</k-><br><range-var->long::min</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-y" rowspan="9">Correctly rounded</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&lt; <k->-2147483648.0</k-><br><range-var->int::min</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-y" rowspan="6">Correctly rounded</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&lt; <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
                <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->== <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
                <td class="center wrap conv-cell-y" rowspan="3">Correctly rounded</td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-y" rowspan="5">Correctly rounded</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-y" rowspan="1"><k->false</k-></td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&gt; <k->0.0</k-><br><range-var-></range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-y" rowspan="8"><k->true</k-></td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&gt; <k->+2147483647.0</k-><br><range-var->int::max</range-var-></range-val-></th>
                <td class="center wrap conv-cell-n" rowspan="8">Undefined</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&gt; <k->+4294967297.0</k-><br><range-var->uint::max</range-var-></range-val-></th>
                <td class="center wrap conv-cell-n" rowspan="7">Undefined</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&gt; <k->+9223372036854775807.0</k-><br><range-var->long::max</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-n" rowspan="6">Undefined</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&gt; <k->+18446744073709551615.0</k-><br><range-var->ulong::max</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-n" rowspan="5">Undefined</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->&gt; <k->+3.4028234663852885981e+38</k-><br><range-var->float::max</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-n" rowspan="2">Undefined</td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->== <k->+1.7976931348623157081e+308</k-><br><range-var->double::max</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val->== <k->+inf</k-><br><range-var->double::inf</range-var-><br><range-var->float::inf</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-y" rowspan="2">Correct result</td>
                <td class="center wrap conv-cell-y" rowspan="2">Correct result</td>
                <fake-td></fake-td>
            </tr>
            <tr class="even">
                <fake-td></fake-td>
                <th><range-val-><f->isnan</f->(n)<br><br><range-var->double::nan</range-var-><br><range-var->float::nan</range-var-></range-val-></th>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <fake-td></fake-td>
                <td class="center wrap conv-cell-n" rowspan="1">undefined</td>
            </tr>

        <!-- bool -->
            <tr>
                <th colspan="2">From / To</th>
                <th><t->uint</t-></th>
                <th><t->int</t-></th>
                <th><t->ulong</t-></th>
                <th><t->long</t-></th>
                <th><t->float</t-></th>
                <th><t->double</t-></th>
                <th><t->bool</t-></th>
            </tr>

            <tr>
                <th rowspan="2"><t->bool</t-></th>
                <th class="nowrap small"><k->false</k-></th>
                <td class="center wrap conv-cell-y"><k->0</k-></td>
                <td class="center wrap conv-cell-y"><k->0</k-></td>
                <td class="center wrap conv-cell-y"><k->0</k-></td>
                <td class="center wrap conv-cell-y"><k->0</k-></td>
                <td class="center wrap conv-cell-y"><k->0.0</k-></td>
                <td class="center wrap conv-cell-y"><k->0.0</k-></td>
                <td class="center wrap conv-cell-y"><k->false</k-></td>
            </tr>
            <tr>
                <fake-td></fake-td>
                <th class="nowrap small"><k->true</k-></th>
                <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
                <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
                <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
                <td class="center wrap conv-cell-y"><k->1</k-> </k-></td>
                <td class="center wrap conv-cell-y"><k->1.0</k-></td>
                <td class="center wrap conv-cell-y"><k->1.0</k-></td>
                <td class="center wrap conv-cell-y"><k->true</k-></td>
            </tr>
    </table></div>
</moveto-doc->






<!--------------------------------------------------------------------->
<!-- Implicit conversions - enums                                    -->
<!--------------------------------------------------------------------->
<h1 id="implicit-conversions.enums"></h1>
<moveto-doc->
    <p>
        <a href="#expressions">Expressions</a> of enum <a href="#types">types</a> are <a href="#implicit-conversions">implicitly convertible</a> to their base <a href="#types">type</a>
        and those whose base <a href="#types">type</a> is a <a href="#primitive-types">primitive type</a> are implicitly convertible to any <a href="#primitive-types">primitive type</a>,
        following all the <a href="#impliti-conversions">implicit conversion rules</a> their base <a href="#types">type</a> is subject to.
    </p>
</moveto-doc->
<moveto-examples->
    <example->
        <label->Example</label->
        <div>
            <w->enum</w-> <t->e</t-> : <t->int</t-> {
                <k->a</k->, <k->b</k->, <k->c</k->;
            }

            <w->enum</w-> <t->e2</t-> : <t->e</t-> {
                <k->a</k-> = e:<k->b</k->, <k->b</k-> = e:<k->a</k->;
            }

            <t->void</t-> <f->main</f->(){
                <t->int</t->   a = e.<k->b</k->;
                <t->float</t-> b = e.<k->c</k->;

                <t->e</t->   c = e2.<k->a</k->;
                <t->int</t-> d = <k->c</k->;
            }
        </div>
    </example->
</moveto-examples->










<!--------------------------------------------------------------------->
<!-- Implicit conversions - pointer types                            -->
<!--------------------------------------------------------------------->
<h1 id="implicit-conversions.pointer-types"></h1>
<moveto-doc->
    <p>
        All pointer types are implicitly convertible to <code><t->ulong</t-></code> values.
    </p>
</moveto-doc->
<moveto-examples->
    <example->
        <label->Example</label->
        <div>
            <t->void</t-> <f->main</f->(){
                <t->ulong</t-> var = @var;
            }
        </div>
    </example->
</moveto-examples->








<!--------------------------------------------------------------------->
<!-- Implicit conversions - constness conversions                    -->
<!--------------------------------------------------------------------->
<h1 id="implicit-conversions.constness-conversions"></h1>
<moveto-doc->
    <p>
        Non-<code><t->const</t-></code> pointer types are implicitly convertible to their respective <code><t->const</t-></code> pointer type.<br>
        If the base type is itself a pointer type, then it must be convertible to the base type of the target type.<br>
        For instance, an <code><t->int@</t-></code> expression would be convertible to <code><t->int const@</t-></code> only,
        and an <code><t->int const@ const@</t-></code> would be convertible to <code><t->int@ const@</t-></code>, <code><t->int const@@</t-></code> and <code><t->int@@</t-></code>.
    </p>
    <p>
        This also applies to const pointer types used as part of function types, with the added constraint that
        all of the pointer types used in the source function type must be implicitly convertible to their respective pointer types in the target function type.
    </p>
</moveto-doc->
<moveto-examples->
    <example->
        <label->Example 1</label->
        <div>
            <t->void</t-> <f->main</f->(){
                <t->int</t-> <k->n</k->;
                <t->int</t-> <t->const</t->@ p = $<k->n</k->;    <c->// Ok, non-const to const conversion</c->
                <c->//int@ p2 = p;</c->        <ce->// Error, cannot convert int const@ to int@</ce->
            }
        </div>
        <label->Example 2</label->
        <div>
            <t->void</t-> <f->main</f->(){
                <t->double const@</t->(<t->float@</t->, <t->float const@ const@</t->) f;
                <f->f</f-> <f->=</f-> <t->double@</t->(<t->float@</t-> <p->a</p->, <t->float@@</t-> <p->b</p->) { <w->return</w-> <k->0</k->; };              <c->// Ok</c->
                <f->f</f-> <f->=</f-> <t->double</t-> <t->const@</t->(<t->float@</t-> <p->a</p->, <t->float@</t-> <t->const@</t-> <p->b</p->) { <w->return</w-> <k->0</k->; };  <c->// Ok</c->
                <c->//f = double const @(float const@ a, float@ const@ b) { return 0; };</c->
                <ce->//  ^ Error, cannot convert double const@(float const@, float@ const@) to double const@(float@, float const@ const@)</ce->
            }
        </div>
    </example->
</moveto-examples->






