

<!--------------------------------------------------------------------->
<!-- Routines                                                        -->
<!--------------------------------------------------------------------->
<h1 id="routines"></h1>
<p>
    <b>Routines</b> are the <b>main component</b> of the <b>language</b>. They contain the <a href="#statements"><b>statements</b></a> that will be executed during runtime.<br>
    They are used to organize the module, provide features and prevent code duplication.<br>
    The routine execution starts from its first <a href="#statements">statement</a> and ends after the first encountered <a href="#return-statements">return statement</a>.
</p>
<p>
    There are 2 types of routines: <a href="#declarations.functions">Functions</a> and <a href="#declarations.operators">Operators</a>.<br>
    They use different signatures and <a href="#routine-calls">calling</a> syntaxes but share the same <a href="#declarations.routine-parameters">parameter</a> and body declarations.
</p>
<p>
    Each routine can <a href="#return-statement">return</a> a single value when <a href="#routine-calls">called</a>.<br>
    The <a href="#types">type</a> of the <a href="#return-statement">returned</a> value is defined by the <a href="#types">type</a> of the routine.<br>
    Routines that don't return a value have to be declared using the <code><t->void</t-></code> type.
</p>
<p>
    The <a href="#const-qualifier"><code><w->const</w-></code> qualifier</a> cannot be applied to routines.
</p>





<!--------------------------------------------------------------------->
<!-- Functions                                                       -->
<!--------------------------------------------------------------------->
<h1 id="functions"></h1>




<!--------------------------------------------------------------------->
<!-- Function declarations                                           -->
<!--------------------------------------------------------------------->
<h1 id="function-declarations"></h1>
<p>
    <b>Functions</b> are a type of <b><a href="declarations.routines">routine</a></b> that requires parentheses to be called.<br>
    They always use the infix notation and can take any number of <a href="#declarations.routine-parameters">parameters</a>.
</p>
<p>
    Function <a href="#identifiers">identifiers</a> must be alphanumeric.
</p>
<syntax->
    <label- id="copy.syntax--declaration-function">Declaration syntax</label->
    <label- id="copy.syntax--declaration-function-signature">Function signature</label->
    <label- id="copy.syntax--declaration-routine-body">Routine body</label->
    <label- id="copy.syntax--declaration-specialization-constraint">Specialization constraint</label->
</syntax->
<example->
    <label->Example - Add function</label->
    <div>
        <t->int</t-> <f->add</f->(<t->int</t-> <p->a</p->, <t->int</t-> <p->b</p->){
            <w->return</w-> a + b;
        }

        <t->void</t-> <f->main</f->(){
            <t->int</t-> n = </t-><f->add</f->(<k->4</k->, <k->6</k->)
        }
    </div>
</example->





<!--------------------------------------------------------------------->
<!-- The main function                                               -->
<!--------------------------------------------------------------------->
<h1 id="the-main-function"></h1>
<p>
    The <b><code><f->main</f-></code> function</b> is where the <b>code execution starts and ends</b>.<br>
    Every module passed to the compiler <b>must define</b> a <b><code><f->main</f-></code></b> function.<br>
</p>
<p>
    //TODO interaction btween the languages
</p>
<p>
    The main function cannot use templates and cannot be <a href="#routine-specialization">specialized</a> in any way.
</p>














<!--------------------------------------------------------------------->
<!-- Default values                                                  -->
<!--------------------------------------------------------------------->
<h1 id="default-values"></h1>
<p>
    <b>Default values</b> are used to <b>initialize</b> the routine parameter <b>when no argument is provided</b>.<br>
    They are defined in the same way as <a href="#variables">variable initializer values</a>.<br>
    Both normal and <a href="#reference-parameters">reference parameters</a> can have default values.
</p>
<p>
    A function can have multiple parameters <b>with</b> a default value, but they must all be declared <b>after</b> the <b>last</b> parameter that <b>doesn't have one</b>.<br>
    Parameters of <a href="#operators">operators</a> cannot have default value.
</p>
<example->
    <label->Example</label->
    <div>
        <w->import</w-> <s->&lt;math&gt;</s->;
        <t->double</t-> <f->pow</f->(<t->double</t-> <p->a</p->, <t->double</t-> <p->b</p-> = <k->2</k->) {
            <w->return</w-> math.<f->pow</f->(a, b);
        }

        <t->void</t-> <f->main</f->(){
            <f->pow</f->(<k->3</k->, <k->3</k->);  <c->// Returns 27</c->
            <f->pow</f->(<k->3</k->);     <c->// Returns 9</c->
        }
    </div>
</example->









<!--------------------------------------------------------------------->
<!-- Parameter packs                                                 -->
<!--------------------------------------------------------------------->
<h1 id="parameter-packs"></h1>
<p>
    <b>Parameter packs</b> allow <a href="#functions">functions</a> to take an <b>arbitrary number</b> of <b>arguments</b>.<br>
    They are decalred in the same way as <a href="#routine-parameters">routine parameters</a>, but their name is followed by the <code>...</code> <a href="#meta-keywords">meta keyword</a> and their type can be a <a href="#template-parameter-packs">template parameter pack</a>.<br>
    When a <a href="#template-parameter-packs">template parameter pack</a> is used as type, each element of the parameter pack can have a different type. The types are defined by the passed arguments.<br>
    When a <a href="#types">type</a> or a type <a href="#templates">template parameter</a> is used, all the arguments have the same type. The type is determined by following the implicit conversion rules for template routine calls.//TODO link
</p>
<p>
    Parameter packs take zero or more arguments and can only be used as arguments in routine calls or template paths.<br>
    The taken arguments are the ones that remain after all the routine parameters have been assigned their argument. Parameters with default values take priority over the arguments.<br>
    Arguments and parameter pack elements are all initialized in the same order in which they were declared.
</p>
<p>
    Each <a href="#funcitons">function</a> can only use a single parameter pack.<br>
    <a href="#operators">Operators</a> cannot use parameter packs.
</p>
<syntax->
    <label- id="copy.syntax--declaration-function-parameter-pack">Declaration syntax</label->
</syntax->
<example->
    <label->Example 1</label->
    <div>
        <w->struct</w-> <t->NoArg</t-> { };

        <c->// This function returns the value of the argument in the middle, or a value of type NoArg if an even number of arguments is passed</c->
        <w->template</w-> &lt;<w->type</w-> <t->t</t->, <w->type</w-> <t->u</t->..., <w->type</w-> <t->v</t->&gt; <t->auto</t-> <f->get_middle_arg</f->(<t->t</t-> <p->l</p->, <t->u</t-> <p->c</p->..., <t->v</t-> <p->r</p->) {
            <w->return</w-> <f->get_middle_arg</f->(c);
        }
        <w->template</w-> &lt;<w->type</w-> <t->t</t->, <w->type</w-> <t->u</t->&gt; <t->NoArg</t-> <f->get_middle_arg</f->(<t->t</t-> <p->l</p->, <t->u</t-> <p->r</p->) {
            <w->return</w-> { };
        }
        <w->template</w-> &lt;<w->type</w-> <t->t</t->&gt; <t->t</t-> <f->get_middle_arg</f->(<t->t</t-> <p->c</p->) {
            <w->return</w-> c;
        }


        <t->void</t-> <f->main</f->(){
            <t->auto</t-> a = <f->get_middle_arg</f->(<k->5</k->, <k->false</k->, <k->1</k->, <k->17</k->, <k->true</k->);  <c->// a has type ulong and value 1</c->
            <t->auto</t-> b = <f->get_middle_arg</f->(<k->1</k->, <k->2</k->);                   <c->// b has type NoArg</c->
        }
    </div>
</example->
<p>
    Parameter packs can be used in conjunction with the <a href="#abbreviated-template-syntax">abbreviated template syntax</a>.<br>
    This is explained in <a href="#abbreviated-template-syntax">Abbreviated template syntax</a>.
</p>
<example->
    <label->Example 2 - Summation function</label->
    <div>
        <t->auto</t-> <f->sum</f->(?<t->t</t-> <p->a</p->, ?<t->u</t->... <p->vals</p->...) {
            <w->return</w-> a <f->+</f-> <f->sum</f->(vals);
        }
        <t->auto</t-> <f->sum</f->(?<t->t</t-> <p->a</p->, ?<t->u</t-> <p->b</p->) {
            <w->return</w-> a <f->+</f-> b;
        }


        <t->void</t-> <f->main</f->(){
            <t->int</t-> n = <k->5</k->;
            <t->float</t-> r = <f->sum</f->(<k->5.9</k->, <k->n</k->, <k->1</k->, <k->true</k->);  <c->// r has value 12.9</c->
        }
    </div>
</example->









<!--------------------------------------------------------------------->
<!-- Operators                                                       -->
<!--------------------------------------------------------------------->
<h1 id="operators"></h1>



<!--------------------------------------------------------------------->
<!-- Operator declarations                                           -->
<!--------------------------------------------------------------------->
<h1 id="operator-declarations"></h1>
<p>
    <b>Operators</b> are a type of <b><a href="#declarations.routines">routine</a></b> that doesn't require parentheses to be <a href="#routine-calls">called</a> and can use <b>multiple <a href="#identifiers">identifiers</a></b>.<br>
    Each <a href="#identifiers">identifier</a> can be prefix, infix or postfix, depending on where it is declared in the operator signature.<br>
    Operators can take any number of <a href="#declarations.routine-parameters">parameters</a>, but they cannot be 0 and must be separated by exactly 1 <a href="#identifiers">identifier</a>.
</p>
<p>
    Operator <a href="#identifiers">identifiers</a> can be alphanumeric or symbolic.<br>
    Declaring consecutive <a href="#idnetifiers">identifiers</a> is not allowed.<br>
    Operator precedence is explained in <a href="#declarations.operator-precedence">Operator precedence</a>.
</p>
<syntax->
    <label- id="copy.syntax--declaration-operator">Declaration syntax</label->
    <label- id="copy.syntax--declaration-operator-signature">Operator signature</label->
    <label- id="copy.syntax--declaration-routine-body">Routine body</label->
    <label- id="copy.syntax--declaration-specialization-constraint">Specialization constraint</label->
</syntax->
<example->
    <label->Example 1 - Promotion operator</label->
    <div>
        <t->int</t-> <f->+</f-> (<t->int</t-> <p->n</p->) <w->priority</w->(<k->3</k->) {
            <w->return</w-> n;
        }

        <t->void</t-> <f->main</f->(){
            <t->int</t-> r = <f->+</f->2;
        }
    </div>
</example->
<example->
    <label->Example 2 - Python-like ternary operator</label->
    <div>
        <t->int</t-> (<t->int</t-> <p->a</p->) <f->if_</f-> (<t->bool</t-> <p->condition</p->) <f->else_</f-> (<t->int</t-> <p->b</p->) <w->priority</w->(<k->15</k->) {
            <w->if</w->(condition) <w->return</w-> a;
            <w->else</w-> <w->return</w-> b;
        }

        <t->void</t-> <f->main</f->(<t->bool</t-> <p->c</p->){
            <t->int</t-> r = 5 <f->if_</f-> c <f->else_</f-> 6;
        }
    </div>
</example->









<!--------------------------------------------------------------------->
<!-- Operator precedence                                             -->
<!--------------------------------------------------------------------->
<h1 id="operator-precedence"></h1>
<p>
    In <b>absence</b> of <b>parentheses</b>, the order in which <b><a href="#declarations.operators">operators</a></b> in the <b>same <a href="#expressions">expression</a></b> are <b><a href="#operator-calls">called</a></b> depends on their <b>priority</b> and <b>associativity</b>.<br>
    Priority and associativity are specified in the <a href="#declarations.operators">operator signature</a> as a <a href="#compile-time-expressions">compile time</a> <a href="#integral-types"><code><t->ulong</t-></code></a> <a href="#expressions">expression</a>
    ranging from <code><k->0</k-></code> to <code><k->15</k-></code>, followed by the <code><w->r</w-></code> or <code><w->l</w-></code> <a href="#meta-keywords">meta keyword</a>.<br>
</p>
<p>
    The value indicates the priority.<br>
    Operators declared with lower values have higher priority and are evaluated first.<br>
    Left-associative operators are always evaluated before right-associative operators with the same priority.
</p>
<p>
    The <code><w->r</w-></code> and <code><w->l</w-></code> <a href="#meta-keywords">meta keywords</a> indicate right and left associativity.<br>
    Associativity defines the order in which operators with the same priority and associativity are evaluated.<br>
    Right-associative operators are evaluated starting from the right, whilst left-associative operators are evaluated starting from the left.<br>
</p>
<example->
    <label->Example 1 - Priority</label->
    <div>
        <t->int</t-> (<t->int</t-> <p->a</p->) <f->o</f-> (<t->int</t-> <p->b</p->) <w->priority</w->(<k->4</k-> <w->l</w->) {
            <w->return</w-> a <f->+</f-> b <f->*</f-> b;
        }

        <t->int</t-> (<t->int</t-> <p->a</p->) <f->p</f-> (<t->int</t-> <p->b</p->) <w->priority</w->(<k->4</k-> <w->r</w->) {
            <w->return</w-> a <f->*</f-> 2 <f->+</f-> b;
        }

        <t->int</t-> (<t->int</t-> <p->a</p->) <f->q</f-> (<t->int</t-> <p->b</p->) <w->priority</w->(<k->5</k-> <w->r</w->) {
            <w->return</w-> b <f->-</f-> a;
        }

        <t->void</t-> <f->main</f->(<t->int</t-> <p->a</p->, <t->int</t-> <p->b</p->, <t->int</t-> <p->c</p->){
            <c->// Evaluated as ((a o (b p c)) q a)</c->
            <t->int</t-> r = a <f->o</f-> b <f->p</f-> c <f->q</f-> a;
        }
    </div>
</example->
<example->
    <label->Example 2 - Associativity</label->
    <div>
        <t->int</t-> (<t->int</t-> <p->a</p->) <f->o</f-> (<t->int</t-> <p->b</p->) <w->priority</w->(<k->4</k-> <w->l</w->) {
            <w->return</w-> a <f->+</f-> b <f->*</f-> b;
        }

        <t->int</t-> (<t->int</t-> <p->a</p->) <f->p</f-> (<t->int</t-> <p->b</p->) <w->priority</w->(<k->4</k-> <w->l</w->) {
            <w->return</w-> a <f->*</f-> 2 <f->+</f-> b;
        }

        <t->void</t-> <f->main</f->(<t->int</t-> <p->a</p->, <t->int</t-> <p->b</p->, <t->int</t-> <p->c</p->){
            <c->// Evaluated as ((a o b) p c)</c->
            <t->int</t-> r = a <f->o</f-> b <f->p</f-> c
        }
    </div>
</example->






<!--------------------------------------------------------------------->
<!-- Routine parameters                                              -->
<!--------------------------------------------------------------------->
<h1 id="routine-parameters"></h1>





<!--------------------------------------------------------------------->
<!-- Parameter delcarations                                          -->
<!--------------------------------------------------------------------->
<h1 id="parameter-declarations"></h1>
<p>
    Routine parameters are named memory locations used to pass arguments to <a href="#routine-calls">routine calls</a>.<br>
    A routine parameter can be a normal parameter, a <a href="#reference-parameters">reference parameter</a> or a <a href="#parameter-packs">parameter pack</a>.
</p>
<p>
    They work in the same way as <a href="#variables">variables</a>, but the initializer value is defined by the caller routine or copied from the <a href="#default-values">default value</a>.<br>
    As with <a href="#variables">variables</a>, routine parameters are first allocated and then initialized by calling the <code>=</code> operator, one parameter at a time, following the order in which they were declared.
</p>
<syntax->
    <label- id="copy.syntax--declaration-routine-parameter">Declaration syntax</label->
</syntax->
<example->
    <label->Example</label->
    <div>
        <t->int</t-> <f->add</f->(<t->uint</t-> <p->a</p->, <t->uint</t-> <p->b</p->) {
            <w->return</w-> a <f->+</f-> b;
        }

        <t->void</t-> <f->main</f->(){
            <t->uint</t-> a = <k->5</k->;
            <t->uint</t-> r = <f->add</f->(<k->a</k->, <k->6</k->);
        }
    </div>
</example->










<!--------------------------------------------------------------------->
<!-- Reference parameters                                            -->
<!--------------------------------------------------------------------->
<h1 id="reference-parameters"></h1>
<p>
    <b>Reference parameters</b> use the <b>address of the argument</b> as <b>initializer value</b> instead of the argument itself. This doesn't apply to their <a href="#default-values">default value</a>.<br>
    They are declared by preceding the name of the parameter with the <code>&</code> <a href="#meta-keywords">meta keyword</a>.<br>
</p>
<p>
    Reference parameters can only be of <a href="#pointer-types">pointer type</a> and the passed arguments must be <a href="#left-and-right-values">l-values</a>.<br>
    Inside the <a href="#routines">routine</a>, reference parameters act exactly as normal parameters.
</p>
<example->
    <label->Example</label->
    <div>
        <t->void</t-> <f->halve</f->(<t->float</t->@ &<p->n</p->) {
            @n <f->/=</f-> <k->2</k->;
        }

        <t->void</t-> <f->main</f->(){
            <t->float</t-> n = <k->8</k->;    <c->// n has value 8</c->
            <f->halve</f->(<k->n</k->);       <c->// n has value 4</c->
            <c->//halve(8);</c->     <ce->// Error, 8 is not an l-value</ce->
        }
    </div>
</example->














<!--------------------------------------------------------------------->
<!-- Routine overloarding                                            -->
<!--------------------------------------------------------------------->
<h1 id="routine-overloading"></h1>
<p style="margin-bottom: 0;">
    <b>Routine overloading</b> allows routines to <b>act differently</b> based on the numer of arguments <b>in each routine call</b>, their types and the value of any compile time value accessible from their declaration.<br>
    This is achieved by declaring the same routine multiple times. Each declaration must be <b>unique</b> and can differ by:
</p>
<ul><ul>
    <li>Number of parameters (and position of the parameters for operators)</li>
    <li>Types of the parameters</li>
    <li>Suitability constraints</li>
</ul></ul>
<br>
<p style="margin-bottom: 0;">
    Declarations that have less than <i>#a</i> parameters or more than <i>#a</i> parameters without a default value (and for operators, those whose position of the parameters don't match with the position of the arguments in the operator call) are discarded.<br>
    <span class="small hidden">[with <i>#a</i> = number of passed arguments]</span><br>
    <br>
    The remaining declarations are organized in categories and the best one is chosen from one of these.<br>
    The categories are checked one at a time, starting from the first. If no declaration is found, the next category is checked.<br>
    If 2 or more declarations are found withing the same category, the routine call is ambiguous and a semantic error is generated.<br>
    If no declaration is found after all the categories have been checked, a suitable declaration doesn't exist and a semantic error is generated.
</p>
<ol style="list-style: lower-alpha;">
    <li>Declarations that can take all the parameters without performing implicit conversions.</li>
    <li>Declarations that can take all the parameters by performing one or more constness-only implicit conversions.</li>
    <li>Declarations that can take all the parameters by performing one or more implicit conversions of any kind.</li>
</ol>
<br>
<split-example-container->
    <split-example-container-left->
        <example->
            <label->Example 1</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;

                <t->void</t-> <f->f</f->(<t->int</t-> <t->const@</t-> <p->p</p->){
                    io.<f->print</f->(<s->"a"</s->);
                }
                <t->void</t-> <f->f</f->(<t->int@</t-> <p->p</p->){
                    io.<f->print</f->(<s->"b"</s->);
                }
                <t->void</t-> <f->f</f->(<t->ulong</t-> <p->p</p->){
                    io.<f->print</f->(<s->"c"</s->);
                }


                <t->void</t-> <f->main</f->(){
                    <t->const</t-> <t->int</t-> n1;
                    <t->int</t->       n2;
                    <t->float</t->     n3;

                    <f->f</f->(@n1);   <c->// No implicit conversions</c->
                    <f->f</f->(@n2);   <c->// 1 constness-only implicit conversion</c->
                    <f->f</f->(@n3);   <c->// 1 implicit conversion</c->
                    <f->f</f->(<k->0.5</k->);   <c->// No implicit conversions</c->
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example->
            <label->Output</label->
            <div>
                abcc<cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->
<p style="margin-bottom: 0;">
    Declarations with parameter packs and/or templates undergo an additional instantiation phase before the best declaration is chosen, in which these features are replaced with standard types and parameters.<br>
    Generated declarations whose number of arguments and argument types are identical to the ones in declarations already defined by the user and any declaration whose suitability constraint is not satisfied are discarded
</p>
<ol style="list-style: decimal;">
    <li>
        Each declaration that uses a function parameter pack and has <i>#a</i> or less parameters has its parameter pack replaced with the exact number of parameters of the correct type in order to bring the total to exactly <i>#a</i>.<br>
        <span class="small hidden">[with <i>#a</i> = number of passed arguments]
    </li>
    <li>
        Each declaration that uses template types in its parameters has these types replaced with the correct type, following the implicit conversion rules for template calls.
    </li>
</ol>
<split-example-container->
    <split-example-container-left->
        <example->
            <label->Example 2</label->
            <div>
                <w->import</w-> <s->&lt;io&gt;</s->;

                <t->void</t-> <f->f</f->(?<t->t</t->... <p->args</p->...){
                    io.<f->print</f->(<s->"More than one argument provided\n"</s->);
                }
                <t->void</t-> <f->f</f->(?<t->t</t-> <p->arg</p->) {
                    io.<f->print</f->(<s->"The first argument is not a double\n"</s->);
                }
                <t->void</t-> <f->f</f->(<t->double</t-> <p->arg</p->) {
                    io.<f->print</f->(<s->"The first argument is a double\n"</s->);
                }


                <t->void</t-> <f->main</f->(){
                    <f->f</f->(<k->1</k->);
                    <f->f</f->(<k->1.0</k->);
                    <f->f</f->(<k->1.0</k->, <k->2</k->);
                }
            </div>
        </example->
    </split-example-container-left->
    <split-example-container-right->
        <example->
            <label->Output</label->
            <div>
                The first argument is not a double
                The first argument is a double
                More than one argument provided
                <cursor-></cursor->
            </div>
        </example->
    </split-example-container-right->
</split-example-container->